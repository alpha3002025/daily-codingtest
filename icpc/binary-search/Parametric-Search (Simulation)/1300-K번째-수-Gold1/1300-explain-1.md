# 백준 1300번: K번째 수

## 문제 분석
N x N 크기의 2차원 배열 A가 있고, `A[i][j] = i * j` (1-indexed)로 정의됩니다. 이 배열의 모든 원소를 1차원 배열 B에 넣고 오름차순으로 정렬했을 때, K번째 수(`B[k]`)를 구하는 문제입니다.

- **N의 범위**: $1 \le N \le 10^5$
- **K의 범위**: $1 \le K \le \min(10^9, N^2)$

N이 최대 $10^5$이므로 배열의 원소 개수는 $N^2 = 10^{10}$개가 될 수 있습니다. 이는 메모리에 모든 수를 저장하거나 정렬할 수 없는 크기입니다. 따라서 $O(N^2)$이나 $O(N^2 \log(N^2))$ 방식으로는 풀 수 없습니다.

## 핵심 아이디어: 이분 탐색 (Binary Search)
우리가 구하고자 하는 값(K번째 수)을 `ans`라고 합시다. 이 `ans`에 대해 "배열 A에 `ans`보다 작거나 같은 수의 개수가 K개 이상인가?"라는 결정 문제(Decision Problem)를 만들 수 있습니다.

이 결정 문제는 `ans`가 커질수록 "작거나 같은 수의 개수"가 단조 증가하는 성질이 있으므로, 이분 탐색(Parametric Search)을 적용할 수 있습니다.

### 탐색 범위 설정
- **Lower Bound (lo)**: 1 (가장 작은 수)
- **Upper Bound (hi)**: $K$ (또는 $N^2$. 하지만 K번째 수는 $K$를 넘을 수 없다는 성질을 이용하면 $K$로 줄일 수도 있습니다.) 
  - *Note*: 실제로 $1 \times 1, 1 \times 2, \dots$ 순으로 증가하므로, 단순히 $N^2$을 상한으로 잡는 것이 안전하고 직관적입니다. 여기서는 편의상 $K$를 최댓값으로 잡아도 무방합니다. (1부터 K까지의 자연수가 있다고 쳤을 때 K번째는 K이므로 A배열의 값들이 1, 2, ... K 보다 듬성듬성하더라도 K번째 수는 K보다 작거나 같음이 보장됩니다.)

### 결정 함수: `count_less_equal(x)` 구현
임의의 수 $x$에 대해, 배열 A에서 $x$보다 작거나 같은 수의 개수를 어떻게 효율적으로 셀 수 있을까요?

$A[i][j] = i \times j$ 이므로, $i \times j \le x$ 조건을 만족하는 $j$의 개수를 구해야 합니다.
이를 $j$에 대해 정리하면 $j \le x / i$ 입니다.

각 행 $i$ (1부터 N까지)에 대해:
- 해당 행에서 $x$보다 작거나 같은 수의 개수는 $\lfloor x / i \rfloor$ 개입니다.
- 단, $j$는 $N$을 넘을 수 없으므로, 실제 개수는 $\min(N, \lfloor x / i \rfloor)$가 됩니다.

이 과정을 $i=1$부터 $N$까지 반복하여 합산하면, 전체 배열에서 $x$ 이하인 수의 개수를 $O(N)$에 구할 수 있습니다.

## 알고리즘 흐름
1. `lo = 1`, `hi = K`로 초기화합니다.
2. `lo <= hi`인 동안 반복합니다:
   - `mid = (lo + hi) // 2`
   - `count = count_less_equal(mid)`
   - 만약 `count >= K`라면:
     - `ans = mid` (현재 `mid`가 K번째 수의 후보가 됨)
     - `hi = mid - 1` (더 작은 값에서 가능한지 탐색)
   - 만약 `count < K`라면:
     - `lo = mid + 1` (더 큰 값을 탐색해야 함)
3. 최종적으로 구해진 `ans`를 출력합니다.

## 시간 복잡도
- 이분 탐색의 범위가 최대 $K$ (또는 $N^2$) 이므로 반복 횟수는 약 $\log(K)$ 입니다.
- 매 반복마다 `count_less_equal` 함수에서 $O(N)$이 소요됩니다.
- 총 시간 복잡도: **$O(N \log K)$**
  - $N=10^5$, $K=10^9$일 때, $10^5 \times 30 \approx 3 \times 10^6$ 연산으로 1초 내에 충분히 통과 가능합니다.
