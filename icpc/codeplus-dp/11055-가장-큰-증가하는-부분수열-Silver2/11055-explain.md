# 11055 가장 큰 증가하는 부분 수열

## 문제 이해
수열 A가 주어졌을 때, 그 부분 수열 중 증가하는 부분 수열(LIS: Longest Increasing Subsequence 변형) 중에서 합이 가장 큰 것을 구하는 문제입니다.

예를 들어, 수열 A = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 인 경우,
- {1, 100} -> 합 101
- {1, 2, 50, 60} -> 합 113
- {1, 3, 5, 6, 7, 8} -> 합 30

가장 큰 합은 113입니다.

## 풀이 접근 (Dynamic Programming)
기본적인 LIS(가장 긴 증가하는 부분 수열) 문제와 유사하지만, "길이"가 아닌 "합"을 최대로 만들어야 합니다.

`dp[i]`를 **A[i]를 마지막 원소로 가지는 증가하는 부분 수열의 최대 합**이라고 정의합니다.

### 점화식
1. 초기값: `dp[i] = A[i]` (자기 자신만 포함하는 경우)
2. `i`번째 원소(`A[i]`)를 마지막으로 하기 위해서는, `0`부터 `i-1`까지의 인덱스 `j`에 대해 다음 조건을 만족해야 합니다.
   - `A[j] < A[i]` (증가하는 수열이어야 함)
3. 위 조건을 만족하는 `j`들 중에서 `dp[j]`가 가장 큰 값을 선택하여 `A[i]`를 더합니다.
   
   $$dp[i] = \max(dp[i], dp[j] + A[i]) \quad \text{if } A[j] < A[i]$$

4. 최종 정답은 `max(dp)`가 됩니다.

### 시간 복잡도
이중 반복문을 사용하므로 $O(N^2)$입니다.
N의 범위가 1,000 이하이므로 충분히 통과 가능합니다.

## Python 코드

```python
import sys

def solve():
    # 입력 받기
    # n: 수열의 크기 (1 <= n <= 1,000)
    n = int(sys.stdin.readline())
    # a: 수열
    a = list(map(int, sys.stdin.readline().split()))

    # dp[i]: a[i]를 마지막으로 하는 가장 큰 증가하는 부분 수열의 합
    # 초기값은 해당 숫자 자체 (자기 자신만 있는 경우)
    dp = [x for x in a]

    for i in range(n):
        for j in range(i):
            if a[j] < a[i]:
                # 이전 원소(a[j])가 현재 원소(a[i])보다 작다면 (증가 조건)
                # 현재 dp[i]와 dp[j] + a[i] 중 더 큰 값으로 갱신
                dp[i] = max(dp[i], dp[j] + a[i])

    print(max(dp))

if __name__ == "__main__":
    solve()
```

## 예제 풀이
입력:
```
10
1 100 2 50 60 3 5 6 7 8
```

DP 테이블 변화:
- `i=0, A[0]=1`: dp[0] = 1
- `i=1, A[1]=100`: 1 < 100 이므로 dp[1] = max(100, dp[0]+100) = 101
- `i=2, A[2]=2`: 1 < 2 이므로 dp[2] = max(2, dp[0]+2) = 3
- `i=3, A[3]=50`: 1 < 50, 2 < 50. dp[3] = max(50, dp[0]+50(51), dp[2]+50(53)) = 53
- `i=4, A[4]=60`: 50 < 60 등. dp[4] = max(..., dp[3]+60(113)) = 113
...
최대값: 113
