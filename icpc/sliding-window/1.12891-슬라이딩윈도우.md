# icpc12891. DNA 비밀번호

나는 슬라이딩 윈도우가 제일 약하다.
연습을 해야 한다.

# 1. 핵심 아이디어
## 처음 윈도우 계산 (1 ~ len(P)-1)
```python
## ...

## 1단계
for i in range(4):
    if dna_counts[i] == 0:
        match_cnt+=1

## 2단계: dna_counts 에 맞는지 체크 (1~len(P)-1 까지 순회)
for i in range(P):
    window_plus(secret_string[i])

if match_cnt == 4:
    result += 1
```

- 1단계 : 0 인 것들의 개수를 카운팅
- 2단계 : `0 ~ i ~ P-1` 동안 c 가 A,C,G,T 중 하나에 맞을 경우 `window[k]` 를 올려서 카운트하고, 그 카운트한 값이 `dna_counts[k]` 에 도달할 경우(원하는 값에 도달) `match_cnt+=1` 한다.

(Claude) 정리해보면 다음과 같다.<br/>
1단계 : 초기값 설정
```python
for i in range(4):
    if dna_counts[i] == 0:
        match_cnt+=1
```
- 목적: 요구 개수가 0인 문자들은 이미 조건을 만족한 것으로 처리
- 예: dna_counts = [1, 0, 2, 0]이면 C, T는 0개 필요하므로 match_cnt = 2

<br/>

2단계 : 실제 윈도우 구성
```python
for i in range(P):  # 0부터 P-1까지
    window_plus(secret_string[i])
```
window_plus 함수 내부에서:
- `secret_string[i]`가 A, C, G, T 중 하나라면
- 해당하는 `window[k]` 증가
만약 `window[k] == dna_counts[k]`가 되면 → `match_cnt += 1`

<br/>

### 참고) 반례
`dna_counts[k]=0` 인 요소들을 카운트했는데 나중에 window 내에서 카운트가 될 일이 없는지 생각할 수 있다. 실제로 내가 그랬다. 인간의 생각은 논리적이지 않기에 안되는 부분을 생각하게 된다.<br/>

직접 생각해보니 그럴일은 없었다. `dna_counts[k]=0` 이라는 것은 문제에서 원하지 않는다는 것이고, for loop 에서도 `==` 조건 검사에서 부합되지 않게 될 것이기 때문이다.<br/>
<br/>

## 2. 윈도우 이동 절차
눈으로 이해해도 변수의 변화 절차를 좀 명확하게 파악해야 해서 그려본 그림
![](./img/12891/icpc-12891-sliding-window-move-2.png)

## python
```python
import sys

S, P = map(int, sys.stdin.readline().strip().split())
secret_string = list(sys.stdin.readline().strip())

dna_counts = list(map(int, sys.stdin.readline().strip().split()))
match_cnt = 0
window = [0]*4 

def window_plus(c):
    global dna_counts, match_cnt, window

    if c == 'A':
        window[0]+=1
        if window[0] == dna_counts[0]:
            match_cnt+=1
    elif c == 'C':
        window[1]+=1
        if window[1] == dna_counts[1]:
            match_cnt+=1
    elif c == 'G':
        window[2]+=1
        if window[2] == dna_counts[2]:
            match_cnt+=1
    elif c == 'T':
        window[3]+=1
        if window[3] == dna_counts[3]:
            match_cnt+=1

def window_minus(c):
    global dna_counts, match_cnt, window

    if c == 'A':
        if window[0] == dna_counts[0]:
            match_cnt-=1
        window[0]-=1
    elif c == 'C':
        if window[1] == dna_counts[1]:
            match_cnt-=1
        window[1]-=1
    elif c == 'G':
        if window[2] == dna_counts[2]:
            match_cnt-=1
        window[2]-=1
    elif c == 'T':
        if window[3] == dna_counts[3]:
            match_cnt-=1
        window[3]-=1

result = 0

for i in range(4):
    if dna_counts[i] == 0:
        match_cnt+=1

for i in range(P):
    window_plus(secret_string[i])

if match_cnt == 4:
    result += 1

for i in range(P, S):
    j = i - P ## e.g. S=9, P=5 =>  j = 0,1,2,3
              ##                   i = 5,6,7,8
    window_plus(secret_string[i]) # + 카운트 (오른쪽 이동(i(5,6,7,8)의 이동))
    window_minus(secret_string[j]) # - 카운트 (잔여 카운트 원상복구(j(0,1,2,3)의 이동))
    if match_cnt == 4:
        result += 1

print(result)
```