이 문제가 처음에 어렵게 느껴지는 이유는 규칙을 말로 숨겨놔서이다.
정직하게 설명해서
- 연속으로 두잔을 마실수는 있지만 3잔을 연속으로 마실수 없습니다.
이렇게 설명하지는 않는다.

- 연속으로 3잔을 마실수는 없습니다.
라고 설명한다.

최대한 많은 잔을 마셔야 한다면 어떻게 해야할까?

- 연속 두잔을 마셨을때 + T(i)
- T(i-1) + T(i)
이 둘의 합을 구하는 것을 계속 누적해나가야한다.

굉장히 기본적인 문제여서 문제 의도가 너무 정직하게 보이기 때문에
조금 더 꼬기 위해서 
- 연속으로 3잔을 마실 수 는 없습니다.
라는 문구로 의미를 숨겨두지 않았나... 하는 생각이 들고 굳이 문제에 말을 이런식으로 애매하게 만드는건 좀 쪼잔하다 싶은?느낌이다.




# (2) [BOJ 2156 포도주 시식](https://www.acmicpc.net/problem/2156)

## 문제, 참고자료
- [백준 2156](https://www.acmicpc.net/problem/2156)
- [Java 문제풀이 (Top Down, Bottom UP 방식 모두)](https://st-lab.tistory.com/135) 
- [Java 문제풀이 (백트래킹 방식)](https://propercoding.tistory.com/73) 
- [Java 문제풀이 (동적프로그래밍 방식)](https://velog.io/@yanghl98/%EB%B0%B1%EC%A4%80-2156-%ED%8F%AC%EB%8F%84%EC%A3%BC-%EC%8B%9C%EC%8B%9D)
- [python 문제풀이](https://jinho-study.tistory.com/991)

<br/>

## 문제풀이 아이디어 (procedure)
```python
"""
dp[3] = max(w[0] + w[1], w[0] + w[2])
dp[n] = max(w[n-2] + w[n-1], w[n-2] + w[n])
w[0] w[1] w[2] ---- w[4] ... = dp[3] = dp[2]
w[0] w[1] ---- w[3] ---- ... = dp[3] = dp[1] + wines[3]
w[0] w[1]      w[3] w[4] ... = dp[3] = dp[1] + wines[3] (중복)
w[0]      w[2] w[3] ---- ... = dp[3] = dp[0] + wines[2] + wines[3]
  -   1    2    3    4

dp[3] = Max (dp[2], dp[1] + w[3], dp[0]+w[2]+w[3])
"""
```
<br/>

## 문제풀이 아이디어 (top down)
```java
static int recur (int N){
  if(dp[N] == null){
    dp[N] = Math.max(
      Math.max(recur(N-2), recur(N-3) + arr[N-1]) + arr[N],
      recur(N-1)
    );
  }
  
  return dp[N];
}
```
<br/>

## 문제풀이 아이디어 (bottom up)
```java
for(int i=3; i<= N; i++){
  dp[i] = Math.max(
    Math.max(dp[i-2], dp[i-3] + arr[i-1]) + arr[i],
    dp[i-1]
  );
}
```
<br/>

## python (2025)
### python top down (dfs) (조금 더 단순한 풀이)
```python
from math import inf
import sys
sys.setrecursionlimit(10**6)  # 재귀 깊이 증가

n = int(sys.stdin.readline().strip())

if n == 0:
    print(0)
    sys.exit()

wines = [0] + [int(sys.stdin.readline().strip()) for _ in range(n)]
dp = [-inf] * (n+1)
dp[1] = wines[1]
# print(f"wines = {wines}, n = {n}, len(wines) = {len(wines)}")

if n > 1:
    dp[2] = wines[1] + wines[2]

### sol2
def dfs(n):
    if n == 0: return 0
    if n == 1: return wines[1]
    if n == 2: return wines[1] + wines[2]
    if dp[n] != -inf: return dp[n]

    dp[n] = max(
        dfs(n-1), 
        dfs(n-2) + wines[n],
        dfs(n-3) + wines[n-1] + wines[n] if n>= 3 else 0,
    )

    return dp[n]

def sol_dp(n):
    result = dfs(n)
    print(f"{result}")

sol_dp(n)
```
<br/>

### python bottom up (dp) (조금 더 단순한 풀이)
```python
import sys

N = int(sys.stdin.readline().strip())
if N == 0:
    print(f"{0}")
wines = [0] + [int(sys.stdin.readline().strip()) for _ in range(N)]
dp = [0] * (len(wines))

"""
[v,v,x,,...]
[v,x,v,,...]
[x,v,v,,...]
"""
# dp[3] = max(dp[1] + wines[3], dp[2], dp[1] + wines[2] + wines[3])

if N == 1:
    print(wines[1])
elif N == 2:
    print(wines[1]+wines[2])
elif N >= 3:
    dp[1] = wines[1]
    dp[2] = dp[1] + wines[2]
    for i in range(3, len(wines)):
        dp[i] = max(
                dp[i-1], ## 1,2 번 와인을 마시는 경우
                dp[i-2] + wines[i], ## 3 번 와인만 마실때
                dp[i-3] + wines[i-1] + wines[i] ## 2,3 번 와인을 마시는 경우
            )
    print(f"{dp[N]}")
```

### python bottom up
```python
from math import inf
import sys
sys.setrecursionlimit(10**6)  # 재귀 깊이 증가

n = int(sys.stdin.readline().strip())

if n == 0:
    print(0)
    sys.exit()

wines = [0] + [int(sys.stdin.readline().strip()) for _ in range(n)]

dp = [-inf] * (n+1) ## dp = [0] * (n+1) 로 해도 됨
dp[0] = 0
dp[1] = wines[1]
if n > 1:
    dp[2] = wines[1] + wines[2]

### sol 1 
def bottom_up(n):
    for i in range(3, n+1):
        dp[i] = max(dp[i-1], 
                    dp[i-2] + wines[i], 
                    dp[i-3] + wines[i-1] + wines[i])
    print(dp[n])

bottom_up(n)
```
<br/>

### python top down (with dfs)
```python
from math import inf
import sys
sys.setrecursionlimit(10**6)  # 재귀 깊이 증가

n = int(sys.stdin.readline().strip())

if n == 0:
    print(0)
    sys.exit()

wines = [0] + [int(sys.stdin.readline().strip()) for _ in range(n)]

dp = [-inf] * (n+1)
dp[0] = 0
dp[1] = wines[1]
if n > 1:
    dp[2] = wines[1] + wines[2]

### sol2
def dfs(n):
    # if n == 0: return 0
    # if n == 1: return wines[1]
    # if n == 2: return wines[1] + wines[2]
    if dp[n] != -inf: return dp[n]

    dp[n] = max(
        dfs(n-1), 
        dfs(n-2) + wines[n],
        dfs(n-3) + wines[n-1] + wines[n] if n>= 3 else 0,
    )

    return dp[n]

def sol_dp(n):
    result = dfs(n)
    print(f"{result}")

sol_dp(n)
```
<br/>

## java 풀이(2023)
### java) Top Down
```java
import java.util.*;
import java.io.*;

public class Main{
    final static Reader reader = new Reader();
    
    static int LEN;
    static Integer [] dp;
    static int [] a;
    
    public static void main(String [] args){
        input();
        sol();
    }
    
    public static void input(){
        LEN = reader.nextInt();
        dp = new Integer [LEN+1];
        a = new int [LEN+1];
        
        for(int i=1; i<=LEN; i++){
            a[i] = reader.nextInt();
        }
        
        dp[0] = 0;
        dp[1] = a[1];
    }
    
    public static void sol(){
        if(LEN > 1){
            dp[2] = a[1] + a[2]; // a[1] ~ a[2] 사이의 최대값
        }
        
        println(dfs(LEN));
    }
    
    public static int dfs(int index){
        // dp[index] 가 비어있을 때에만 재귀를 수행
        if(dp[index] == null){
            dp[index] = 
                Math.max(
                    dfs(index-1),
                    Math.max(
                        dfs(index-3) + a[index-1],
                        dfs(index-2)
                    ) + a[index]
                );
        }
        
        // dp[index] 가 비어있지 않으면 존재하는 값을 리턴
        return dp[index];
    }
    
    public static void println(Object o){
        System.out.println(String.valueOf(o));
    }
    
    private static class Reader{
        BufferedReader reader;
        StringTokenizer st;
        
        public Reader() {
            reader = new BufferedReader(new InputStreamReader(System.in));
        }

        public Reader(String s) throws FileNotFoundException {
            reader = new BufferedReader(new FileReader(new File(s)));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = "";
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}
```
<br/>

### java) Bottom Up
```java
import java.util.*;
import java.io.*;

public class Main{
    final static Reader reader = new Reader();
    
    static int LEN;
    static Integer [] dp;
    static int [] a;
    
    public static void main(String [] args){
        input();
        sol();
    }
    
    public static void input(){
        LEN = reader.nextInt();
        dp = new Integer [LEN+1];
        a = new int [LEN+1];
        
        for(int i=1; i<=LEN; i++){
            a[i] = reader.nextInt();
        }
        
        dp[0] = 0;
        dp[1] = a[1];
    }
    
    public static void sol(){
        if(LEN > 1){
            dp[2] = a[1] + a[2]; // a[1] ~ a[2] 사이의 최대값
        }
        
        // println(dfs(LEN));
        println(dynamicWay(LEN));
    }
    
    public static int dynamicWay(int len){
        
        for(int i=3; i<=len; i++){
            dp[i] = Math.max(
                dp[i-1],
                Math.max(
                    dp[i-3] + a[i-1],
                    dp[i-2]
                ) + a[i]
            );
        }
        
        return dp[len];
    }
  
    public static void println(Object o){
        System.out.println(String.valueOf(o));
    }
    
    private static class Reader{
        BufferedReader reader;
        StringTokenizer st;
        
        public Reader() {
            reader = new BufferedReader(new InputStreamReader(System.in));
        }

        public Reader(String s) throws FileNotFoundException {
            reader = new BufferedReader(new FileReader(new File(s)));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = "";
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}
```
<br/>