방은 배정하겠다는데 방 하나에는 사람을 꽉 채우겠다는 의미

핵심아이디어
- i 번째 데이터가 A의 배수
- i 번째 데이터가 B의 배수
- i 번째 데이터가 C의 배수

N 번째가 A,B,C 중 하나의 배수이면 Ok
이 값을 표현하기 위해 DP 기반 풀이에서는 `dp[i+A]`, `dp[i+B]`, `dp[i+C]` 를 사용해서 배수에 해당하는 값들을 마스킹해나갔다.

# (3) BOJ 14697 방배정하기
## 문제, 참고자료
- [백준14697 방배정하기](https://www.acmicpc.net/problem/14697)
- [가장 도움이 되었던 자료 - python 풀이](https://jinho-study.tistory.com/992)
- [Java 문제 풀이 (Brute force 방식)](https://dundung.tistory.com/35)
- [Java 문제풀이 (재귀 방식)](https://lotuslee.tistory.com/19) 
- [Java 문제풀이 (동적프로그래밍 방식)](https://velog.io/@yanghl98/%EB%B0%B1%EC%A4%80-2156-%ED%8F%AC%EB%8F%84%EC%A3%BC-%EC%8B%9C%EC%8B%9D)
- [python 문제풀이](https://jinho-study.tistory.com/991)
<br/>

## python 완전탐색(bruteforce) 1 (통과하긴 함)
- 통과하긴 한다. 방이 몇개 까지 필요할지 최악의 케이스를 구한 후에 진행하기 때문이다.
- 100 점이 나오기는 한다. 하지만 아직은 찜찜
- 이런 방식도 자주 연습해봐야 programmers 의 빡구현때도 당황을 안한다.
```python
A, B, C, N = map(int, input().split())

found = False

## sol1 (시간 초과)
def sol1_bruteforce():
    for i in range(0, N // A + 1): ## 1 ~ A size 방으로 채울수 있는 방의 개수
        for j in range(0, N // B + 1): ## 1 ~ B size 방으로 채울수 있는 방의 개수
            for k in range(0, N // C + 1): ## 1 ~ C size 방으로 채울수 있는 방의 개수
                if i*A + j*B + k*C == N:
                    print(f"{1}")
                    sys.exit()

    print("0")

sol1_bruteforce()
```
<br/>

## python 완전탐색(brutefoce) 2 (무식한 버전)
- 이 경우 채점 시에 3점밖에 못받는다.
```python
A, B, C, N = map(int, input().split())

found = False

def sol2_bruteforce():
    for i in range(A + 1): ## 1 ~ A
        for j in range(B + 1): ## 1 ~ B
            for k in range(C + 1): ## 1 ~ C
                if i*A + j*B + k*C == N:
                    print(f"{1}")
                    sys.exit()

    print("0")

sol2_bruteforce()
```
<br/>

## python) 동적계획법
```python
import sys
from math import inf
A, B, C, N = map(int, sys.stdin.readline().strip().split())


## sol3 db (bottom up)
def sol3_bottomup_dp():
    dp = [0] * (N+1) ## DP 배열 초기화 (최대 사이즈 : N+1)
    dp[0] = 1 ## 0 명 채울수 있음

    ## DP 진행 (A,B,C 를 추가를 하면서 앞으로 나감)
    for i in range(N+1):
        if dp[i] == 1: ## i 명을 채울 수 있다면 
            if i + A <= N:
                dp[i + A] = 1
            if i + B <= N:
                dp[i + B] = 1
            if i + C <= N:
                dp[i + C] = 1

    print(dp[N])

## 정답 출력 (N명을 채우는 것이 가능한지)
sol3_bottomup_dp()
```
<br/>

### java) 동적프로그래밍 방식 사용 (동적계획법)
```java
import java.util.*;
import java.io.*;

public class Main{
    final static Reader reader = new Reader();
    
    static int room_a;
    static int room_b;
    static int room_c;
    static int total;
    
    public static void main(String [] args){
        input();
        sol();
    }
    
    public static void input(){
        room_a = reader.nextInt();
        room_b = reader.nextInt();
        room_c = reader.nextInt();
        total = reader.nextInt();
    }
    
    public static void sol(){
        // bruteForce(); // 시간초과
        dynamicWay();
    }
    
    public static void bruteForce(){
        for(int i=0; i<=total; i=i+i*room_a){
            for(int j=0; j<=total-i; j=j+j*room_b){
                for(int k=0; k<=total-i-j; k=k+k*room_c){
                    if(i + j + k == total){
                        println("1");
                        return;
                    }
                }
            }
        }
        println("0");
    }
    
    public static void dynamicWay(){
        int [] room_size_arr = new int []{room_a, room_b, room_c};
        int [] d = new int[total+1];
        d[0] = 1;
        
        for(int i=1; i<=total; i++){
            for(int room_size : room_size_arr){
                if(i-room_size>=0 && d[i-room_size] == 1){
                    d[i] = 1;
                }
            }
        }
        if(d[total] == 1) println("1");
        else println("0");
    }
    
    public static void println(Object o){
        System.out.println(String.valueOf(o));
    }
    
    private static class Reader{
        BufferedReader reader;
        StringTokenizer st;
        
        public Reader() {
            reader = new BufferedReader(new InputStreamReader(System.in));
        }

        public Reader(String s) throws FileNotFoundException {
            reader = new BufferedReader(new FileReader(new File(s)));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = "";
            try {
                str = reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}
```

<br/>