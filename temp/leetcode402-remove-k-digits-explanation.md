# LeetCode 402: Remove K Digits

## 1. 문제 개요
문자열로 주어진 음이 아닌 정수 `num`에서 `k`개의 숫자를 제거하여 만들 수 있는 **가장 작은 수**를 문자열로 반환하는 문제입니다.

## 2. 핵심 아이디어: 그리디(Greedy) + 모노토닉 스택(Monotonic Stack)

가장 작은 수를 만들기 위해서는 **왼쪽 자릿수(높은 자릿수)**에 최대한 작은 숫자가 오도록 해야 합니다.
즉, **"앞에 있는 큰 숫자"를 우선적으로 제거**해야 뒤에 있는 작은 숫자가 앞으로 당겨져서 전체 수가 작아집니다.

### 알고리즘 로직
1.  숫자를 하나씩 순회하며 스택에 넣습니다.
2.  **중요**: 만약 **현재 숫자(`c`)가 스택의 마지만 숫자(`stack[-1]`)보다 작다면**, 스택에 있는 숫자를 제거합니다.
    *   왜냐하면 스택에 있는(더 앞에 위치한) 큰 숫자를 버리고, 현재의 작은 숫자를 그 자리에 놓는 것이 더 이득이기 때문입니다 (Greedy).
    *   이 과정을 `k`번 횟수가 남아있고, 스택에 값이 있고, 조건이 만족하는 동안 반복합니다.
3.  순회가 끝난 뒤에도 `k`가 남아있다면, 뒤에 있는 숫자들(이미 오름차순으로 정렬된 상태일 것임)을 버립니다.
4.  결과 문자열에서 앞부분의 불필요한 '0'을 제거합니다(Leading Zeros).

## 3. 코드 분석

```python
def solution(num, k):
    prev_stack = []
    for c in num:
        # 그리디 로직: 스택의 top이 현재 숫자보다 크면 제거 (앞쪽의 큰 수 제거)
        while k and prev_stack and prev_stack[-1] > c:
            prev_stack.pop()
            k -= 1
        prev_stack.append(c) # 현재 숫자 추가

    # 만약 k가 아직 남아있다면, 뒤에서부터 제거
    # (이미 숫자는 오름차순 형태일 것이므로 뒤쪽이 큰 수임)
    if k > 0:
        prev_stack = prev_stack[:-k]

    # 문자열로 변환 및 앞쪽 '0' 제거
    s = "".join(prev_stack).lstrip("0")
    
    # 빈 문자열이면 "0" 반환
    return s if s else "0"
```

## 4. 예시 동작

`num = "1432219", k = 3`

1.  `'1'` -> 스택: `['1']`
2.  `'4'` -> 스택: `['1', '4']` (4 > 1 이므로 유지)
3.  `'3'` -> 스택: `['1', '3']` (4 > 3 이므로 4 제거, k=2)
4.  `'2'` -> 스택: `['1', '2']` (3 > 2 이므로 3 제거, k=1)
5.  `'2'` -> 스택: `['1', '2', '2']` (2 == 2 이므로 유지)
6.  `'1'` -> 스택: `['1', '2', '1']` -> `['1', '1']` (2 > 1 이므로 뒤쪽 2 제거, k=0) -> `['1', '2', '1']` (앞쪽 2는 못 뺌, 아 스택은 `['1', '2', '2']`였음. 두번째 `2`가 들어오면서... 
    *   정정:
    *   `'1'`, `'4'`, `'3'`(pop 4, k=2) -> `['1', '3']`
    *   `'2'`(pop 3, k=1) -> `['1', '2']`
    *   `'2'` -> `['1', '2', '2']`
    *   `'1'`(pop `2`, k=0) -> `['1', '2', '1']`. 더 이상 k가 없으므로 루프 종료.
    *   마지막 `'9'` -> `['1', '2', '1', '9']`
    *   결과: `1219`

## 5. 복잡도
*   **시간 복잡도**: O(N) - 각 숫자는 스택에 최대 한 번 들어가고 한 번 나옵니다.
*   **공간 복잡도**: O(N) - 스택에 결과를 저장합니다.
