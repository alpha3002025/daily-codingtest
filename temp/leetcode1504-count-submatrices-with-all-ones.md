# LeetCode 1504: Count Submatrices With All Ones

## 1. 문제 개요
0과 1로 이루어진 `m x n` 행렬 `mat`이 주어졌을 때, **모든 원소가 1인 부분 직사각형(Submatrix)의 개수**를 구하는 문제입니다.

## 2. 핵심 아이디어: 2D -> 1D 히스토그램 변환
이 문제는 단순히 모든 가능한 시작점과 끝점을 찾으면 O(N^3) 이상의 시간이 걸려 비효율적입니다.
이를 효율적으로 풀기 위해 **매 행(Row)을 "바닥"으로 간주하고, 위쪽으로 쌓인 1의 높이(Height)**를 계산하여 1차원 히스토그램 문제로 변환합니다.

### 과정
1.  각 행(`row`)을 순회하며, 각 열(`col`)위로 연속된 1이 몇 개 쌓여있는지(`heights`)를 갱신합니다.
    *   `mat[row][col] == 0`이면 높이는 0이 됩니다.
    *   `mat[row][col] == 1`이면 이전 행의 높이 + 1이 됩니다.
2.  이제 문제는 **"각 칸을 오른쪽 아래 꼭짓점으로 하는 직사각형의 개수를 세는 것"**으로 바뀝니다.

## 3. 모노토닉 스택 (Monotonic Stack) 활용

각 행마다 만들어진 히스토그램(`heights`)에서, 특정 위치 `i`에서 끝나는 직사각형의 개수를 효율적으로 구하기 위해 **오름차순 스택(Monotonic Stack)**을 사용합니다.

### 공식 유도
현재 위치 `i`에서의 높이가 `h`라고 합시다.
`i`번째 칸을 오른쪽 끝으로 하면서 만들 수 있는 직사각형의 개수는 다음과 같이 계산됩니다:
*   현재 높이 `h`보다 낮은 높이를 가진 가장 가까운 왼쪽 인덱스 `j`를 찾습니다.
*   `j`부터 `i`까지의 구간은 높이 `h`로 평탄화된 직사각형들을 형성합니다.
    *   이 구간의 너비: `i - j`
    *   높이 `h`인 직사각형 내부에서 만들 수 있는 직사각형 수: `(i - j) * h`
*   `j` 위치까지 만들 수 있었던 직사각형의 개수(`prev`)를 더합니다.

즉, 점화식은 다음과 같습니다:
`curr = (i - j) * h + prev`

*   `j`: 스택에서 `h`보다 작은 높이를 가진 바로 왼쪽 인덱스
*   `prev`: `j` 위치까지의 누적 직사각형 개수
*   `curr`: `i` 위치에서의 누적 직사각형 개수

### 스택 구조
스택에는 `[인덱스, 누적 개수, 높이]` 형태의 데이터를 저장하여, O(1)에 이전 상태를 참조합니다.
*   `stack = [[-1, 0, -1]]`: 초기값 (인덱스 -1, 개수 0, 높이 -1)

## 4. 코드 분석

```python
class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        heights = [0] * len(mat[0])
        res = 0

        for row in mat:
            # 1. 히스토그램 높이 갱신
            for i, x in enumerate(row):
                heights[i] = 0 if x == 0 else heights[i] + 1
            
            # 2. 모노토닉 스택 초기화 (인덱스, 누적값, 높이)
            # 높이 -1인 가상의 벽을 두어 모든 원소를 처리할 수 있게 함
            stack = [[-1, 0, -1]]

            for i, h in enumerate(heights):
                # 3. 현재 높이보다 크거나 같은 이전 높이들은 제거 (오름차순 유지)
                # 현재 높이 h가 더 작다면, 스택에 있는 높은 기둥들은 h 높이까지만 유효함
                while stack[-1][2] >= h:
                    stack.pop()
                
                # 4. 계산
                # j: 나보다 높이가 낮은 바로 왼쪽 인덱스
                # prev: j까지의 누적 결과
                j, prev, _ = stack[-1]
                
                # (i - j) * h: j+1 ~ i 구간에서 높이 h로 만들 수 있는 직사각형 수
                # prev: j 위치까지 이미 만들어진 직사각형 수 (그 형태 그대로 연장됨)
                curr = prev + (i - j) * h
                
                stack.append([i, curr, h])
                res += curr
        
        return res
```

## 5. 예시 동작

`heights = [1, 2, 1]` 일 때:

1.  **i=0, h=1**:
    *   스택: `[-1, 0, -1]` (top 높이 -1 < 1) -> pop 안 함
    *   `j=-1`, `prev=0`
    *   `curr = 0 + (0 - (-1)) * 1 = 1`
    *   `res += 1` (총 1)
    *   스택 추가: `[[-1, 0, -1], [0, 1, 1]]`

2.  **i=1, h=2**:
    *   스택 top 높이 1 < 2 -> pop 안 함
    *   `j=0`, `prev=1`
    *   `curr = 1 + (1 - 0) * 2 = 3`
    *   `res += 3` (총 4)
    *   스택 추가: `[..., [0, 1, 1], [1, 3, 2]]`

3.  **i=2, h=1**:
    *   스택 top 높이 2 >= 1 -> **Pop!** (`[1, 3, 2]` 제거)
    *   스택 top 높이 1 >= 1 -> **Pop!** (`[0, 1, 1]` 제거)
    *   남은 스택 top: `[-1, 0, -1]`
    *   `j=-1`, `prev=0`
    *   `curr = 0 + (2 - (-1)) * 1 = 3`
    *   `res += 3` (총 7)
    *   스택 추가: `[[-1, 0, -1], [2, 3, 1]]`

## 6. 결론
*   **시간 복잡도**: O(M * N) - 각 칸을 최대 2번(push/pop) 방문합니다.
*   **공간 복잡도**: O(N) - `heights` 배열과 `stack`의 크기.
