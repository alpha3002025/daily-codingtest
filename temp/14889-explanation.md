# 백준 14889 "스타트와 링크" - 팀 능력치 계산 함수 설명

## 문제 개요
N명의 사람을 N/2명씩 두 팀(스타트 팀, 링크 팀)으로 나누어, 두 팀의 능력치 차이를 최소화하는 문제입니다.

## 선택한 함수 설명

```python
def calculate_team_ability(team):
    """팀의 능력치 합 계산"""
    ability = 0
    for i in range(len(team)):
        for j in range(i + 1, len(team)):
            ability += S[team[i]][team[j]] + S[team[j]][team[i]]
    return ability
```

### 함수의 역할
팀에 속한 선수들의 **능력치 합**을 계산하는 함수입니다.

### 핵심 로직
1. **이중 반복문**으로 팀 내에서 가능한 **모든 선수 쌍의 조합**을 순회
2. `i < j` 관계를 만족하는 모든 쌍 `(i, j)`에 대해
3. 각 쌍의 **양방향 능력치**를 합산: `S[team[i]][team[j]] + S[team[j]][team[i]]`

## 구체적인 예시

### 입력 데이터
```
N = 4
```
```python
S = [
    [0, 1, 2, 3],
    [4, 0, 5, 6],
    [7, 1, 0, 2],
    [3, 4, 5, 0]
]
```

### 예시 1: 2명으로 구성된 팀
**팀 구성:** `team = [0, 2]` (0번과 2번 선수)

#### 계산 과정

| i | j | `team[i]` | `team[j]` | `S[team[i]][team[j]]` | `S[team[j]][team[i]]` | 합계 |
|---|---|---------|---------|---------------------|---------------------|------|
| 0 | 1 | 0 | 2 | `S[0][2]` = 2 | `S[2][0]` = 7 | 9 |

**최종 ability = 9**

### 예시 2: 3명으로 구성된 팀
**팀 구성:** `team = [0, 1, 2]` (0, 1, 2번 선수)

#### 계산 과정

| i | j | `team[i]` | `team[j]` | `S[team[i]][team[j]]` | `S[team[j]][team[i]]` | 합계 |
|---|---|---------|---------|---------------------|---------------------|------|
| 0 | 1 | 0 | 1 | `S[0][1]` = 1 | `S[1][0]` = 4 | 5 |
| 0 | 2 | 0 | 2 | `S[0][2]` = 2 | `S[2][0]` = 7 | 9 |
| 1 | 2 | 1 | 2 | `S[1][2]` = 5 | `S[2][1]` = 1 | 6 |

**최종 ability = 5 + 9 + 6 = 20**

## 왜 이렇게 계산하는가?

백준 14889 문제에서 `S[i][j]`의 의미:
- **`S[i][j]`**: i번 선수와 j번 선수가 같은 팀일 때, i번 선수가 더하는 능력치

따라서 두 선수가 팀이면:
- **`S[i][j]`**: i → j로의 기여도
- **`S[j][i]`**: j → i로의 기여도
- 두 값을 **모두 더해야** 팀의 총 능력치가 됨

### 조합을 이용한 효율적 계산
`i < j` 조건 (`for j in range(i + 1, len(team))`)의 의미:
- 팀 내 모든 선수 쌍의 **조합(Combination)**을 순회
- 예: 3명 팀 `[0, 1, 2]`에서 가능한 쌍은 `(0,1)`, `(0,2)`, `(1,2)` 총 3개
- 각 쌍마다 **양방향 능력치를 모두 합산**: `S[i][j] + S[j][i]`
- 중복 없이 모든 쌍을 정확히 한 번씩만 계산

## 시간 복잡도
- 팀 크기가 k일 때: **O(k²)**
- N명 중 N/2명을 선택하므로, k = N/2
- 한 팀의 능력치 계산: **O((N/2)²) = O(N²)**
