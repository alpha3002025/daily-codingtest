# [1차] 다트 게임

## 문제 설명
카카오톡 게임별의 다트 게임 로직을 구현하는 문제입니다.
총 3번의 기회에서 얻은 점수(0~10), 보너스(S, D, T), 옵션(*, #)으로 구성된 문자열을 입력받아 최종 점수를 계산해야 합니다.

- **점수**: 0 ~ 10
- **보너스**: Single(S, 1제곱), Double(D, 2제곱), Triple(T, 3제곱)
- **옵션**: 
  - 스타상(*): 해당 점수와 바로 전에 얻은 점수를 각 2배로 만듦.
  - 아차상(#): 해당 점수는 마이너스됨.

## 접근법 & 주요 개념

### 1. 정규표현식 (Regular Expression)
문자열이 `점수|보너스|옵션`의 반복된 형태이므로, 이를 파싱하기 위해 정규표현식을 사용하는 것이 가장 효율적입니다.
- 패턴: `(\d+)([SDT])([*#]?)`
  - `(\d+)`: 숫자 1개 이상 매칭 (10이 두 자리 수이므로 `\d`가 아닌 `\d+` 사용)
  - `([SDT])`: S, D, T 중 하나의 문자와 매칭
  - `([*#]?)`: *, # 문자가 0개 또는 1개 매칭 (옵션은 없을 수도 있음)

### 2. 리스트(스택) 활용
옵션 중 **스타상(*)**은 "바로 전에 얻은 점수"에도 영향을 줍니다. 이를 처리하기 위해 계산된 각 기회의 점수를 리스트에 순서대로 저장해두고, 필요 시 인덱스를 통해 이전 값에 접근하여 수정합니다.

## Python 풀이

```python
import re

def solution(dartResult):
    # 1. 정규표현식 컴파일
    # 그룹 1: 점수 (0~10)
    # 그룹 2: 보너스 (S, D, T)
    # 그룹 3: 옵션 (*, #, 또는 빈 문자열)
    pattern = re.compile(r'(\d+)([SDT])([*#]?)')
    
    # findall은 매칭되는 모든 패턴을 튜플의 리스트로 반환합니다.
    # 예: [('1', 'S', ''), ('2', 'D', '*'), ('3', 'T', '')]
    matches = pattern.findall(dartResult)
    
    scores = []
    
    for idx, (score_str, bonus, option) in enumerate(matches):
        score = int(score_str)
        
        # 보너스 계산
        if bonus == 'S':
            score = score ** 1
        elif bonus == 'D':
            score = score ** 2
        elif bonus == 'T':
            score = score ** 3
            
        # 옵션 계산
        if option == '*':
            score *= 2 # 현재 점수 2배
            if idx > 0: # 첫 번째 기회가 아니라면
                scores[idx-1] *= 2 # 이전 점수도 2배
        elif option == '#':
            score *= -1 # 현재 점수 마이너스
            
        scores.append(score)
        
    return sum(scores)
```

### 코드 분석
1. `re.findall`을 사용하여 복잡한 문자열 파싱 로직을 한 줄로 처리했습니다.
2. `scores` 리스트에 단계별 점수를 저장함으로써, `*` 옵션이 나왔을 때 `scores[idx-1]`로 직전 점수에 쉽게 접근할 수 있습니다.
3. 최종적으로 `sum(scores)`를 반환하여 총점을 구합니다.


## 코드 설명


### 정규표현식 패턴

```python
    pattern = re.compile(r'(\d+)([SDT])([*#]?)')
```

다트 게임의 점수 계산 로직을 구현하기 위해 입력 문자열을 파싱하는 핵심 부분입니다. 정규표현식을 사용하여 `점수`, `보너스`, `옵션` 세 가지 요소를 그룹으로 나누어 추출합니다.

1.  **`(\d+)` - 점수**:
    -   `\d`는 숫자(digit)를 의미합니다.
    -   `+`는 1회 이상 반복됨을 의미합니다. 점수는 0부터 10까지 가능하므로, 10의 경우 두 자리 숫자가 되기 때문에 `\d+`를 사용해야 합니다.
2.  **`([SDT])` - 보너스**:
    -   `[]`는 대괄호 안의 문자 중 하나와 매칭됨을 의미합니다.
    -   S(ingle), D(ouble), T(riple) 중 하나가 반드시 존재해야 합니다.
3.  **`([*#]?)` - 옵션**:
    -   `*` 또는 `#` 문자와 매칭됩니다.
    -   `?`는 해당 문자가 0회 또는 1회 등장함(있을 수도 있고 없을 수도 있음)을 의미합니다. 옵션이 없는 경우 빈 문자열로 매칭됩니다.


### 정규표현식 괄호의 의미

1.  **소괄호 `()`: 그룹화 (Grouping)**
    -   패턴의 일부분을 하나로 묶어 **그룹(Group)**으로 만듭니다.
    -   `findall` 함수를 사용할 때, 소괄호로 묶인 부분만 **추출**하여 튜플(tuple) 형태로 반환해줍니다.
    -   이 코드에서는 점수, 보너스, 옵션을 각각 별도로 추출해서 사용해야 하므로 `(\d+)`, `([SDT])`, `([*#]?)`와 같이 3개의 그룹을 만들었습니다.
    -   결과 예시: `[('1', 'S', ''), ('2', 'D', '*')]`

2.  **대괄호 `[]`: 문자 집합 (Character Set)**
    -   대괄호 안에 있는 **문자들 중 딱 하나**와 매칭됩니다.
    -   `[SDT]`는 "S 또는 D 또는 T 중 한 글자"라는 뜻입니다. (== `S|D|T`)
    -   `[*#]`는 "* 또는 # 중 한 글자"라는 뜻입니다.
    -   순서는 상관없으며, 안에 나열된 후보들 중 하나라도 일치하면 매칭 성공입니다.





