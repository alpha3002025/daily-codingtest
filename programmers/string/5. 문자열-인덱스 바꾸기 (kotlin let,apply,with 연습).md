
# Link
https://school.programmers.co.kr/learn/courses/30/lessons/120895


# 참고 (문자열 합칠때 개행문자 관련 이슈)
문자열은 다음과 같이 합쳐야 한다.
1. 개행문자 없이 더한다.
2. 개행을 하더라도 괄호로 묶어서 더한다.

1\. 개행문자 없이 더한다.
```python
answer = my_string[:left] + my_string[right] + my_string[left+1:right] + my_string[left] + my_string[right+1:]
```
<br/>

2\. 괄호로 묶어서 더한다.
```python
answer = (
    my_string[:left]
    + my_string[right]
    + my_string[left+1:right]
    + my_string[left]
    + my_string[right+1:]
)
```
<br/>

만약 다음과 같이 괄호`()` 로 묶지 않고 개행문자를 사용해 정의할 경우에는 unary plus 로 간주해서 에러를 낸다.
```python
answer = 
    my_string[:left]
    + my_string[right]
    + my_string[left+1:right]
    + my_string[left]
    + my_string[right+1:]
```
<br/>

unary plus (단항 +)는 숫자타입(정수, 실수)에만 쓸수 있는 연산자이며, 사실상 '부호를 유지한 채'값을 반환한다.
예를 들면 `+x`는 x 를 그대로 내보내는 효과를 낸다.
`(-x)` 처럼 부호를 붙이거나 바꿀 때 `(-(-3) = 3)` 사용되는 맥락에 비해 쓰임새가 적다.

```python
a = 5
b = -3

print(+a) #5 (단항 + : 그대로 5 를 반환)
print(+b) #-3 (단항 + : 그대로 -3을 반환)

# 실수에 대한 예
x = 2.7
y = -4.1

print(+x)   # 2.7
print(+y)   # -4.1

# 단항 - (마이너스)와 비교
print(-a)   # -5   (부호 반전)
print(-b)   # 3    (부호 반전)

# 체이닝도 가능
val = +(-(+(-10)))
# 해석: -10 → +(-10) = -10 → -(-10)=10 → +(10)=10 → -(10)=-10 → +(-10) = -10 
print(val)  # -10
```
- 위 예에서 +a나 +b는 숫자를 바꾸지 않고 그대로 반환합니다.
- 반면 -a, -b처럼 단항 마이너스는 부호를 반전시킵니다.
<br/>

왜 문자열에 쓰면 에러가 나는가?
```python
s = "hello"
print(+s)   # TypeError: bad operand type for unary +: 'str'
```
- 단항 플러스(+)는 숫자 타입에만 정의된 연산자입니다.
- 문자열(str)이나 리스트 등의 다른 타입에는 정의되어 있지 않기 때문에 “문자열에 단항 +를 적용할 수 없다”라는 에러가 발생합니다.

<br/>

# python (1)
```python
def solution(my_string, num1, num2):
    left,right = sorted((num1, num2))
    
    answer = (my_string[:left]
        + my_string[right]
        + my_string[left+1:right]
        + my_string[left]
        + my_string[right+1:])
    
    return answer
```
<br/>

# python (2) : list 를 활용한 풀이
시간 복잡도가 조금 더 늘지만, list 를 활용한 풀이는 깔끔해보이긴 하다.
```python
def solution(my_string, num1, num2):
    s = list(my_string)
    s[num1],s[num2] = s[num2],s[num1]
    return ''.join(s)
```


# kotlin
## (1) apply 를 사용할 경우 (this를 사용)
```kotlin
class Solution {
    fun solution(my_string: String, num1: Int, num2: Int): String {
        return StringBuilder(my_string)
            .apply{
                val temp = this.get(num1)
                this.set(num1, this.get(num2))
                this.set(num2, temp)
            }
            .toString()
    }
}
```

## (2) let 을 사용 (it)를 사용
```kotlin
class Solution {
    fun solution(my_string: String, num1: Int, num2: Int): String {
        return StringBuilder(my_string)
            .let{
                val temp = it.get(num1)
                it.set(num1, it.get(num2))
                it.set(num2, temp)
                it
            }
            .toString()
    }
}
```
<br/>

## (3) with 를 사용
```kotlin
class Solution {
    fun solution(my_string: String, num1: Int, num2: Int): String {
        return with(StringBuilder(my_string)){
            val temp = this.get(num1)
            this.set(num1, this.get(num2))
            this.set(num2, temp)
            toString()
        }
    }
}
```
<br/>


## 총정리
```kotlin
class Solution {
    fun solution(my_string: String, num1: Int, num2: Int): String {
        //// run
        // return StringBuilder(my_string).apply{
        //     val temp = this.get(num1)
        //     this.set(num1, this.get(num2))
        //     this.set(num2, temp)
        // }.toString()
        
        //// let
        // return StringBuilder(my_string).let{
        //     val temp = it.get(num1)
        //     it.set(num1, it.get(num2))
        //     it.set(num2, temp)
        //     it.toString()
        // }
        
        //// with
        return with(StringBuilder(my_string)){
            val temp = this.get(num1)
            this.set(num1, this.get(num2))
            this.set(num2, temp)
            this.toString()
        }
    }
}
```