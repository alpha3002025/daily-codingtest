# 고고학 최고의 발견

## 1. 문제 설명
- **문제 링크**: [https://school.programmers.co.kr/learn/courses/30/lessons/131702](https://school.programmers.co.kr/learn/courses/30/lessons/131702)
- **정보**:
  - $N \times N$ 크기의 격자에 시곗바늘(0~3)이 있습니다.
  - 하나의 시계 바늘을 돌리면, 그 칸과 상하좌우 인접한 칸들(총 최대 5개)의 시계 바늘이 90도 시계방향으로 회전합니다.
    - 값 변화: `(value + 1) % 4`
  - 모든 시계 바늘을 12시 방향(값 0)으로 만드는 **최소 조작 횟수**를 구해야 합니다.
- **제한사항**:
  - $2 \le N \le 8$
  - 시간 복잡도는 넉넉한 편은 아니지만 $N$이 매우 작습니다.

---

## 2. 접근법 및 핵심 개념 (Greedy + Brute Force)

이 문제는 전형적인 **"Lights Out"** 변형 퍼즐 문제입니다. 모든 칸을 조작 대상으로 고려하면 경우의 수가 너무 많아지지만, **위에서부터 아래로 순차적으로 결정**한다는 아이디어를 사용하면 탐색 공간을 획기적으로 줄일 수 있습니다.

### 핵심 아이디어
1. **첫 번째 행(Row 0)**의 조작이 정해지면, 나머지 행들의 조작 여부는 **자동으로 결정**됩니다.
   - 첫 번째 행의 $(0, c)$ 칸의 값이 0이 아니라면, 이를 0으로 만들 수 있는 방법은 그 아래칸인 $(1, c)$를 회전시켜 영향을 주는 방법뿐입니다.
     - (물론 $(0, c)$ 자체를 돌리거나 좌우를 돌려도 되지만, 우리가 "위에서 아래로 스캔한다"고 가정하면, $(0, c)$의 상태를 확정짓는 마지막 기회는 바로 아래칸인 $(1, c)$의 조작입니다.)
   - 따라서, 0번째 행의 조작을 임의로 결정하고 나면, 1번째 행의 각 칸은 **바로 위칸(0번째 행)을 0으로 만들기 위해** 필연적으로 특정 횟수만큼 회전해야 합니다.
   - 마찬가지로 2번째 행은 1번째 행을 0으로 만들기 위해 결정됩니다.
   - 이를 $N-1$번째 행까지 반복합니다.
2. 마지막 행($N-1$행)까지 처리가 끝났을 때, 마지막 행의 모든 칸이 0이 되어있다면 성공한 케이스입니다. 그렇지 않다면 실패입니다.

### 알고리즘 단계
1. **첫 번째 행의 모든 조작 경우의 수**를 완전 탐색합니다.
   - 첫 번째 행의 칸은 $N$개이고, 각 칸은 0번~3번 회전할 수 있습니다.
   - 경우의 수: $4^N$. 
   - $N=8$일 때 $4^8 = 65,536$가지 경우이므로 충분히 계산 가능합니다.
2. 각 경우마다:
   - 그리드를 복사(`deepcopy` 또는 슬라이싱)하여 시뮬레이션을 진행합니다.
   - 0번째 행의 조작을 수행합니다.
   - 1번째 행부터 $N-1$번째 행까지 순회하며, 바로 위 칸(`grid[r-1][c]`)이 0이 되도록 현재 칸(`grid[r][c]`)을 회전시킵니다.
   - 마지막에 $N-1$행이 모두 0인지 확인하고, 그렇다면 총 조작 횟수를 갱신합니다.

---

## 3. Python 풀이

```python
from itertools import product

def solution(clockHands):
    n = len(clockHands)
    ans = float('inf')
    
    # 상하좌우 및 자기 자신 변화량 (행, 열)
    dx = [0, -1, 1, 0, 0]
    dy = [0, 0, 0, -1, 1]
    
    # 첫 번째 줄의 모든 경우의 수 탐색 (4^n 가지)
    # product(range(4), repeat=n)은 (0,0,...,0) ~ (3,3,...,3) 까지 생성
    for first_row_rots in product(range(4), repeat=n):
        # 원본 보호를 위해 복사 (N이 작으므로 직접 복사도 빠름)
        grid = [row[:] for row in clockHands]
        total_rots = 0
        
        # 1. 첫 번째 행 조작 적용
        for col in range(n):
            rots = first_row_rots[col]
            if rots == 0: continue
            
            total_rots += rots
            # (0, col) 주변 5칸 회전 적용
            for i in range(5):
                nx, ny = 0 + dx[i], col + dy[i]
                if 0 <= nx < n and 0 <= ny < n:
                    grid[nx][ny] = (grid[nx][ny] + rots) % 4
        
        # 2. 두 번째 행부터 마지막 행까지
        # 바로 위(r-1, c)의 값을 0으로 만들기 위해 (r, c)를 조작
        for r in range(1, n):
            for c in range(n):
                # 바로 위 칸의 값
                val_above = grid[r-1][c]
                if val_above == 0: continue
                
                # 위 칸을 0으로 만들기 위해 필요한 회전 수
                # (val_above + needed) % 4 == 0  => needed = (4 - val_above) % 4
                needed = (4 - val_above) % 4
                
                total_rots += needed
                
                # (r, c) 주변 5칸 회전 적용
                for i in range(5):
                    nx, ny = r + dx[i], c + dy[i]
                    if 0 <= nx < n and 0 <= ny < n:
                        grid[nx][ny] = (grid[nx][ny] + needed) % 4
        
        # 3. 마지막 행 검사
        # 모든 칸이 0이어야 성공
        if all(val == 0 for val in grid[n-1]):
            ans = min(ans, total_rots)
            
    return ans
```

### 코드 분석
- **`product(range(4), repeat=n)`**: 첫 번째 행의 각 칸에 대해 0, 1, 2, 3번 회전하는 모든 조합을 생성합니다.
- **`grid[nx][ny] = (grid[nx][ny] + needed) % 4`**: 시계 바늘이 회전했을 때 값을 갱신하는 로직입니다.
- **Greedy Logic**: `r`행의 조작은 `r-1`행의 상태를 해결하기 위해 '강제'되므로, 2중 포문 안에서의 결정은 유일합니다. 따라서 첫 번째 행의 초기값만 정해주면 전체 판의 결과가 결정됩니다.

## 4. 복잡도 분석
- **시간 복잡도**: $O(4^N \times N^2)$
  - 첫 행의 경우의 수: $4^N$.
  - 각 경우에 대해 전체 그리드 순회: $N^2$.
  - $N=8$일 최대 때 약 $65,536 \times 64 \approx 4,200,000$ 연산으로, Python 기준 1초 내에 충분히 통과 가능합니다.
- **공간 복잡도**: $O(N^2)$
  - 그리드 복사본을 유지하는 공간입니다.
