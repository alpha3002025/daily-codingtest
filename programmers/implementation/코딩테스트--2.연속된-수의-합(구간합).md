# 2. 연속된 수의 합 (구간합) (level 0)

풀이 1 번은 어떤 연속 수열의 길이가 num 개이고 합이 total 일때 이때 num 개의 가장 큰수를 찾는다. 나머지는 버리고 몫을 통해서 구했기에 딱 떨어지는 것은 아니고 그 다음 과정에서 range 를 만들어가면서 답을 찾아야 한다.

풀이 2번은 이해를 못했다.  claude 의 해설을 빌려보면 다음과 같다.
`solution(3, 12)`인 경우:
- `var = 0+1+2+3 = 6` (1,2,3의 합)
- `diff = 12 - 6 = 6`
- `start_num = 6 // 3 = 2`
- 결과: `[1+2, 2+2, 3+2] = [3, 4, 5]`
- 검증: 3+4+5 = 12 ✓


# Link
https://school.programmers.co.kr/learn/courses/30/lessons/120923

# python (1)
- num 개의 같은 수를 더해서 total 이 되는 지점인 `biggest_n` 을 구한다. 이 지점부터 연속되는 숫자의 구간 내에서 문제에서 원하는 리스트를 찾아나간다.
```python
def solution(num, total):
    biggest_n = total // num ### 가장큰수 x num 을 하는 케이스로 끝지점을 먼저 구한다.
    
    for i in range(num): ### 뒤에서부터 카운팅
        curr_range = range(biggest_n - i, biggest_n - i + num) ## 출발지점 (biggest_n -i 로부터 num개의 수를 배열)
        if sum(curr_range) == total:
            return list(curr_range)
```


# python (2)
이 풀이 방식은 이해가 어려웠다. claude 의 해설을 빌려보면 다음과 같다.
`solution(3, 12)`인 경우:
- `var = 0+1+2+3 = 6` (1,2,3의 합)
- `diff = 12 - 6 = 6`
- `start_num = 6 // 3 = 2`
- 결과: `[1+2, 2+2, 3+2] = [3, 4, 5]`
- 검증: 3+4+5 = 12 ✓

이 알고리즘의 핵심 아이디어는 **기본 연속수열(1,2,3,...)에서 시작점을 적절히 이동시켜 목표합을 만족시키는 것**입니다.

```python
def solution(num, total):
    var = sum(range(num+1))
    diff = total - var
    start_num = diff // num
    
    return [i+1+start_num for i in range(num)]
```