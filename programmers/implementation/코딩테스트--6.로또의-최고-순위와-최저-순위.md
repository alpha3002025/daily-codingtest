최소: lottos 의 숫자 들 중 `win_nums` 에 존재하는 숫자의 수
최대: 최소값 + 0의 개수
- 어차피 수가 중복되지 않기에, 0의 개수를 그대로 더하면 된다. 
- 만약 수가 중복가능하면, 1~45 를 돌려서 체크

Rank 계산하는것도 내 입장에서는 기발하게 보였던건 배열의 인덱스를 그대로 잘 활용했다는 점이다. 실전에서도 이런거 써먹어보고 싶다.

# Link
https://school.programmers.co.kr/learn/courses/30/lessons/77484


# python
```python
def solution(lottos, win_nums):
    
    erased = 0
    min_count, max_count = 0,0
    for n in lottos:
        if n == 0:
            erased+=1
        else:
            if n in win_nums:
                min_count+=1
    
    max_count = min_count + erased
    
    rank = [6,6,5,4,3,2,1]
    
    return [rank[max_count], rank[min_count]]
```


# python (my) - 1차 (실행(o), 제출(fail))
내 경우에는 차집합 의 개념을 이용해 계산하려 했었다. 
```python
from collections import defaultdict

def solution(lottos, win_nums):
    
    rank_ = defaultdict(int, {
        6:1,
        5:2,
        4:3,
        3:4,
        2:5
    })
    
    
    def cal_rank(r_, m):
        return 6 if r_[m] == 0 else r_[m]
    
    
    min_count, max_count = 0,0
    
    numbers = set(win_nums)
    
    min_set = set()
    for l in lottos:
        if l in win_nums:
            min_set.add(l)
    diff = numbers - min_set
    
    min_count = len(min_set)
    max_count = 6 if len(diff) == 0 else len(diff)
    
    # print(f"diff = {diff}, min_set = {min_set}, numbers = {numbers}")
    
    min_rank = cal_rank(rank_, min_count)
    max_rank = cal_rank(rank_, max_count)
    return [max_rank, min_rank]
```


