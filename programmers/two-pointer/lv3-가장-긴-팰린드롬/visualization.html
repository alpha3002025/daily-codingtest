<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Longest Palindrome Visualization</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

        :root {
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --text-color: #f1f5f9;
            --muted-text: #94a3b8;
            --primary: #3b82f6;
            --success: #10b981;
            --error: #ef4444;
            --highlight: #f59e0b;
            --center-marker: #8b5cf6;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 2rem;
            box-sizing: border-box;
        }

        h1 {
            font-weight: 700;
            margin-bottom: 2rem;
            background: linear-gradient(to right, var(--primary), var(--center-marker));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        .container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        /* Controls Area */
        .controls {
            background-color: var(--card-bg);
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
            justify-content: center;
        }

        input {
            background-color: var(--bg-color);
            border: 1px solid #334155;
            color: var(--text-color);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 1rem;
            flex-grow: 1;
            min-width: 200px;
            outline: none;
            transition: border-color 0.2s;
        }

        input:focus {
            border-color: var(--primary);
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        button:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background-color: #334155;
        }

        /* Visualization Area */
        .visualizer-container {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 12px;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
        }

        .string-display {
            display: flex;
            gap: 4px;
            padding: 1rem;
        }

        .char-box {
            width: 40px;
            height: 40px;
            background-color: var(--bg-color);
            border: 2px solid #334155;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.2rem;
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .char-idx {
            position: absolute;
            top: -25px;
            font-size: 0.75rem;
            color: var(--muted-text);
            font-weight: 400;
        }

        /* States */
        .char-box.center {
            border-color: var(--center-marker);
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.3);
            transform: translateY(-4px);
        }

        .char-box.active {
            border-color: var(--highlight);
        }

        .char-box.match {
            background-color: rgba(16, 185, 129, 0.2);
            border-color: var(--success);
            color: var(--success);
        }

        .char-box.mismatch {
            background-color: rgba(239, 68, 68, 0.2);
            border-color: var(--error);
            color: var(--error);
        }

        .char-box.final-palindrome {
            background-color: rgba(59, 130, 246, 0.2);
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
        }

        /* Legend */
        .status-panel {
            display: flex;
            gap: 2rem;
            font-size: 0.9rem;
            color: var(--muted-text);
            width: 100%;
            justify-content: space-around;
            padding-top: 1rem;
            border-top: 1px solid #334155;
        }

        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .status-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-color);
        }

        .legend {
            display: flex;
            gap: 1rem;
            font-size: 0.8rem;
            margin-top: 1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        /* Labels for pointers */
        .pointer-label {
            position: absolute;
            bottom: -25px;
            font-size: 0.75rem;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 4px;
            color: white;
            z-index: 10;
        }

        /* L and R labels */
        .label-l {
            background-color: var(--warning, #f59e0b);
            left: 50%;
            transform: translateX(-100%);
            margin-left: -2px;
        }

        .label-r {
            background-color: var(--warning, #f59e0b);
            left: 50%;
            transform: translateX(0%);
            margin-left: 2px;
        }

        /* Unified pointer if L==R */
        .label-c {
            background-color: var(--center-marker);
        }
    </style>
</head>

<body>

    <h1>Longest Palindrome Visualization</h1>

    <div class="container">

        <div class="controls">
            <input type="text" id="inputString" value="abacde" placeholder="Enter string (e.g., abcdcba)"
                maxlength="20">
            <button onclick="startVisualization()">Restart</button>
            <button onclick="stepForward()" class="secondary" id="stepBtn">Step &rarr;</button>
            <button onclick="toggleAutoPlay()" class="secondary" id="autoBtn">Auto Play</button>
        </div>

        <div class="visualizer-container">
            <div class="string-display" id="displayArea">
                <!-- String characters will be generated here -->
            </div>

            <div class="status-panel">
                <div class="status-item">
                    <span>Center Index</span>
                    <span id="statusCenter" class="status-value">-</span>
                </div>
                <div class="status-item">
                    <span>Type</span>
                    <span id="statusType" class="status-value">-</span>
                </div>
                <div class="status-item">
                    <span>Current Length</span>
                    <span id="statusCurrLen" class="status-value">0</span>
                </div>
                <div class="status-item">
                    <span>Max Length</span>
                    <span id="statusMaxLen" class="status-value">0</span>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="dot" style="background: var(--center-marker)"></div>Center
                </div>
                <div class="legend-item">
                    <div class="dot" style="background: var(--success)"></div>Match
                </div>
                <div class="legend-item">
                    <div class="dot" style="background: var(--error)"></div>Mismatch
                </div>
                <div class="legend-item">
                    <div class="dot" style="background: var(--primary)"></div>Best So Far
                </div>
            </div>
        </div>
    </div>

    <script>
        // State
        let s = "";
        let steps = [];
        let currentStepIndex = -1;
        let isAutoPlaying = false;
        let autoPlayInterval = null;

        const inputEl = document.getElementById('inputString');
        const displayEl = document.getElementById('displayArea');
        const statusCenter = document.getElementById('statusCenter');
        const statusType = document.getElementById('statusType');
        const statusCurrLen = document.getElementById('statusCurrLen');
        const statusMaxLen = document.getElementById('statusMaxLen');
        const stepBtn = document.getElementById('stepBtn');
        const autoBtn = document.getElementById('autoBtn');

        // Logic to pre-calculate steps
        function generateSteps(str) {
            const stepList = [];
            const n = str.length;

            // Initial state
            stepList.push({
                type: 'init',
                message: 'Start',
                maxLen: 0,
                maxStart: 0,
                maxEnd: 0,
                center: -1,
                left: -1,
                right: -1,
                matchStatus: 'none' // none, match, mismatch
            });

            if (n === 0) return stepList;

            let maxLen = 0;
            let maxStart = 0;
            let maxEnd = 0; // inclusive

            // Helper to add steps for expansion
            const expand = (centerIdx, isEven) => {
                let left = centerIdx;
                let right = isEven ? centerIdx + 1 : centerIdx;
                let currentLen = 0;

                stepList.push({
                    type: 'new_center',
                    center: centerIdx,
                    centerType: isEven ? 'Even' : 'Odd',
                    left: left,
                    right: right,
                    maxLen: maxLen,
                    maxStart: maxStart,
                    maxEnd: maxEnd,
                    matchStatus: 'none',
                    message: `Checking center ${centerIdx} (${isEven ? 'Even' : 'Odd'})`
                });

                while (left >= 0 && right < n) {
                    // Pre-check state
                    stepList.push({
                        type: 'check',
                        center: centerIdx,
                        centerType: isEven ? 'Even' : 'Odd',
                        left: left,
                        right: right,
                        maxLen: maxLen,
                        maxStart: maxStart,
                        maxEnd: maxEnd,
                        matchStatus: 'checking',
                        message: `Comparing s[${left}] ('${str[left]}') and s[${right}] ('${str[right]}')`
                    });

                    if (str[left] === str[right]) {
                        // Match found
                        currentLen = right - left + 1;
                        if (currentLen > maxLen) {
                            maxLen = currentLen;
                            maxStart = left;
                            maxEnd = right;
                        }

                        stepList.push({
                            type: 'match',
                            center: centerIdx,
                            centerType: isEven ? 'Even' : 'Odd',
                            left: left,
                            right: right,
                            maxLen: maxLen,
                            maxStart: maxStart,
                            maxEnd: maxEnd,
                            matchStatus: 'match',
                            message: `Match! Expanding...`
                        });

                        left--;
                        right++;
                    } else {
                        // Mismatch
                        stepList.push({
                            type: 'mismatch',
                            center: centerIdx,
                            centerType: isEven ? 'Even' : 'Odd',
                            left: left,
                            right: right,
                            maxLen: maxLen,
                            maxStart: maxStart,
                            maxEnd: maxEnd,
                            matchStatus: 'mismatch',
                            message: `Mismatch.`
                        });
                        break;
                    }
                }
            };

            for (let i = 0; i < n; i++) {
                // Odd length
                expand(i, false);
                // Even length
                if (i < n - 1) {
                    expand(i, true);
                }
            }

            // Final state
            stepList.push({
                type: 'done',
                maxLen: maxLen,
                maxStart: maxStart,
                maxEnd: maxEnd,
                center: -1,
                left: -1,
                right: -1,
                matchStatus: 'none',
                message: 'Finished!'
            });

            return stepList;
        }

        function renderString() {
            displayEl.innerHTML = '';
            for (let i = 0; i < s.length; i++) {
                const box = document.createElement('div');
                box.className = 'char-box';
                box.textContent = s[i];

                const idx = document.createElement('div');
                idx.className = 'char-idx';
                idx.textContent = i;
                box.appendChild(idx);

                displayEl.appendChild(box);
            }
        }

        function updateUI(step) {
            const boxes = document.querySelectorAll('.char-box');

            // Reset styles
            boxes.forEach(b => {
                b.className = 'char-box';
                // Remove pointer labels
                const oldLabels = b.querySelectorAll('.pointer-label');
                oldLabels.forEach(l => l.remove());
            });

            // Highlight Max Palindrome Found So Far
            if (step.maxLen > 0) {
                for (let i = step.maxStart; i <= step.maxEnd; i++) {
                    if (boxes[i]) boxes[i].classList.add('final-palindrome');
                }
            }

            // If invalid state or done
            if (step.center === -1) {
                statusCenter.textContent = '-';
                statusType.textContent = '-';
                return;
            }

            // Highlight Center
            if (boxes[step.center]) {
                boxes[step.center].classList.add('center');
                if (step.centerType === 'Even' && boxes[step.center + 1]) {
                    // For even, visual center is between i and i+1, maybe mark both?
                    // Let's mark the primary center index
                }
            }

            statusCenter.textContent = step.center;
            statusType.textContent = step.centerType;
            statusMaxLen.innerText = step.maxLen;
            statusCurrLen.innerText = (step.right - step.left - 1) > 0 ? (step.right - step.left - 1) : 0; // Rough calc, specific logic below better

            // Initial new center setup
            if (step.type === 'new_center') {
                return;
            }

            // Visualization for check/match/mismatch
            if (step.left >= 0 && step.left < s.length) {
                const box = boxes[step.left];
                const label = document.createElement('div');
                label.className = 'pointer-label label-l';
                label.textContent = 'L';
                box.appendChild(label);
            }
            if (step.right >= 0 && step.right < s.length) {
                const box = boxes[step.right];
                const label = document.createElement('div');
                label.className = 'pointer-label label-r';
                label.textContent = 'R';
                box.appendChild(label);

                // Handle single center case separate logic visually?
                // If L==R, maybe just one label "L/R" or center color?
            }

            if (step.matchStatus === 'match') {
                if (boxes[step.left]) boxes[step.left].classList.add('match');
                if (boxes[step.right]) boxes[step.right].classList.add('match');
                statusCurrLen.innerText = step.right - step.left + 1;
            } else if (step.matchStatus === 'mismatch') {
                if (boxes[step.left]) boxes[step.left].classList.add('mismatch');
                if (boxes[step.right]) boxes[step.right].classList.add('mismatch');
            } else if (step.matchStatus === 'checking') {
                if (boxes[step.left]) boxes[step.left].classList.add('active');
                if (boxes[step.right]) boxes[step.right].classList.add('active');
            }
        }

        function startVisualization() {
            s = inputEl.value;
            if (!s) return;

            steps = generateSteps(s);
            currentStepIndex = 0;
            renderString();
            updateUI(steps[0]);

            // Stop logic
            if (isAutoPlaying) {
                clearInterval(autoPlayInterval);
                isAutoPlaying = false;
                autoBtn.textContent = 'Auto Play';
            }
        }

        function stepForward() {
            if (currentStepIndex < steps.length - 1) {
                currentStepIndex++;
                updateUI(steps[currentStepIndex]);
            } else {
                if (isAutoPlaying) toggleAutoPlay();
            }
        }

        function toggleAutoPlay() {
            if (isAutoPlaying) {
                clearInterval(autoPlayInterval);
                isAutoPlaying = false;
                autoBtn.textContent = 'Auto Play';
            } else {
                if (currentStepIndex >= steps.length - 1) currentStepIndex = 0;
                isAutoPlaying = true;
                autoBtn.textContent = 'Pause';
                autoPlayInterval = setInterval(stepForward, 500); // 500ms per step
            }
        }

        // Init
        startVisualization();

    </script>
</body>

</html>