# 프로그래머스 - 가장 긴 팰린드롬 (Level 3)

## 문제 설명
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12904)

앞뒤를 뒤집어도 똑같은 문자열을 팰린드롬(palindrome)이라고 합니다.
문자열 `s`가 주어질 때, `s`의 부분문자열(Substring)중 가장 긴 팰린드롬의 길이를 return 하는 `solution` 함수를 완성해 주세요.

예를들면, 문자열 `s`가 "abcdcba"이면 7을 return하고 "abacde"이면 3을 return합니다.

### 제한사항
- 문자열 `s`의 길이 : 2,500 이하의 자연수
- 문자열 `s`는 알파벳 소문자로만 구성

### 입출력 예
| s | answer |
|---|---|
| "abcdcba" | 7 |
| "abacde" | 3 |

---

## 문제 풀이

이 문제는 문자열 내에서 가장 긴 팰린드롬 부분 문자열을 찾는 고전적인 문제입니다.
주어진 제한사항에서 문자열 `s`의 길이가 최대 2,500이므로, $O(N^2)$ 시간 복잡도를 가진 알고리즘으로 충분히 통과할 수 있습니다.

### 접근 방법: 중심 확산법 (Expand Around Center)

팰린드롬은 중심을 기준으로 대칭인 문자열입니다. 따라서 문자열의 각 문자를 중심으로 잡고, 양쪽으로 펼쳐나가며 팰린드롬 여부를 확인할 수 있습니다.

1. **중심점(Center)의 종류**:
   - 길이가 **홀수**인 팰린드롬: 중심이 문자 하나입니다. (예: "aba", 중심 'b')
   - 길이가 **짝수**인 팰린드롬: 중심이 문자 사이(혹은 두 문자)입니다. (예: "abba", 중심 'bb')

2. **알고리즘 동작**:
   - 문자열의 인덱스 `i`를 `0`부터 `len(s)-1`까지 순회합니다.
   - 각 `i`에 대해 두 가지 경우를 검사합니다:
     1. `i`를 중심으로 하는 홀수 길이 팰린드롬 확장 (`left=i`, `right=i`)
     2. `i`와 `i+1`을 중심으로 하는 짝수 길이 팰린드롬 확장 (`left=i`, `right=i+1`)
   - `expand(left, right)` 함수는 `s[left]`와 `s[right]`가 같을 때까지 **`left`는 왼쪽(인덱스 감소)으로**, **`right`는 오른쪽(인덱스 증가)으로** 이동하며 확장합니다.
   - 확장이 멈추면 그때의 길이를 계산하여 최대값을 갱신합니다.

### 코드 구현 (Python)

```python
def solution(s):
    # 예외 처리: 길이가 1 이하이거나 문자열 전체가 팰린드롬인 경우 바로 반환
    # 이 부분은 필수적인 최적화는 아니지만, 효율성을 높여줍니다.
    if len(s) < 2 or s == s[::-1]:
        return len(s)

    def expand(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1  # 왼쪽으로 이동 (인덱스 감소)
            right += 1 # 오른쪽으로 이동 (인덱스 증가)
        # while문이 끝났을 때는 조건을 만족하지 않는 상태이므로
        # 실제 팰린드롬 범위는 (left + 1) ~ (right - 1) 입니다.
        # 길이는 (right - 1) - (left + 1) + 1 = right - left - 1
        return right - left - 1

    max_len = 0
    for i in range(len(s) - 1):
        # 홀수 길이 팰린드롬 (중심: i)
        # 짝수 길이 팰린드롬 (중심: i, i+1)
        max_len = max(max_len, expand(i, i), expand(i, i + 1))

    return max_len
```

### 시간 복잡도 분석
- 바깥 반복문은 문자열 길이 $N$만큼 돕니다.
- 내부 `expand` 함수는 최악의 경우(모든 문자가 같을 때) 중심에서 양쪽 끝까지 확장하므로 최대 $O(N)$이 걸립니다.
- 따라서 전체 시간 복잡도는 $O(N^2)$입니다.
- $N=2500$일 때 $N^2 = 6,250,000$이므로 시간 제한 내에 충분히 돕니다.

### 참고: Manacher 알고리즘
- 팰린드롬 문제를 $O(N)$에 해결하는 Manacher's Algorithm이 존재하지만, 구현이 복잡하고 이 문제의 제한사항($N \le 2500$) 하에서는 $O(N^2)$ 풀이로도 충분합니다. 코딩 테스트에서는 구현이 간단하고 확실한 방법을 선택하는 것이 좋습니다.
