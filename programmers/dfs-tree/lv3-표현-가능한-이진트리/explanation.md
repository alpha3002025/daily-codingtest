# 표현 가능한 이진트리 (Level 3, 2023 KAKAO BLIND RECRUITMENT)

## 문제 설명
프로그래머스 "표현 가능한 이진트리" 문제는 주어진 십진수를 이진수로 변환했을 때, 이 이진수가 **포화 이진트리(Full Binary Tree)** 형태의 구조를 가질 수 있는지 판별하는 문제입니다.

### 핵심 개념
1.  **포화 이진트리 (Full Binary Tree)**:
    -   모든 레벨이 꽉 차 있는 이진트리입니다.
    -   노드의 개수는 항상 **$2^h - 1$**개입니다. ($h$: 트리의 높이)
    -   예: 1, 3, 7, 15, 31, ...
2.  **더미 노드 (0)**:
    -   주어진 이진수의 길이가 포화 이진트리 노드 수보다 작다면, 앞에 `0`을 채워(왼쪽 패딩) 포화 이진트리 형태로 만들어야 합니다.
    -   이때 `0`은 **더미 노드**를 의미하며, 실제로는 존재하지 않는 노드입니다.
3.  **유효성 조건**:
    -   이진트리의 **부모-자식 관계**에서 가장 중요한 규칙:
    -   **"부모가 0(더미)이면, 자식도 반드시 0이어야 한다."**
    -   부모 노드가 `0`이라는 것은 아예 존재하지 않는다는 뜻이므로, 그 밑에 자식 노드가 `1`(실존)일 수 없습니다.

## 해결 방법
### 1. 이진수 변환 및 패딩 (Padding)
-   입력된 수 `number`를 이진수 문자열로 변환합니다. (`bin` 함수 사용)
-   문자열의 길이 `L`이 포화 이진트리의 노드 수($2^h - 1$)가 되도록 앞에 `0`을 붙입니다.
-   필요한 길이 구하기: `L`보다 크거나 같은 가장 작은 $2^h - 1$을 찾습니다.

### 2. 재귀적 유효성 검사 (Divide and Conquer)
-   만들어진 이진 문자열의 **중앙값**이 현재 서브트리의 **루트(Root)**가 됩니다.
-   **검사 로직**:
    1.  현재 루트가 `0`인 경우:
        -   왼쪽 자식 서브트리와 오른쪽 자식 서브트리에 **`1`이 하나라도 있으면 안 됩니다.**
        -   즉, 루트가 없으면 하위 노드들도 다 없어야 합니다.
    2.  현재 루트가 `1`인 경우:
        -   왼쪽 자식과 오른쪽 자식에 대해 각각 재귀적으로 검사를 수행합니다.
        -   자식들이 유효한 트리 구조인지 확인합니다.

## Python 풀이

```python
import math

def check_tree(binary_sub):
    # 기저 사례: 길이가 1이면(리프 노드) 항상 True (1이든 0이든 상관없음)
    if len(binary_sub) == 1:
        return True
    
    mid = len(binary_sub) // 2
    root = binary_sub[mid]
    left_sub = binary_sub[:mid]
    right_sub = binary_sub[mid+1:]
    
    # 루트가 0인데 자식 중에 1이 하나라도 있으면 False (불가능한 트리)
    if root == '0':
        # 자식 서브트리에 '1'이 포함되어 있다면 유효하지 않음
        if '1' in left_sub or '1' in right_sub:
            return False
            
    # 그 외의 경우(루트가 1이거나, 루트가 0이고 자식도 다 0인 경우)
    # 왼쪽과 오른쪽 서브트리도 재귀적으로 확인
    return check_tree(left_sub) and check_tree(right_sub)

def solution(numbers):
    answer = []
    
    for num in numbers:
        # 1. 이진수 변환 (0b 접두어 제거)
        binary_str = bin(num)[2:]
        length = len(binary_str)
        
        # 2. 포화 이진트리 길이로 맞추기 (Padding)
        # 2^h - 1 형태가 될 때까지 h를 증가
        h = 0
        while (2**h - 1) < length:
            h += 1
        
        full_length = 2**h - 1
        # 앞부분에 0을 채워서 길이 맞춤
        padded_binary = binary_str.zfill(full_length)
        
        # 3. 트리 유효성 검사
        if check_tree(padded_binary):
            answer.append(1)
        else:
            answer.append(0)
            
    return answer
```

## 복잡도 분석
-   **시간 복잡도**: `O(N * log M)` (`N`: `numbers`의 개수, `M`: 숫자의 크기)
    -   각 숫자에 대해 이진수 길이가 약 `log M`입니다.
    -   재귀 함수는 트리 노드 수만큼 호출되므로 이진수 길이에 비례합니다.
-   **공간 복잡도**: `O(log M)`
    -   재귀 호출 스택 깊이와 이진수 문자열 저장 공간이 필요합니다.

## 코드 설명

### 이진수 변환 및 포화 이진트리 패딩(Padding)

```python
        # 1. 이진수 변환 (0b 접두어 제거)
        binary_str = bin(num)[2:]
        length = len(binary_str)
        
        # 2. 포화 이진트리 길이로 맞추기 (Padding)
        h = 0
        while (2**h - 1) < length:
            h += 1
        
        full_length = 2**h - 1
        # 앞부분에 0을 채워서 길이 맞춤
        padded_binary = binary_str.zfill(full_length)
```

이 부분은 입력된 숫자를 문제에서 요구하는 **트리 형태의 이진 문자열**로 변환하는 전처리 과정입니다.

1.  **이진수 변환**:
    -   `bin(num)` 함수는 `0b101`과 같이 접두어 `0b`를 포함하므로, 슬라이싱 `[2:]`을 통해 순수 이진수 문자열만 추출합니다.
2.  **포화 이진트리 길이 계산**:
    -   문제의 조건에 따라 이진트리는 **포화 이진트리(Full Binary Tree)** 형태여야 합니다.
    -   높이가 `h`인 포화 이진트리의 노드 개수는 항상 **$2^h - 1$**개입니다. (예: 1, 3, 7, 15, 31...)
    -   따라서 `while`문을 통해 현재 이진수 길이(`length`)를 수용할 수 있는 가장 작은 포화 이진트리 크기(`full_length`)를 찾습니다.
3.  **패딩(Padding)**:
    -   `zfill(full_length)` 함수를 사용하여 부족한 길이만큼 문자열의 **앞부분(왼쪽)**을 `0`(더미 노드)으로 채웁니다.
    -   이렇게 해야 트리의 구조가 무너지지 않고 루트 노드와 자식 노드의 인덱스를 올바르게 찾을 수 있습니다.



### 트리 구조 분할 (Root, Left, Right)

```python
    mid = len(binary_sub) // 2
    root = binary_sub[mid]
    left_sub = binary_sub[:mid]
    right_sub = binary_sub[mid+1:]
```

이 부분은 이진 문자열을 **트리 구조로 해석하기 위해 분할**하는 과정입니다.

1.  **루트 노드(`root`)**:
    -   포화 이진트리의 특성상, 순회 결과(문자열)의 **가장 가운데에 있는 값**이 항상 해당 서브트리의 루트 노드가 됩니다.
    -   인덱스 `mid`를 통해 루트 노드의 값(`0` 또는 `1`)을 추출합니다.
2.  **왼쪽/오른쪽 서브트리 (`left_sub`/`right_sub`)**:
    -   루트를 기준으로 앞부분(`:mid`)은 왼쪽 자식 서브트리, 뒷부분(`mid+1:`)은 오른쪽 자식 서브트리가 됩니다.
    -   이러한 분할 정복 방식을 통해 재귀적으로 트리의 하위 구조를 검사할 수 있습니다.


### 유효성 검사 (부모-자식 규칙)

```python
    # 루트가 0인데 자식 중에 1이 하나라도 있으면 False (불가능한 트리)
    if root == '0':
        # 자식 서브트리에 '1'이 포함되어 있다면 유효하지 않음
        if '1' in left_sub or '1' in right_sub:
            return False
```

이 부분은 "표현 가능한 이진트리" 여부를 판별하는 **가장 중요한 조건**입니다.

1.  **규칙의 의미**:
    -   포화 이진트리에서 부모 노드가 `0`(더미 노드, 존재하지 않음)이라면, 그 자식 노드들도 당연히 존재할 수 없습니다.
    -   즉, **"부모가 없으면 자식도 없어야 한다"**는 논리입니다.
2.  **검사 방법**:
    -   현재 서브트리의 루트가 `0`인 경우, 왼쪽 자식(`left_sub`)이나 오른쪽 자식(`right_sub`) 문자열에 하나라도 `1`이 포함되어 있는지 확인합니다.
    -   만약 `1`이 있다면 "존재하지 않는 부모 밑에 존재하는 자식"이 있는 모순된 상황이므로 `False`를 반환합니다.




### 재귀 호출 (분할 정복)

```python
    # 그 외의 경우(루트가 1이거나, 루트가 0이고 자식도 다 0인 경우)
    # 왼쪽과 오른쪽 서브트리도 재귀적으로 확인
    return check_tree(left_sub) and check_tree(right_sub)
```

현재 루트 노드에 대한 검사가 통과되었다면, 이제 하위 서브트리들도 유효한지 확인해야 합니다.

1.  **재귀적 확인**:
    -   왼쪽 자식 서브트리(`left_sub`)와 오른쪽 자식 서브트리(`right_sub`)에 대해 각각 `check_tree` 함수를 재귀적으로 호출합니다.
    -   이는 큰 트리의 문제를 작은 서브트리의 문제로 쪼개어 해결하는 **분할 정복(Divide and Conquer)** 방식입니다.
2.  **논리 연산자 `and`**:
    -   전체 트리가 유효하려면, 루트의 유효성뿐만 아니라 **왼쪽 자식 트리와 오른쪽 자식 트리 모두가 유효**해야 합니다.
    -   따라서 두 재귀 호출의 결과가 모두 `True`일 때만 최종적으로 `True`를 반환합니다. 하나라도 `False`라면 전체 트리는 표현 불가능한 상태가 됩니다.






### 심화 개념: 왜 "부모가 0이면 자식도 0"이어야 할까?

이 조건은 문제에서 이진수를 트리로 변환하는 과정을 역추적할 때 발생하는 논리적 제약입니다.

1.  **더미 노드(Dummy Node)의 의미**:
    -   이진수의 `0`은 해당 위치에 노드가 **없음(Empty)**을 나타내는 것이 아니라, 포화 이진트리의 모양을 갖추기 위해 채워 넣은 **공백**과 같습니다.
    -   즉, `0`인 노드는 "존재하지 않는 노드" 취급을 받습니다.

2.  **연결성(Connectivity)의 모순**:
    -   트리 구조에서 자식 노드는 부모 노드에 **연결**되어 있어야 존재할 수 있습니다.
    -   만약 부모 노드가 `0`(존재하지 않음)인데 자식 노드가 `1`(존재함)이라면, **"존재하지 않는 허구의 부모에 매달려 있는 실제 자식"**이라는 모순이 발생합니다.
    -   마치 "가지(Branch)가 잘려 나갔는데 그 끝에 잎사귀(Leaf)가 공중에 떠 있는 상황"과 같습니다.

3.  **결론**:
    -   따라서 부모 노드가 `0`이라면, 그 하위의 모든 서브트리는 반드시 `0`이어야만 논리적으로 올바른 트리 구조가 성립합니다.
    -   이것이 이 문제의 유효성을 판단하는 **필요충분조건**입니다.
