# 숫자 타자 대회 (Level 3)

## 문제 설명
프로그래머스 "숫자 타자 대회" 문제는 숫자로 된 문자열을 두 손가락(왼손, 오른손)을 이용해 입력할 때 비용을 최소화하는 **동적계획법(Dynamic Programming)** 문제입니다. 4x3 크기의 숫자 패드에서 특정 규칙에 따라 두 손가락의 위치를 옮기며 숫자를 누르는 과정에서 발생하는 가중치(비용)의 합을 줄이는 것이 목표입니다.

### 핵심 개념
1.  **상태 정의**: `dp[index][left_finger][right_finger]`
    -   `index`: 현재 눌러야 할 숫자의 인덱스
    -   `left_finger`: 왼손 엄지손가락의 위치 (0~9, *, #)
    -   `right_finger`: 오른손 엄지손가락의 위치 (0~9, *, #)
    -   문제에서 사용되는 숫자는 0~9뿐이지만, 패드 구조상 *와 # 위치도 고려해야 합니다(초기 위치는 4, 6).
2.  **비용(가중치) 계산**:
    -   **제자리(0)**: 1
    -   **상하좌우(1)**: 2
    -   **대각선(1.414..)**: 3
    -   **그 외**: 4 이상
    -   미리 모든 숫자 쌍(0~9) 간의 비용을 계산해두는(Pre-calculation) 것이 효율적입니다.
3.  **제약 조건**: 하나의 숫자 위에 두 손가락이 동시에 올라갈 수 없습니다.

## 해결 방법

### 1. 키패드 좌표화 및 비용 행렬 생성
각 키패드 숫자를 (행, 열) 좌표로 매핑합니다.
-   1:(0,0), 2:(0,1), ..., 0:(3,1) 등
이를 이용해 임의의 두 숫자 간 이동 비용을 미리 계산하여 `cost[start][end]` 2차원 배열에 저장합니다.

### 2. 동적계획법 (DP) 적용
`solve(idx, left, right)` 함수를 정의하여 재귀적으로 풀거나, 반복문을 이용한 DP로 해결합니다.
하지만 `left`, `right` 두 변수를 모두 관리하면 상태 공간이 너무 커질 수 있습니다(`100,000 * 10 * 10`은 가능하지만 최적화 필요).

**최적화 포인트**:
현재 눌러야 할 숫자가 `target`이라면, 다음 상태에서의 손가락 위치 중 하나는 반드시 `target`이 됩니다. 따라서 이전 상태의 `left`, `right` 중 하나가 `target`으로 바뀌는 것만 고려하면 됩니다.
DP 테이블을 `dp[idx][other_finger_pos]`로 줄일 수 있습니다. (현재 누른 숫자는 고정되어 있으므로, 반대쪽 손가락 위치만 저장)

### 3. 점화식
현재 눌러야 할 숫자가 `num`이고, 이전 단계에서 두 손가락 위치가 `L`, `R`이었다면:
1.  **왼손 이동**: `L -> num` 비용 + `solve(idx+1, num, R)`
2.  **오른손 이동**: `R -> num` 비용 + `solve(idx+1, L, num)`
단, `num == R`이라면 왼손으로 누를 수 없고(이미 오른손이 있으므로), 반대도 마찬가지입니다.

## Python 풀이

```python
import sys

# 재귀 깊이 제한 해제
sys.setrecursionlimit(200000)

def solution(numbers):
    # 키패드 좌표 매핑
    # 0~9까지 숫자의 좌표 (행, 열)
    # 1 2 3
    # 4 5 6
    # 7 8 9
    # * 0 #
    positions = {
        '1': (0, 0), '2': (0, 1), '3': (0, 2),
        '4': (1, 0), '5': (1, 1), '6': (1, 2),
        '7': (2, 0), '8': (2, 1), '9': (2, 2),
        '0': (3, 1)
    }
    
    # 두 숫자 간 이동 비용 계산 함수
    def get_cost(start, end):
        if start == end:
            return 1
        
        r1, c1 = positions[start]
        r2, c2 = positions[end]
        
        dist_r = abs(r1 - r2)
        dist_c = abs(c1 - c2)
        
        # 대각선 이동 최소화
        min_dist = min(dist_r, dist_c)
        # 직선 이동
        remain_dist = abs(dist_r - dist_c)
        
        # 대각선(3) * min_dist + 직선(2) * remain_dist
        # 단, 문제의 가중치 정의상 간단한 규칙으로 변환 가능하지 않고
        # 문제 예시에 따라 단순히 
        # 인접: 2, 대각선: 3, 그외: 4가 아니라
        # 거리에 따른 가중치 로직이 필요함.
        # 문제에서 정의된 가중치:
        # 제자리: 1
        # 상하좌우 인접: 2
        # 대각선 인접: 3
        # 그 외: 더 복잡할 수 있으나 문제 설명상 경로의 합.
        # 정확히는 (최소 이동 시간) 개념으로 접근:
        # 가중치 = (대각선 이동 횟수 * 3) + (직선 이동 횟수 * 2)
        # 대각선 이동 횟수 = min(|r1-r2|, |c1-c2|)
        # 직선 이동 횟수 = max(|r1-r2|, |c1-c2|) - min(...) = |dist_r - dist_c|
        
        if dist_r == 0 and dist_c == 0:
            return 1
        return (min_dist * 3) + (remain_dist * 2)

    # 비용 테이블 미리 계산 (Pre-calculation)
    costs = [[0] * 10 for _ in range(10)]
    for i in range(10):
        for j in range(10):
            costs[i][j] = get_cost(str(i), str(j))

    # DP 테이블: dp[index][left][right] -> 메모리 초과 가능성 존재
    # 최적화: dp 딕셔너리 사용 (현재 인덱스 단계의 { (left, right): min_cost } 형태)
    # 초기 상태: 왼손 4, 오른손 6 (문자열이지만 인덱스로 편하게 변환)
    # 편의상 '4', '6' 문자를 바로 쓰거나 정수형으로 매핑
    
    # 현재 단계의 가능한 상태들: { (left_pos, right_pos): cost }
    current_states = { ('4', '6'): 0 }
    
    for num in numbers:
        next_states = {}
        for (left, right), cost in current_states.items():
            # 목표 숫자
            target = num
            
            # 비용 계산을 위해 정수형 인덱스로 변환 필요하면 변환, 여기선 문자열 그대로 사용
            cost_l = costs[int(left)][int(target)]
            cost_r = costs[int(right)][int(target)]
            
            # 1. 왼손 이동 (목표 숫자가 오른손 위치와 다를 때만)
            if target != right:
                new_cost = cost + cost_l
                new_state = (target, right)
                if new_state not in next_states or new_cost < next_states[new_state]:
                    next_states[new_state] = new_cost
            
            # 2. 오른손 이동 (목표 숫자가 왼손 위치와 다를 때만)
            if target != left:
                new_cost = cost + cost_r
                new_state = (left, target)
                if new_state not in next_states or new_cost < next_states[new_state]:
                    next_states[new_state] = new_cost
        
        current_states = next_states
        
    return min(current_states.values())

```

## 복잡도 분석
-   **시간 복잡도**: `O(N)`
    -   `numbers`의 길이 `N`만큼 반복합니다.
    -   각 단계에서 관리해야 할 상태(두 손가락의 위치 조합)는 최대 `10 * 10 = 100`가지입니다. (실제로는 한 손가락이 `target`에 고정되므로 약 `10`개 내외)
    -   따라서 `O(100 * N)` -> `O(N)`으로 매우 효율적입니다.
-   **공간 복잡도**: `O(1)` (혹은 상수 크기의 메모리)
    -   `current_states`와 `next_states` 딕셔너리는 항상 최대 100개 미만의 키를 가집니다.


## 코드 설명


### 키패드 좌표 매핑

```python
    positions = {
        '1': (0, 0), '2': (0, 1), '3': (0, 2),
        '4': (1, 0), '5': (1, 1), '6': (1, 2),
        '7': (2, 0), '8': (2, 1), '9': (2, 2),
        '0': (3, 1)
    }
```
이 딕셔너리는 숫자 키패드를 **2차원 좌표 (행, 열)**로 변환하는 역할을 합니다.
문제에서 주어진 키패드는 4행 3열 형태이며, 두 숫자 사이의 거리를 계산하기 위해 각 숫자의 물리적 위치를 정의했습니다.

-   **구조**:
    -   `1, 2, 3` -> `0`행
    -   `4, 5, 6` -> `1`행
    -   `7, 8, 9` -> `2`행
    -   `*, 0, #` -> `3`행 (`*`와 `#`은 숫자가 아니므로 `0`만 정의)
-   **용도**: 이동 비용을 계산할 때 `(r1, c1)`과 `(r2, c2)`의 차이를 구하는 데 사용됩니다.

### 이동 비용 계산 (대각선 및 직선)

```python
    # 두 숫자 간 이동 비용 계산 함수
    def get_cost(start, end):
        # ... (좌표 및 거리 계산 생략)
        
        # 대각선 이동 (비용 3)
        min_dist = min(dist_r, dist_c)
        # 직선 이동 (비용 2)
        remain_dist = abs(dist_r - dist_c)
        
        # 최종 가중치 합
        return (min_dist * 3) + (remain_dist * 2)
```
<br/>

요약
- 대각선 우선 원칙: (1, 1) 이동 시 직선+직선 비용은 4인데 반해 대각선 비용은 3이므로, 대각선을 최대한 많이 사용하는 것이 유리합니다.
- 대각선 횟수 산출: 가로/세로 거리 중 더 짧은 쪽(min(dist_r, dist_c))만큼 대각선 이동이 가능합니다.
- 직선 횟수 산출: 대각선 이동 후 남은 거리(abs(dist_r - dist_c))는 직선으로 이동합니다.

<br/>

이 함수는 두 좌표 간의 **최소 가중치 경로** 비용을 계산합니다. 핵심 원리는 **"대각선 이동을 최대한 많이 활용하는 것"**입니다.

1.  **왜 대각선을 선호하는가?**:
    -   상하좌우 직선 이동의 비용은 **2**, 대각선 이동의 비용은 **3**입니다.
    -   목표 지점까지 `(1, 1)`만큼 이동해야 할 때,
        -   **직선 2번**: 오른쪽(2) + 아래(2) = **총 4**
        -   **대각선 1번**: 우하향 대각선(3) = **총 3**
    -   따라서 대각선 이동이 직선 2번보다 항상 저렴하므로 가능한 많이 사용하는 것이 이득입니다.

2.  **대각선 이동 횟수 (`min_dist`)**:
    -   대각선으로 한 번 움직이면 가로(`dist_c`)와 세로(`dist_r`) 거리가 동시에 1씩 줄어듭니다.
    -   따라서 두 거리 중 **더 작은 값(`min(dist_r, dist_c)`)**만큼 대각선 이동을 할 수 있습니다.

3.  **직선 이동 횟수 (`remain_dist`)**:
    -   대각선 이동을 최대한 하고 나면, 가로 또는 세로 중 한 방향의 거리만 남게 됩니다.
    -   남은 거리는 두 거리의 차이(`abs(dist_r - dist_c)`)와 같으며, 이 구간은 어쩔 수 없이 직선으로 이동해야 합니다.




### 비용 테이블 미리 계산 (Pre-calculation)

```python
    # 비용 테이블 미리 계산 (Pre-calculation)
    costs = [[0] * 10 for _ in range(10)]
    for i in range(10):
        for j in range(10):
            costs[i][j] = get_cost(str(i), str(j))
```

이 부분은 **성능 최적화**를 위해 모든 숫자 쌍 간의 이동 비용을 미리 구해두는 과정입니다.

-   **목적**: `solution` 함수 내부의 반복문(`numbers` 길이만큼 수행)에서 매번 `get_cost` 함수를 호출하여 좌표를 찾고 계산하는 오버헤드를 줄이기 위함입니다.
-   **방법**: 0부터 9까지 모든 숫자 조합(10x10 = 100가지)에 대해 비용을 계산하여 2차원 리스트 `costs`에 저장합니다.
-   **활용**: 이후 로직에서는 `costs[start][end]`와 같이 인덱스로 접근하여 **O(1)** 시간 복잡도로 즉시 비용을 가져올 수 있습니다.

### DP 수행 (딕셔너리를 이용한 최적화)

```python
    # 현재 단계의 가능한 상태들: { (left_pos, right_pos): cost }
    current_states = { ('4', '6'): 0 }
    
    for num in numbers:
        next_states = {}
        for (left, right), cost in current_states.items():
            # ... (이동 및 비용 계산)
```

이 부분은 **핵심 DP 로직**으로, 메모리 사용량을 최소화하며 최적해를 찾아가는 과정입니다.

1.  **공간 최적화 (Sliding Window)**:
    -   `numbers`의 길이가 최대 100,000이므로, `dp[100000][10][10]` 크기의 3차원 배열을 만들면 메모리가 많이 소모됩니다.
    -   하지만 현재 숫자를 누를 때는 **"바로 직전 상태"**만 알면 충분합니다.
    -   따라서 `current_states`(현재 단계)와 `next_states`(다음 단계) 두 개의 딕셔너리만 사용하여 메모리를 **O(1)**(상수 크기)로 유지합니다.

2.  **상태 관리 (`(left, right): cost`)**:
    -   딕셔너리의 키는 `(왼손 위치, 오른손 위치)` 튜플이고, 값은 해당 상태까지의 **최소 누적 비용**입니다.
    -   중복된 손가락 위치 상태가 발생하면, 더 작은 비용으로 갱신(`min`)하여 최적해만 남깁니다.

3.  **제약 조건 확인 (`target != right`, `target != left`)**:
    -   **왼손 이동 시**: 목표 숫자(`target`)에 이미 오른손(`right`)이 있으면 안 됩니다.
    -   **오른손 이동 시**: 목표 숫자(`target`)에 이미 왼손(`left`)이 있으면 안 됩니다.
    -   이 조건을 통해 "두 손가락이 같은 위치에 있을 수 없다"는 규칙을 준수합니다.

4.  **최종 결과**:
    -   모든 숫자를 누른 후(`for`문 종료), `current_states`에 남아있는 모든 경우의 수 중 가장 작은 비용(`min(current_states.values())`)이 정답이 됩니다.
