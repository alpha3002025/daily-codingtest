# 에어컨 (Level 3)

## 문제 설명
프로그래머스 "에어컨" 문제는 **동적계획법(Dynamic Programming, DP)**을 사용하여 해결해야 하는 최적화 문제입니다.
실외 온도와 희망 쾌적 온도가 주어졌을 때, 에어컨을 효율적으로 가동하여 승객이 탑승 중인 시간 동안 실내 온도를 쾌적 범위(`t1` ~ `t2`) 내로 유지하면서 **전력 소비를 최소화**해야 합니다.

### 핵심 개념
1.  **상태 정의 (State)**: `dp[전시 시간][현재 온도]`
    -   시간의 흐름에 따라 온도가 변하므로, **(시간, 온도)**의 2차원 상태 공간을 탐색해야 합니다.
2.  **전이 (Transition)**:
    -   **에어컨 OFF**: 실내 온도가 실외 온도를 향해 1도 변하거나(차이가 있을 때), 유지됩니다(같을 때). 비용: **0**.
    -   **에어컨 ON (온도 변경)**: 온도를 1도 높이거나 낮춥니다. 비용: **a**.
    -   **에어컨 ON (온도 유지)**: 현재 온도를 유지합니다. 비용: **b**.
3.  **제약 조건**: `onboard[i] == 1`인 시각에는 반드시 실내 온도가 `t1 ~ t2` 사이여야 합니다.

## 해결 방법
### 1. 온도 범위 정규화 (Offset)
문제에서 주어지는 온도는 **-10도 ~ 40도**입니다.
배열의 인덱스로 음수를 사용할 수 없으므로, 모든 온도에 **+10**을 더하여 **0 ~ 50** 범위로 변환하여 처리합니다.

### 2. 점화식 설계
`dp[i][j]` = `i`분일 때 실내 온도가 `j`도일 때의 최소 비용

다음 상태 `dp[i+1]`을 갱신하는 방식(Push DP) 또는 현재 상태 `dp[i]`를 이전 상태들로부터 계산하는 방식(Pull DP) 모두 가능합니다. 여기서는 직관적인 설명을 위해 현재 상태(`i`, `j`)에서 다음 상태로 전이하는 방식을 사용합니다.

-   **온도 상승**: `j -> j+1` (에어컨 켬: `+a` / 에어컨 끔(실외 > 실내): `0`)
-   **온도 하강**: `j -> j-1` (에어컨 켬: `+a` / 에어컨 끔(실외 < 실내): `0`)
-   **온도 유지**: `j -> j` (에어컨 켬: `+b` / 에어컨 끔(실외 == 실내): `0`)

### 3. 승객 탑승 처리
`onboard[i] == 1`인 경우, 유효하지 않은 온도 범위(`t1` 미만, `t2` 초과)의 DP 값은 `INF`로 처리하여 경로를 차단합니다.

## Python 풀이

```python
def solution(temperature, t1, t2, a, b, onboard):
    # 1. 온도 범위 보정 (-10 ~ 40 -> 0 ~ 50)
    # 인덱스 처리를 편하게 하기 위해 10을 더해줍니다.
    temperature += 10
    t1 += 10
    t2 += 10
    
    # DP 테이블 초기화
    # 최대 온도 범위: 0도 ~ 50도 (51개)
    # 시간 범위: len(onboard)
    MAX_TEMP = 51
    INF = float('inf')
    dp = [[INF] * MAX_TEMP for _ in range(len(onboard))]
    
    # 시작 상태 초기화 (0분, 실외 온도, 비용 0)
    dp[0][temperature] = 0
    
    # 시간 흐름에 따른 DP 수행
    for i in range(len(onboard) - 1):
        for j in range(MAX_TEMP):
            # 도달 불가능한 상태면 스킵
            if dp[i][j] == INF:
                continue
            
            # 다음 시간(i+1)으로의 전이
            
            # Case 1: 에어컨을 끄는 경우 (비용 0)
            # 실내 온도가 실외 온도 방향으로 1도 변하거나 같으면 유지됨
            next_temp = j
            if j < temperature:
                next_temp = j + 1
            elif j > temperature:
                next_temp = j - 1
            # (j == temperature인 경우 next_temp = j 그대로 유지)
            
            dp[i+1][next_temp] = min(dp[i+1][next_temp], dp[i][j])
            
            # Case 2: 에어컨을 켜서 온도 변경 (비용 a)
            # 온도 상승
            if j + 1 < MAX_TEMP:
                dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j] + a)
            # 온도 하강
            if j - 1 >= 0:
                dp[i+1][j-1] = min(dp[i+1][j-1], dp[i][j] + a)
                
            # Case 3: 에어컨을 켜서 온도 유지 (비용 b)
            # (실외 온도와 달라서 에어컨을 켜야만 유지되는 경우를 포함하여 min 처리)
            dp[i+1][j] = min(dp[i+1][j], dp[i][j] + b)

        # 승객 탑승 시 제약 조건 확인 (i+1 시간에 탑승)
        # 쾌적 온도(t1 ~ t2) 범위를 벗어나면 INF 처리하여 해당 경로 무효화
        if onboard[i+1] == 1:
            for j in range(MAX_TEMP):
                if not (t1 <= j <= t2):
                    dp[i+1][j] = INF
                    
    # 결과: 마지막 시간(len(onboard)-1)에 가능한 모든 온도 중 최소 비용 반환
    return min(dp[len(onboard) - 1])
```

## 복잡도 분석
-   **시간 복잡도**: `O(N * K)`
    -   `N`: `onboard`의 길이 (최대 1,000)
    -   `K`: 온도 범위 (51)
    -   각 시간마다 51개의 온도 상태를 갱신하므로 연산량이 매우 적어 효율적입니다.
-   **공간 복잡도**: `O(N * K)`
    -   `dp` 테이블의 크기입니다. (최적화 시 `O(K)`로 줄일 수 있습니다.)


## 코드 설명
### 온도 보정 및 초기화
```python
    # 1. 온도 범위 보정 (-10 ~ 40 -> 0 ~ 50)
    # 인덱스 처리를 편하게 하기 위해 10을 더해줍니다.
    temperature += 10
    t1 += 10
    t2 += 10
    
    # DP 테이블 초기화
    # 최대 온도 범위: 0도 ~ 50도 (51개)
    # 시간 범위: len(onboard)
    MAX_TEMP = 51
    INF = float('inf')
    dp = [[INF] * MAX_TEMP for _ in range(len(onboard))]
    
    # 시작 상태 초기화 (0분, 실외 온도, 비용 0)
    dp[0][temperature] = 0
```
이 부분은 문제 해결을 위한 **전처리(Preprocessing) 및 초기화** 단계입니다.

-   **온도 오프셋 (`+10`)**:
    -   문제에서 주어지는 온도의 범위는 `-10`도부터 `40`도입니다.
    -   파이썬 리스트(배열)의 인덱스는 **0 이상**이어야 하므로, 음수 온도를 처리하기 위해 모든 온도 값에 `10`을 더해줍니다.
    -   이로써 온도의 범위는 `0` ~ `50`이 되며, 리스트의 인덱스로 직접 사용할 수 있게 됩니다.
-   **DP 테이블 생성**:
    -   `MAX_TEMP = 51`: 0도부터 50도까지 총 51개의 온도 상태를 표현합니다.
    -   `dp` 배열을 `INF`(무한대)로 초기화하는 이유는 **최소 비용**을 구하는 문제이기 때문입니다. 아직 계산되지 않거나 도달할 수 없는 상태는 무한대로 두어 `min()` 연산 시 배제되도록 합니다.
-   **시작 상태 (`Base Case`)**:
    -   `0`분일 때의 실내 온도는 문제 조건에 따라 **실외 온도(`temperature`)**와 같습니다.
    -   이때의 비용은 `0`이므로 `dp[0][temperature] = 0`으로 설정하여 DP 탐색을 시작합니다.


<br/>
<br/>

### 시간과 온도 순회 (i, j)
```python
    # 시간 흐름에 따른 DP 수행
    for i in range(len(onboard) - 1):
        for j in range(MAX_TEMP):
```
이 이중 반복문은 **(시간, 온도)**의 모든 가능한 상태 공간을 탐색하는 역할을 합니다.

-   **`i` (시간)**: 현재 시각(분)을 의미합니다.
    -   `0`분부터 시작하여 `마지막 시간 - 1`분까지 순회합니다.
    -   `i` 시점의 상태(`dp[i]`)를 기준으로 **다음 시각 `i+1`**의 상태(`dp[i+1]`)를 계산하는 **전방 탐색(Push DP)** 방식을 사용하기 때문입니다.
-   **`j` (온도)**: 현재의 실내 온도를 의미합니다.
    -   `0`도부터 `50`도(`MAX_TEMP`)까지 가능한 모든 온도 상태를 확인합니다.
    -   오프셋이 적용된 값이므로 실제 온도는 `j - 10`도입니다.

### Case 1: 에어컨을 끄는 경우 (비용 0)

```python
            # Case 1: 에어컨을 끄는 경우 (비용 0)
            # 실내 온도가 실외 온도 방향으로 1도 변하거나 같으면 유지됨
            next_temp = j
            if j < temperature:
                next_temp = j + 1
            elif j > temperature:
                next_temp = j - 1
            # (j == temperature인 경우 next_temp = j 그대로 유지)
            
            dp[i+1][next_temp] = min(dp[i+1][next_temp], dp[i][j])
```
에어컨을 껐을 때의 온도 변화를 시뮬레이션하는 로직입니다. 중요한 점은 **비용이 0**이라는 것입니다.

-   **온도 변화 원리**: 에어컨을 끄면 실내 온도는 자연스럽게 **실외 온도(`temperature`)와 가까워지는 방향**으로 1도씩 변합니다.
    -   실외가 더 더우면 (`j < temperature`) -> 실내 온도 **+1도** (`j + 1`)
    -   실외가 더 추우면 (`j > temperature`) -> 실내 온도 **-1도** (`j - 1`)
    -   이미 같다면 (`j == temperature`) -> **변화 없음** (`j`)
-   **최소 비용 갱신**: 계산된 다음 온도(`next_temp`) 상태에 대하여, 현재 비용(`dp[i][j]`)을 그대로 가져가며(추가 비용 0), 기존 값과 비교해 더 작은 값으로 갱신합니다.

### Case 2: 에어컨을 켜서 온도 변경 (비용 a)

```python
            # Case 2: 에어컨을 켜서 온도 변경 (비용 a)
            # 온도 상승
            if j + 1 < MAX_TEMP:
                dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j] + a)
            # 온도 하강
            if j - 1 >= 0:
                dp[i+1][j-1] = min(dp[i+1][j-1], dp[i][j] + a)
```
에어컨을 가동하여 **온도를 강제로 변경**하는 경우입니다.

-   **비용 발생**: 에어컨을 사용하여 온도를 `1도` 변화시킬 때마다 전력 소비량 `a`가 추가됩니다.
-   **두 가지 방향성**:
    1.  **온도 상승 (+1도)**: 현재 온도 `j`에서 `j+1`로 증가시킵니다. (`j+1`이 범위 내에 있을 때)
    2.  **온도 하강 (-1도)**: 현재 온도 `j`에서 `j-1`로 감소시킵니다. (`j-1`이 범위 내에 있을 때)
-   **실외 온도와의 관계 무관**: 이 케이스는 에어컨의 힘으로 온도를 바꾸는 것이므로, 실외 온도가 어떻든 간에 비용 `a`를 지불하고 원하는 방향으로 온도를 1도 바꿀 수 있음을 의미합니다.

### Case 3: 에어컨을 켜서 온도 유지 (비용 b)

```python
            # Case 3: 에어컨을 켜서 온도 유지 (비용 b)
            # (실외 온도와 달라서 에어컨을 켜야만 유지되는 경우를 포함하여 min 처리)
            dp[i+1][j] = min(dp[i+1][j], dp[i][j] + b)
```
에어컨을 가동하여 **현재 온도를 유지**하는 경우입니다.

-   **목적**: 실외 온도와 실내 온도가 다를 때, 에어컨을 끄면 자연적으로 온도가 변해버립니다. 이를 막고 현재 온도를 그대로 유지하고 싶을 때 사용합니다.
-   **비용**: 온도 유지 비용 `b`가 발생합니다.
-   **비교와 생존 (`min`)**:
    -   만약 실내온도 == 실외온도라면, **Case 1**에서 이미 비용 `0`으로 `dp[i+1][j]`가 갱신되어 있을 것입니다.
    -   이 경우 `min(0, b)`는 `0`이므로, 더 비싼 비용인 `b`는 선택되지 않습니다.
    -   반대로 실내외 온도가 다르다면 **Case 1**은 `j`가 아닌 `j+1`이나 `j-1`로 전이되므로, 현재 온도 `j`를 유지하는 방법은 이 경우(비용 `b`)가 유일할 수 있습니다.
    -   따라서 `min`을 통해 상황에 맞는 최적의 비용이 선택됩니다.

### 승객 탑승 시 제약 조건 확인

```python
        # 승객 탑승 시 제약 조건 확인 (i+1 시간에 탑승)
        # 쾌적 온도(t1 ~ t2) 범위를 벗어나면 INF 처리하여 해당 경로 무효화
        if onboard[i+1] == 1:
            for j in range(MAX_TEMP):
                if not (t1 <= j <= t2):
                    dp[i+1][j] = INF
```
문제의 핵심 제약 조건인 **"승객이 탑승 중일 때는 쾌적 온도를 유지해야 한다"**를 처리하는 부분입니다.

-   **시점 확인 (`i+1`)**: 현재 `i`분에서 전이를 마친 **다음 시각 `i+1`분**에 승객이 탑승하는지 확인합니다.
-   **조건 검증**: 만약 승객이 탑승한다면(`onboard[i+1] == 1`), 그 시각의 실내 온도는 반드시 `t1`과 `t2` 사이여야 합니다.
-   **가지치기 (Pruning)**:
    -   계산된 온도 `j`가 쾌적 범위(`t1 <= j <= t2`)를 벗어난다면?
    -   해당 상태(`dp[i+1][j]`)를 **무한대(`INF`)**로 강제 변경합니다.
    -   이렇게 하면 이후의 DP 단계에서 이 상태는 "불가능한 경로"로 취급되어, 다음 계산에 선택되지 않고 자연스럽게 소멸됩니다.
-   **유효성 보장**: 이 로직 덕분에 최종 결과(`min(dp[len-1])`)는 항상 승객이 있을 때 쾌적 온도를 만족했던 경로들 중에서만 도출됩니다.

### 결과 반환

```python
    # 결과: 마지막 시간(len(onboard)-1)에 가능한 모든 온도 중 최소 비용 반환
    return min(dp[len(onboard) - 1])
```
모든 시간(`0`분 ~ `마지막`분)에 대한 시뮬레이션이 끝난 후, 정답을 도출하는 단계입니다.

-   `dp[len(onboard) - 1]` 리스트는 **마지막 시각(종료 시점)**에 도달했을 때, 각 온도별로 필요한 **최소 누적 비용**들을 담고 있습니다.
-   마지막 시점의 온도가 몇 도이든 상관없이, 우리는 **가장 적은 비용**이 든 경우를 찾으면 됩니다.
-   따라서 해당 리스트의 값들 중 최솟값(`min()`)을 반환하면 정답이 됩니다.
-   (참고: 불가능한 경로는 이미 `INF`로 처리되어 있으므로, `min()` 연산에서 자연스럽게 제외됩니다.)
