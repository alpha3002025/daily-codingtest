# 단어 퍼즐 (Level 4)

## 문제 설명
프로그래머스 "단어 퍼즐" 문제는 주어진 단어 조각들(`strs`)을 조합하여 목표 문자열(`t`)을 완성할 때, 사용된 단어 조각의 최소 개수를 구하는 **동적계획법(Dynamic Programming, DP)** 문제입니다. 단어 조각은 무한히 사용할 수 있으며, 완성할 수 없는 경우 `-1`을 반환합니다.

### 핵심 개념
1.  **상태 정의**: `dp[i]`
    -   목표 문자열 `t`의 **인덱스 `i`까지**(길이 `i+1`)를 완성하는 데 필요한 **최소 단어 조각 수**입니다.
    -   예) `dp[5]`는 `t[0:5]` (앞에서부터 5글자)를 만드는 최소 비용.
2.  **전이 조건 (Transition)**:
    -   `dp[i]`를 구하기 위해, `i`번째 글자로 끝나는 단어 조각이 있는지 확인합니다.
    -   예를 들어, `t`의 마지막 3글자가 `str` 조각과 같다면, `dp[i] = dp[i-3] + 1`이 될 수 있습니다.
    -   단어 조각의 최대 길이는 5이므로, 현재 위치 `i`에서 **최대 5글자 전**까지만 과거(`i-1` ~ `i-5`)를 확인하면 됩니다.
3.  **최적화**:
    -   `t`의 길이는 최대 20,000으로 약간 길지만, 단어 조각의 길이는 최대 5로 매우 짧습니다.
    -   이 점을 이용해 `strs` 전체를 매번 순회하는 대신, 현재 위치에서 끝나는 길이가 1~5인 부분 문자열이 `strs`에 존재하는지 확인하는 방식이 효율적입니다.
    -   빠른 검색을 위해 `strs`를 **집합(Set)** 자료구조로 변환하여 조회 속도를 `O(1)`로 만듭니다.

## 해결 방법
### 1. `strs`를 Set으로 변환
단어 검색 시간을 단축하기 위해 `strs` 리스트를 `set`인 `word_set`으로 변환합니다.

### 2. DP 테이블 초기화
-   크기: `len(t)` (또는 편의상 `len(t) + 1`)
-   초기값: `INF` (무한대). 아직 도달하지 못한 위치임을 표시합니다.

### 3. DP 수행
`i`를 `0`부터 `len(t) - 1`까지 순회하며 `dp[i]`를 채웁니다.
각 위치 `i`에서, 길이 `k` (1~5)인 단어 조각을 떼어냈을 때 그 조각이 `word_set`에 있는지 확인합니다.
-   **검사**: `t[i-k+1 : i+1]` (끝이 `i`인 길이 `k` 문자열)
-   **조건**: 해당 조각이 set에 있고, 그 조각을 붙이기 전 상태(`dp[i-k]`)가 유효하다면(`!= INF`)
-   **갱신**: `dp[i] = min(dp[i], dp[i-k] + 1)`

(인덱스를 1-based로 생각하면 `dp[i]`는 길이 `i`를 만드는 비용으로 정의하는 편이 구현이 더 직관적일 수 있습니다.)

## Python 풀이

```python
def solution(strs, t):
    # strs의 단어들을 빠른 조회를 위해 set으로 변환
    word_set = set(strs)
    n = len(t)
    # dp[i]: t의 0~i-1번째 인덱스(길이 i)까지 만드는 데 필요한 최소 조각 수
    # dp[0]은 길이 0(빈 문자열)을 의미하며 0개 필요
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    
    # 1부터 t의 길이 n까지 순회
    for i in range(1, n + 1):
        # 마지막 조각의 길이 k (1~5)
        # 단어 조각은 길이가 최대 5라고 문제 조건에 명시됨
        # i-k가 음수가 되면 안 되므로 range 범위 조절 필요하지만
        # 슬라이싱은 범위를 벗어나도 에러가 안 나고 빈 문자열 등을 반환하므로 
        # k는 1~5를 돌되, i-k >= 0 조건을 체크하는 것이 안전
        for k in range(1, 6):
            if i - k < 0:
                # 더 이상 뒤로 갈 수 없으면 종료 (k가 커질수록 더 뒤를 보므로)
                break
            
            # t의 끝부분(길이 k) 문자열 추출
            # t는 0-based 인덱스이므로
            # 길이 i까지의 부분문자열은 t[:i]이고, 
            # 거기서 뒤의 k개를 자르면 t[i-k : i]가 됨
            sub = t[i-k : i]
            
            if sub in word_set:
                # 이전 상태(dp[i-k])가 유효하다면(만들 수 있는 상태라면)
                if dp[i-k] != float('inf'):
                    dp[i] = min(dp[i], dp[i-k] + 1)
                    
    # 만들 수 없는 경우(여전히 INF) -1 반환
    if dp[n] == float('inf'):
        return -1
        
    return dp[n]
```

## 복잡도 분석
-   **시간 복잡도**: `O(N * M)` (`N`: `t`의 길이 20,000, `M`: 단어 조각 최대 길이 5)
    -   각 위치 `i`마다 최대 5번의 반복문을 돌며 문자열 슬라이싱 및 Set 조회를 수행합니다.
    -   `20,000 * 5` = `100,000` 번의 연산으로 충분히 빠릅니다.
-   **공간 복잡도**: `O(N)`
    -   `dp` 배열의 크기는 `N`에 비례합니다.

## 코드 설명


### 초기화 및 전처리

```python
    word_set = set(strs)
    n = len(t)
    # dp[i]: t의 0~i-1번째 인덱스(길이 i)까지 만드는 데 필요한 최소 조각 수
    # dp[0]은 길이 0(빈 문자열)을 의미하며 0개 필요
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
```

이 부분은 효율적인 알고리즘 수행을 위한 준비 단계입니다.

1.  **Set 변환 (`word_set`)**:
    -   `strs` 리스트에 담긴 단어 조각들은 리스트 형태이므로 검색 시 `O(M)`(M은 리스트 크기)의 시간이 소요될 수 있습니다.
    -   이를 **Hash Set**으로 변환하면 평균 **O(1)**의 시간 복잡도로 특정 단어가 존재하는지 빠르게 확인할 수 있습니다.
2.  **DP 테이블 초기화**:
    -   `dp` 배열의 크기를 `n + 1`로 설정하여, 인덱스 `i`가 곧 **"만들고자 하는 부분 문자열의 길이"**를 의미하도록 직관적으로 설계했습니다.
    -   모든 값을 `INF`(무한대)로 초기화하여 아직 도달하지 못했음을 표시합니다.
3.  **Base Case**:
    -   `dp[0] = 0`: **길이가 0인 문자열(빈 문자열)**을 만드는 데 필요한 단어 조각 수는 **0개**입니다. 이 값이 DP의 출발점이 됩니다.

### DP 반복문 및 최적화

```python
    # 1부터 t의 길이 n까지 순회
    for i in range(1, n + 1):
        # 마지막 조각의 길이 k (1~5)
        # ...
        for k in range(1, 6):
```

이 부분은 문제 해결의 **핵심 로직이자 최적화 포인트**입니다.

1.  **메인 루프 (`i`)**: 
    -   목표 단어 `t`를 앞에서부터 **한 글자씩 늘려가며(`1`부터 `n`까지)** 완성 비용을 계산합니다. 작은 부분 문제들을 해결하여 최종적으로 전체 문제를 해결하는 바텀업(Bottom-Up) 방식입니다.
2.  **내부 루프 (`k`)**: 
    -   현재 위치 `i`에서 **끝나는 마지막 단어 조각**의 길이를 가정합니다.
    -   일반적인 DP라면 모든 가능한 이전 위치를 탐색해야겠지만, 문제 조건에서 **"단어 조각의 최대 길이는 5"**라고 명시되어 있습니다.
    -   따라서 `k`를 `1`부터 `5`까지만 반복하면 되므로, 내부 루프 횟수가 획기적으로 줄어들어 `O(N * 5)` 즉, `O(N)`의 선형 시간 복잡도로 해결이 가능합니다.

### 부분 문자열 확인 및 상태 갱신 (점화식)

```python
            if i - k < 0:
                break
            
            sub = t[i-k : i]
            
            if sub in word_set:
                if dp[i-k] != float('inf'):
                    dp[i] = min(dp[i], dp[i-k] + 1)
```

이 코드는 실제 점화식 `dp[i] = min(dp[i], dp[i-k] + 1)`을 수행하는 과정입니다.

1.  **범위 체크**:
    -   `i - k < 0`: 확인하려는 길이가 현재까지 만든 문자열 길이보다 길다면 검사가 불가능하므로 중단합니다.
2.  **부분 문자열 추출 (`sub`)**:
    -   현재 위치 `i`를 끝으로 하는 길이 `k`짜리 단어(`t[i-k : i]`)를 잘라냅니다. 이것이 우리가 찾고 있는 "마지막 퍼즐 조각" 후보입니다.
3.  **유효성 검증 및 갱신**:
    -   **조건 1**: 잘라낸 조각 `sub`가 `word_set`에 존재해야 합니다. (유효한 퍼즐 조각인가?)
    -   **조건 2**: 그 조각을 제외한 나머지 앞부분(`dp[i-k]`)이 완성 가능한 상태여야 합니다. (`INF`가 아니어야 함)
    -   두 조건이 만족되면, **이전 단계의 최소 비용 + 1**로 현재 비용을 갱신합니다. `min()`을 사용하는 이유는 길이 `1~5`의 다양한 조각 중 가장 효율적인 방법을 선택하기 위함입니다.
