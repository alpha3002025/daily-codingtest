# 카운트 다운 (Level 3)

## 문제 설명
프로그래머스 "카운트 다운" 문제는 다트 게임을 소재로 한 동적계획법(Dynamic Programming) 문제입니다.
목표 점수 `target`을 0으로 만드는 데 필요한 최소한의 다트 던지기 횟수와, 그 상황에서 "싱글(Single)" 또는 "불(Bull)"을 최대한 많이 맞힌 횟수를 구해야 합니다.

### 점수 체계
- **싱글 (Single)**: 1 ~ 20점 (보너스 카운트 +1)
- **더블 (Double)**: 2 * (1 ~ 20)점 (보너스 카운트 0)
- **트리플 (Triple)**: 3 * (1 ~ 20)점 (보너스 카운트 0)
- **불 (Bull)**: 50점 (보너스 카운트 +1)

### 우선순위
1. **던진 다트 수 최소화**
2. **("싱글" + "불") 횟수 최대화**

## 해결 방법: 동적계획법 (DP)

목표 점수 `target`이 최대 100,000이므로, O(target)의 시간 복잡도를 가진 DP로 해결할 수 있습니다.

### 점화식 정의
`dp[i]`를 점수 `i`를 만드는 최적의 해 `[던진 횟수, 싱글/불 횟수]`라고 정의합니다.
- 초기 상태: `dp[0] = [0, 0]`
- 목표: `dp[target]` 구하기

점수 `i`에 도달하기 위해, 마지막에 던진 점수를 `p`라고 하면:
`dp[i] = min_condition(dp[i - p] + cost(p))`
여기서 `cost(p)`는 `[1, 1]` (싱글/불인 경우) 또는 `[1, 0]` (그 외)입니다.

단, 비교 연산은 다음과 같이 정의됩니다:
- 던진 횟수가 더 작은 것이 우선.
- 던진 횟수가 같다면, 싱글/불 횟수가 더 큰 것이 우선.

### 구현 상세
한 번에 얻을 수 있는 점수들을 미리 정의해두고, `target`까지 바텀업(Bottom-Up) 방식으로 테이블을 채웁니다.
유효한 점수는 1~20(싱글), 2~40(더블), 3~60(트리플), 50(불) 입니다.
동일한 점수라도 '싱글/불'로 얻을 수 있다면 가산점을 얻으므로, 각 점수별로 얻을 수 있는 최대 보너스를 미리 전처리(Pre-calculation)하여 사용합니다.

## Python 풀이

```python
def solution(target):
    # 각 점수를 얻을 때의 최대 보너스 (싱글/불: 1, 그외: 0) 저장
    # best_moves[score] = bonus
    best_moves = {}
    
    # 1. 더블, 트리플 (보너스 0)
    for i in range(1, 21):
        for mult in [2, 3]:
            score = i * mult
            if score not in best_moves:
                best_moves[score] = 0
                
    # 2. 싱글 (보너스 1) - 덮어쓰기 (우선순위 높음)
    for i in range(1, 21):
        best_moves[i] = 1
        
    # 3. 불 (보너스 1)
    best_moves[50] = 1
    
    # DP 테이블 초기화
    # dp[i] = [던진 횟수, 싱글/불 횟수]
    # 초기값: 던진 횟수 무한대
    dp = [[float('inf'), 0] for _ in range(target + 1)]
    dp[0] = [0, 0]
    
    # DP 수행
    # 1부터 target까지 순회
    for i in range(1, target + 1):
        # 가능한 모든 던지기 점수에 대해
        for score, bonus in best_moves.items():
            if i >= score:
                prev_darts, prev_bonus = dp[i - score]
                
                # 라운드 갱신
                new_darts = prev_darts + 1
                new_bonus = prev_bonus + bonus
                
                # 최적해 갱신 조건
                # 1. 횟수가 더 적으면 갱신
                # 2. 횟수가 같으면 보너스가 더 많으면 갱신
                if new_darts < dp[i][0] or (new_darts == dp[i][0] and new_bonus > dp[i][1]):
                    dp[i] = [new_darts, new_bonus]
                    
    return dp[target]
```

## 복잡도 분석
- **시간 복잡도**: O(Target * K). `target`은 최대 100,000이고, `K`는 한 번에 낼 수 있는 점수의 종류(유니크한 점수 약 40~50개)입니다.
- **공반 복잡도**: O(Target). `dp` 배열의 크기입니다.

## 코드 설명
### 더블,트리플 계산
```python
        # 1. 더블, 트리플 (보너스 0)
    for i in range(1, 21):
        for mult in [2, 3]:
            score = i * mult
            if score not in best_moves:
                best_moves[score] = 0
```
이 코드는 **더블(Double)**과 **트리플(Triple)** 영역을 맞췄을 때의 점수를 미리 계산하여 `best_moves` 딕셔너리에 등록하는 초기화 단계입니다.

- **점수 계산**: 1~20점의 2배(더블), 3배(트리플)에 해당하는 점수들을 계산합니다.
- **보너스 0점 부여**: 문제 조건상 싱글이나 불을 맞혔을 때만 카운트가 올라가므로, 더블/트리플은 보너스 점수(싱글/불 횟수)를 `0`으로 설정합니다.
- **우선순위 처리**: 이 코드가 **먼저 실행**되고 이후에 싱글 점수(보너스 1)를 등록합니다. 따라서 `20`점처럼 더블(`10*2`)로도 가능하고 싱글(`20*1`)로도 가능한 점수는, 나중에 등록되는 싱글의 보너스 점수(`1`)가 최종적으로 저장되어 유리한 쪽으로 선택하게 됩니다.

<br/>
<br/>


### 싱글, 불 계산
```python
    # 2. 싱글 (보너스 1) - 덮어쓰기 (우선순위 높음)
    for i in range(1, 21):
        best_moves[i] = 1
        
    # 3. 불 (보너스 1)
    best_moves[50] = 1
```
이 부분은 **싱글(Single)**과 **불(Bull)** 점수를 등록하는 과정입니다.

- **보너스 1점 부여**: 문제의 목표 2순위인 "싱글/불 횟수 최대화"를 위해, 싱글(1~20)과 불(50)을 맞혔을 때 보너스 점수 `1`을 부여합니다.
- **덮어쓰기 (Overwriting)**:
    - 앞서 더블/트리플 계산에서 이미 등록된 점수가 있더라도, 여기서 다시 값을 할당합니다.
    - 예: `20`점은 `더블 10`으로 `best_moves[20] = 0`이 되어있었지만, `싱글 20`이 가능하므로 `best_moves[20] = 1`로 덮어씌워집니다.
    - 이를 통해 동일한 점수를 낼 수 있다면 항상 **보너스를 얻는(싱글/불)** 방법을 선택하도록 보장합니다.


<br/>
<br/>


### DP 테이블 초기화

```python
    # DP 테이블 초기화
    # dp[i] = [던진 횟수, 싱글/불 횟수]
    # 초기값: 던진 횟수 무한대
    dp = [[float('inf'), 0] for _ in range(target + 1)]
    dp[0] = [0, 0]
```

이 부분은 **동적계획법(DP)**을 수행하기 위한 테이블을 생성하고 초기값을 설정하는 단계입니다.

- **테이블 크기**: `target + 1` 크기로 생성하여 인덱스가 곧 점수가 되도록 합니다. (0점 ~ target점)
- **초기값 설정 (`float('inf')`)**:
    - 최소 횟수를 구하는 문제이므로, 아직 도달하지 못한 점수들의 던진 횟수는 **무한대**로 초기화합니다.
    - 이렇게 해야 나중에 `min()` 비교 시, 실제로 계산된 값들이 선택될 수 있습니다.
- **기저 사례 (Base Case)**:
    - `dp[0] = [0, 0]`: **0점**을 만들기 위해 필요한 다트 횟수는 **0번**, 보너스 횟수도 **0번**입니다. 이 값이 DP의 출발점이 됩니다.


### DP 수행 (핵심 로직)

```python
    # DP 수행
    # 1부터 target까지 순회
    for i in range(1, target + 1):
        # 가능한 모든 던지기 점수에 대해
        for score, bonus in best_moves.items():
            if i >= score:
                prev_darts, prev_bonus = dp[i - score]
                
                # 라운드 갱신
                new_darts = prev_darts + 1
                new_bonus = prev_bonus + bonus
                
                # 최적해 갱신 조건
                if new_darts < dp[i][0] or (new_darts == dp[i][0] and new_bonus > dp[i][1]):
                    dp[i] = [new_darts, new_bonus]
```

이 코드는 실제 점수를 채워나가는 바텀업(Bottom-Up) DP 과정입니다.

1.  **순회 (`for i in range...`)**:
    - 1점부터 목표 점수 `target`까지 순차적으로 최적해를 구해 나갑니다.
    - 작은 점수의 해가 확정되어 있어야 큰 점수의 해를 구할 수 있기 때문입니다.

2.  **점수 조합 시도 (`for score, bonus ...`)**:
    - 현재 점수 `i`를 만들기 위해, 마지막으로 던진 다트가 무엇인지 모든 경우의 수(`best_moves`)를 대입해봅니다.
    - `i - score`는 **"마지막 다트를 던지기 직전의 점수"**를 의미합니다.

3.  **최적해 갱신 조건 (`if ...`)**:
    - 문제에서 제시한 우선순위를 그대로 코드에 옮긴 부분입니다.
    - **조건 1**: 던진 횟수(`new_darts`)가 기존(`dp[i][0]`)보다 **적으면** 무조건 갱신합니다.
    - **조건 2**: 던진 횟수가 **같다면**, 싱글/불 보너스(`new_bonus`)가 더 **많은** 경우 갱신합니다.
