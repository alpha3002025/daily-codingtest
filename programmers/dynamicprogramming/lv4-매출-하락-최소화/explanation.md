# 매출 하락 최소화 (Level 4, 2021 KAKAO BLIND RECRUITMENT)

## 문제 설명
프로그래머스 "매출 하락 최소화" 문제는 회사 조직도(트리 구조)에서 모든 팀이 최소 1명 이상의 직원을 워크숍에 보내되, 참석한 직원들의 매출액 합계가 최소가 되도록 하는 **트리 DP(Tree DP)** 문제입니다.

### 핵심 개념
1.  **트리 구조**:
    -   회사의 조직도는 트리 형태이며, 루트 노드(1번, CEO)부터 시작됩니다.
    -   모든 팀은 팀장 한 명과 여러 팀원으로 구성됩니다.
2.  **팀의 조건**:
    -   각 팀장은 자신의 팀원 중 적어도 한 명(자신 포함)이 워크숍에 참석해야 한다는 책임을 가집니다.
    -   즉, **(팀장, 팀원들) 그룹 내에서 최소 1명은 참석**해야 합니다.
3.  **트리 DP 상태 정의**:
    -   각 노드(직원) `u`에 대해 두 가지 상태를 정의합니다.
    -   `dp[u][0]`: `u`가 워크숍에 **참석하지 않았을 때**, `u`를 루트로 하는 서브트리의 최소 비용.
    -   `dp[u][1]`: `u`가 워크숍에 **참석했을 때**, `u`를 루트로 하는 서브트리의 최소 비용.

## 해결 방법
### 1. 트리 구성
주어진 `links` 정보를 이용하여 인접 리스트 형태(`tree`)로 트리를 구성합니다.

### 2. 점화식 (DFS 탐색)
자식 노드들을 `v1, v2, ..., vk`라고 할 때, 부모 노드 `u`의 DP 값은 다음과 같이 계산합니다.

-   **Case 1: `u`가 참석하는 경우 (`dp[u][1]`)**
    -   `u`가 이미 참석했으므로, `u`가 팀장인 팀의 조건은 충족되었습니다.
    -   따라서 자식 노드들(`v`)은 참석 여부와 상관없이 **각각의 최소 비용**을 선택하면 됩니다.
    -   `dp[u][1] = sales[u] + sum(min(dp[v][0], dp[v][1]) for v in children)`

-   **Case 2: `u`가 참석하지 않는 경우 (`dp[u][0]`)**
    -   `u`가 불참하므로, `u`가 팀장인 팀에서는 **적어도 한 명의 자식 노드가 참석**해야 합니다.
    -   기본적으로 자식들도 최소 비용(`min(dp[v][0], dp[v][1])`)을 선택하고 싶겠지만, 만약 모든 자식들이 '불참'하는 것이 이득이라서 모두 불참을 선택해버린다면? -> **팀 조건 위배**.
    -   따라서 **"자식 중 최소 한 명은 참석"**하도록 강제해야 합니다.
    -   **계산 로직**:
        1.  일단 모든 자식에 대해 `min(dp[v][0], dp[v][1])`을 더합니다 (`sum_min_cost`).
        2.  만약 이 선택 과정에서 **적어도 하나의 자식이 참석(`dp[v][1]` 선택)**했다면, 추가 조치 없이 `sum_min_cost`가 답입니다.
        3.  만약 **모든 자식이 불참(`dp[v][0]` 선택)**했다면, 그중에서 "비용 증가가 가장 적은" 자식 하나를 억지로 참석시켜야 합니다.
        4.  비용 증가량: `diff = dp[v][1] - dp[v][0]`
        5.  `sum_min_cost + min(diff)`가 최종 비용이 됩니다.

## Python 풀이

```python
import sys

# 재귀 깊이 제한 해제 (트리 깊이가 깊을 수 있음)
sys.setrecursionlimit(300000)

def solution(sales, links):
    n = len(sales)
    # 트리 구성 (인접 리스트)
    tree = [[] for _ in range(n + 1)]
    for u, v in links:
        tree[u].append(v)
        
    # dp[u][0]: u가 불참할 때 서브트리 최소 비용
    # dp[u][1]: u가 참석할 때 서브트리 최소 비용
    dp = [[0, 0] for _ in range(n + 1)]
    
    def dfs(u):
        visited_at_least_one = False  # 자식 중 한 명이라도 참석했는지 여부
        min_diff = float('inf')       # 강제로 참석시킬 때의 최소 추가 비용
        sum_child_cost = 0            # 자식들의 최소 비용 합
        
        # 리프 노드 처리 (자식이 없는 경우)
        if not tree[u]:
            dp[u][0] = 0           # 불참: 비용 0
            dp[u][1] = sales[u-1]  # 참석: 본인 매출액 (sales는 0-indexed)
            return

        for v in tree[u]:
            dfs(v)
            
            # 자식 v에 대해 더 작은 비용을 선택 (기본 전략)
            cost_v = min(dp[v][0], dp[v][1])
            sum_child_cost += cost_v
            
            # 만약 자식이 참석하는 비용이 선택되었다면(같아도 참석으로 간주 가능하지만, 확실히 더 작아서 선택된 경우)
            # 엄밀히는: dp[v][1] <= dp[v][0] 인 경우를 카운트해도 됨
            
            # 강제 참석을 위한 차이값 계산 (참석 - 불참)
            # 이 값이 작을수록 불참->참석으로 바꿀 때 비용 손해가 적음
            diff = dp[v][1] - dp[v][0]
            min_diff = min(min_diff, diff)
            
            # 현재 선택된 비용이 '참석' 쪽이라면 기록
            if dp[v][1] < dp[v][0]:
                visited_at_least_one = True
        
        # Case 1: u가 참석함
        # 자식들의 선택과 무관하게 본인 비용 추가
        dp[u][1] = sales[u-1] + sum_child_cost
        
        # Case 2: u가 불참함
        # 자식 중 하나라도 참석해야 함
        if visited_at_least_one:
            # 이미 자식 중 누군가 참석했으므로 추가 비용 없음
            dp[u][0] = sum_child_cost
        else:
            # 아무도 참석 안 했다면, 가장 손해가 적은 한 명을 강제로 참석시킴
            # min_diff = (참석비용 - 불참비용)의 최솟값
            # sum_child_cost에는 이미 모든 자식의 '불참비용'이 더해져 있으므로
            # 여기에 (참석 - 불참)을 더하면 해당 자식은 '참석비용'을 더한 셈이 됨
            dp[u][0] = sum_child_cost + min_diff
            
    # 루트 노드(1번)부터 탐색 시작
    dfs(1)
    
    # 1번 팀(CEO 포함 팀)도 조건 만족해야 하므로,
    # CEO가 참석하거나(1), 불참하고 자식 중 누군가 참석하거나(0) 중 최솟값
    return min(dp[1][0], dp[1][1])

```

## 복잡도 분석
-   **시간 복잡도**: `O(N)`
    -   트리의 모든 노드를 한 번씩만 방문하는 DFS 탐색입니다.
    -   각 노드에서 자식 노드의 수만큼 반복하지만, 전체적으로 보면 모든 간선을 한 번씩 타는 것과 같으므로 `O(V+E)` -> `O(N)`입니다.
-   **공간 복잡도**: `O(N)`
    -   DP 테이블(`300,000 * 2`)과 재귀 스택 공간(`최대 N`)이 필요합니다.


## 코드 설명

### 트리 구성 및 DP 초기화

```python
    n = len(sales)
    # 트리 구성 (인접 리스트)
    tree = [[] for _ in range(n + 1)]
    for u, v in links:
        tree[u].append(v)
        
    # dp[u][0]: u가 불참할 때 서브트리 최소 비용
    # dp[u][1]: u가 참석할 때 서브트리 최소 비용
    dp = [[0, 0] for _ in range(n + 1)]
```

이 부분은 입력 데이터를 처리하여 알고리즘에 적합한 형태로 변환하는 전처리 단계입니다.

1.  **트리 구성 (`tree`)**:
    -   입력으로 주어지는 `links`는 부모-자식 관계의 간선 정보입니다.
    -   이를 효율적으로 탐색하기 위해 **인접 리스트(Adjacency List)** 형태로 변환합니다.
    -   직원 번호가 `1`번부터 시작하므로, 편의상 리스트 크기를 `n + 1`로 설정하여 인덱스를 그대로 직원 번호로 사용합니다.
2.  **DP 테이블 초기화 (`dp`)**:
    -   각 직원(노드)마다 두 가지 상태를 저장해야 하므로 `(n + 1) x 2` 크기의 2차원 배열을 생성합니다.
    -   `dp[u][0]`: `u`번 직원이 워크숍에 **참석하지 않았을 때**, 해당 서브트리의 최소 매출 감소액.
    -   `dp[u][1]`: `u`번 직원이 워크숍에 **참석했을 때**, 해당 서브트리의 최소 매출 감소액.


### DFS 내부 변수 정의

```python
        visited_at_least_one = False  # 자식 중 한 명이라도 참석했는지 여부
        min_diff = float('inf')       # 강제로 참석시킬 때의 최소 추가 비용
        sum_child_cost = 0            # 자식들의 최소 비용 합
```

이 변수들은 현재 노드 `u`가 **워크숍에 불참하는 경우(`dp[u][0]`)** 를 처리하기 위해 사용됩니다. 부모가 불참하면 자식 중 **최소 1명**은 반드시 참석해야 한다는 제약 조건 때문입니다.

1.  **`visited_at_least_one`**:
    -   자식 노드들의 최적해(`min(dp[v][0], dp[v][1])`)를 구하는 과정에서, 단 한 명이라도 **참석하는 쪽(`dp[v][1]`)**이 선택되었는지 체크합니다.
    -   만약 `True`라면, 이미 팀 내에서 누군가 참석했으므로 제약 조건이 자연스럽게 만족된 상태입니다.
2.  **`min_diff`**:
    -   만약 모든 자식이 **불참하는 쪽(`dp[v][0]`)**이 이득이라서 아무도 참석하지 않게 된다면, 우리는 손해를 감수하고서라도 **한 명을 강제로 참석**시켜야 합니다.
    -   이때 "불참 비용(`dp[v][0]`)" 대신 "참석 비용(`dp[v][1]`)"으로 바꿀 때 증가하는 비용(`dp[v][1] - dp[v][0]`)이 **가장 작은 값**을 저장해 둡니다.
3.  **`sum_child_cost`**:
    -   자식 노드들의 최적 비용의 단순 합계입니다. 나중에 `min_diff`를 더할 때 베이스가 됩니다.




### 리프 노드(Leaf Node) 처리

```python
        # 리프 노드 처리 (자식이 없는 경우)
        if not tree[u]:
            dp[u][0] = 0           # 불참: 비용 0
            dp[u][1] = sales[u-1]  # 참석: 본인 매출액 (sales는 0-indexed)
            return
```

이 부분은 재귀 함수 `dfs`의 **종료 조건(Base Case)**입니다. 더 이상 자식이 없는 말단 직원(리프 노드)에 도달했을 때 수행됩니다.

1.  **자식이 없는 경우**:
    -   `tree[u]`가 비어 있다면, `u`번 직원은 팀장이 아닙니다(팀원이 없음).
    -   따라서 "팀장이 포함된 팀에서 최소 1명이 참석해야 한다"는 제약 조건 중, 본인이 팀장으로서 책임져야 할 팀은 없습니다.
2.  **DP 값 설정**:
    -   `dp[u][0]` (불참): 자신이 속한 팀의 팀장이 알아서 해결할 문제이므로, 본인의 불참 비용은 **0**입니다.
    -   `dp[u][1]` (참석): 본인이 참석하면 **본인의 하루 매출액(`sales[u-1]`)**만큼 매출이 감소합니다. (비용 발생)




### 자식 노드 순회 및 강제 참석 로직

```python
        for v in tree[u]:
            dfs(v)
            sum_child_cost += min(dp[v][0], dp[v][1])
            
            diff = dp[v][1] - dp[v][0]
            min_diff = min(min_diff, diff)
            
            if dp[v][1] < dp[v][0]:
                visited_at_least_one = True
```

이 반복문은 현재 팀장(`u`)의 모든 팀원(`v`)을 검사하며 필요한 값을 누적 계산합니다.

1.  **기본 전략 (`sum_child_cost`)**:
    -   각 자식 `v`는 본인 입장에서 가장 이득인 경우(`min(참석, 불참)`)를 선택한다고 가정하고 비용을 더합니다.
    -   이 값은 `u`가 참석하는 경우(`dp[u][1]`)에는 그대로 사용됩니다. (팀장 `u`가 참석했으므로 자식은 자유롭게 선택 가능)
2.  **강제 참석 대비 (`min_diff`)**:
    -   만약 `u`가 불참하게 되면, 자식 중 최소 1명을 강제로 참석시켜야 할 수도 있습니다.
    -   이때 손해를 최소화하기 위해 `참석 비용 - 불참 비용`의 차이(`diff`)가 가장 작은 값을 미리 구해둡니다.
3.  **참석 여부 확인 (`visited_at_least_one`)**:
    -   만약 자식의 최적해가 "참석(`dp[v][1] < dp[v][0]`)"인 경우가 하나라도 있다면, 강제 참석 조치는 불필요합니다.
    -   이 플래그를 통해 나중에 `dp[u][0]` 계산 시 추가 비용을 더할지 말지 결정합니다.




### DP 점화식 계산 (Case 1 & Case 2)

```python
        # Case 1: u가 참석함
        dp[u][1] = sales[u-1] + sum_child_cost
        
        # Case 2: u가 불참함
        if visited_at_least_one:
            dp[u][0] = sum_child_cost
        else:
            dp[u][0] = sum_child_cost + min_diff
```

자식 노드 순회가 끝난 후, 최종적으로 `dp[u][1]`과 `dp[u][0]`을 결정하는 단계입니다.

1.  **Case 1: 본인이 참석하는 경우 (`dp[u][1]`)**
    -   본인이 팀장으로서 참석했으므로, **"팀 내 최소 1명 참석"** 조건은 이미 만족되었습니다.
    -   따라서 자식들은 참석/불참 중 본인에게 더 이득인 쪽을 자유롭게 선택한 값들의 합(`sum_child_cost`)에 본인의 매출액(`sales[u-1]`)만 더하면 됩니다.
2.  **Case 2: 본인이 불참하는 경우 (`dp[u][0]`)**
    -   본인이 불참하므로, **자식 중 최소 한 명**이 대신 참석해야 합니다.
    -   **상황 A (`visited_at_least_one` is True)**:
        -   이미 자식들 중 최소 비용 선택 과정에서 참석을 선택한 자식이 있습니다.
        -   별도의 조치 없이 `sum_child_cost` 그대로가 최소 비용이 됩니다.
    -   **상황 B (`visited_at_least_one` is False)**:
        -   모든 자식이 "불참"하는 것이 비용이 더 적어서 아무도 참석하지 않은 상태입니다.
        -   이 경우, 팀 조건을 만족시키기 위해 **가장 비용 증가가 적은(`min_diff`)** 자식 한 명을 골라 강제로 참석시킵니다.
        -   최종 비용 = `sum_child_cost + min_diff`





### 최종 결과 도출

```python
    # 루트 노드(1번)부터 탐색 시작
    dfs(1)
    
    # 1번 팀(CEO 포함 팀)도 조건 만족해야 하므로,
    # CEO가 참석하거나(1), 불참하고 자식 중 누군가 참석하거나(0) 중 최솟값
    return min(dp[1][0], dp[1][1])
```

알고리즘의 마지막 단계입니다.

1.  **DFS 탐색 시작**:
    -   회사의 최상위 책임자인 **CEO(1번 노드)**부터 DFS를 호출하여 재귀적으로 밑바닥(리프 노드)부터 위로 올라오며 최소 비용을 계산합니다.
2.  **결과 반환**:
    -   모든 계산이 끝나면 `dp[1][0]`(CEO 불참 시 최소 비용)과 `dp[1][1]`(CEO 참석 시 최소 비용) 값이 채워집니다.
    -   우리의 목표는 **전체 매출 하락의 최솟값**이므로, 두 경우 중 더 작은 값을 선택하여 반환합니다. 어떤 경우를 선택하든 하의 모든 팀의 조건은 만족된 상태입니다.
