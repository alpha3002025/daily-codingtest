# 튜플

## 문제 설명
특정 튜플 `(a1, a2, ..., an)`을 표현하는 집합이 문자열 형태로 주어집니다.
예: `{{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}` -> 이는 튜플 `(2, 1, 3, 4)`를 의미합니다.
집합의 원소 순서는 바뀔 수 있으므로 `{{1, 2}, {2}}` 처럼 들어올 수도 있습니다.
이 문자열을 보고 원본 튜플을 찾아내야 합니다.

### 핵심 개념
1.  **문자열 파싱 (Parsing)**: 중괄호`{}`로 둘러싸인 문자열을 리스트 형태로 변환해야 합니다.
    - 양 끝의 `{{`와 `}}`를 제거하고, `},{`를 기준으로 나누면 각 집합 문자열을 얻을 수 있습니다.
2.  **규칙 찾기**:
    - 원소 개수가 1개인 집합 -> 튜플의 첫 번째 원소.
    - 원소 개수가 2개인 집합 -> 튜플의 첫, 두 번째 원소.
    - ...
    - 따라서 **길이가 짧은 집합부터 순서대로** 보면서, **새로 등장한 숫자**를 찾아 튜플에 추가하면 됩니다.

## Python 풀이

```python
def solution(s):
    # 1. 문자열 파싱
    # s[2:-2] : 양 끝의 {{ 와 }} 제거
    # split("},{") : 각 집합을 분리
    # 예: "2},{2,1},{2,1,3},{2,1,3,4"
    s = s[2:-2].split("},{")
    
    # 2. 각 문자열을 숫자 리스트로 변환하고, 길이 순으로 정렬
    data = []
    for subset in s:
        # 콤마로 분리하여 정수 리스트 생성
        data.append(list(map(int, subset.split(','))))
        
    # 길이 기준 오름차순 정렬
    data.sort(key=lambda x: len(x))
    
    # 3. 튜플 복원
    answer = []
    seen = set()
    
    for subset in data:
        for num in subset:
            if num not in seen:
                answer.append(num)
                seen.add(num)
                
    return answer
```

### 코드 설명
- `s[2:-2]`: 문자열 앞뒤의 불필요한 `{{`, `}}`를 제거합니다. 문자열이 `{{...}}` 형태이므로 인덱스 2부터 -2 전까지 자릅니다.
- `split("},{")`: 닫는 괄호와 여는 괄호 사이의 콤마를 포함해 자르면, 내부의 숫자들만 콤마로 연결된 문자열들이 리스트로 나옵니다 (`"2"`, `"2,1"` 등).
- `data.sort(key=len)`: 원소 개수가 적은 집합부터 처리해야 순서를 알 수 있습니다.
- `seen`: 이미 튜플에 추가한 숫자를 기록해두고, 새로운 숫자(`not in seen`)가 나오면 그 숫자가 튜플의 다음 원소입니다.

### 정규식 활용 풀이
정규식을 쓰면 파싱이 더 강력해집니다.

```python
import re
from collections import Counter

def solution_regex(s):
    # 모든 숫자를 다 찾음
    # 예: [2, 2, 1, 2, 1, 3, 2, 1, 3, 4]
    nums = re.findall(r'\d+', s)
    
    # 가장 많이 등장한 숫자가 첫 번째 원소...?
    # 문제 예시: (2, 1, 3, 4)
    # {2} -> 2 등장 (1회)
    # {2, 1} -> 2, 1 등장 (2가 2회, 1이 1회)
    # {2, 1, 3} -> 2, 1, 3 (2가 3회, 1이 2회, 3이 1회)
    # {2, 1, 3, 4} -> ...
    # 즉, 가장 많이 등장한 숫자가 튜플의 제일 앞 원소입니다.
    # 그 다음 많이 등장한 숫자가 두 번째 원소.
    
    counter = Counter(nums)
    # 등장 빈도 내림차순 정렬
    # most_common()은 [(값, 빈도), ...] 리스트 반환
    return [int(k) for k, v in counter.most_common()]
```
이 방식(`Counter`)이 출제 의도와 정확히 일치하는지는 모르겠지만, 집합들의 구성 성질상 **"앞쪽에 위치한 원소일수록 더 많은 부분집합에 포함된다"**는 논리가 성립하므로 매우 영리한 해법입니다.
