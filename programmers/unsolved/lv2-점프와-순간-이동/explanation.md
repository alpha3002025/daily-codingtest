# 점프와 순간 이동

## 문제 설명
0에서 시작하여 `N`까지 이동해야 합니다.
- **점프**: $K$ 칸 앞으로 이동. 배터리(비용) $K$ 사용.
- **순간 이동**: 현재 거리 $\times 2$ 로 이동. 배터리 사용 0.
배터리 사용량을 최소화하세요.

### 핵심 개념
1.  **거꾸로 생각하기 (Backwards)**: 0에서 N으로 가는 최소 비용을 짜는 것보다, **N에서 0으로 돌아오는 과정**을 생각하는 게 훨씬 쉽습니다.
    - 현재 위치가 짝수라면? 순간 이동을 해서 왔다고 치면 됩니다(비용 0). 즉, $N / 2$ 지점에서 점프했다.
    - 현재 위치가 홀수라면? 점프를 해서 왔어야 합니다(비용 1). 즉, $(N-1)$ 지점에서 1칸 점프했다.
2.  **이진수 (Binary Representation)**:
    - 계속 2로 나누고(순간이동), 홀수일 때 1을 뺀다(점프)는 과정은
    - **이진수로 변환했을 때 1의 개수(Hamming Weight)**를 세는 것과 동일합니다.
    - 예: $N=5 (101_2) \to 2$
        - 5 (홀) -> 1칸 점프 -> 4
        - 4 (짝) -> 순간이동 -> 2
        - 2 (짝) -> 순간이동 -> 1
        - 1 (홀) -> 1칸 점프 -> 0
        - 총 점프: 2회.

## Python 풀이

```python
def solution(n):
    # 이진수에서 1의 개수를 세면 끝
    return bin(n).count('1')
```

### 코드 설명
- 문제를 잘 분석해보면 $N$을 만드는 과정에서 "$\times 2$"는 비용이 안 들고 "+1"만 비용이 듭니다.
- 즉, $N = 2^a + 2^b + ...$ 형태로 나타낼 때 항의 개수가 최소 비용입니다.
- 이는 $N$의 이진수 표현에서 비트가 1인 개수와 정확히 일치합니다.
