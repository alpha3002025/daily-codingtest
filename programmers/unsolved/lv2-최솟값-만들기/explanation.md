# 최솟값 만들기

## 문제 설명
두 배열 `A`, `B`에서 각각 한 개의 숫자를 뽑아 곱한 뒤 모두 더합니다. 이 누적합이 최소가 되게 하세요.
예: `A=[1, 4, 2]`, `B=[5, 4, 4]` -> `1*5 + 2*4 + 4*4 = 29` (최소 아님) -> `1*5 + 2*4 + 4*4`? 아님.
최적: `1*5 + 2*4 + 4*4`가 아니라, 작은 수와 큰 수를 곱해야 상쇄됩니다.
`1*5 + 2*4 + 4*4` (X) -> `1*5 + 2*4(X)`...
규칙: **가장 작은 수 $\times$ 가장 큰 수** 순서로 짝지어야 합이 최소가 됩니다.

### 핵심 개념
1.  **정렬 (Sorting) & 그리디 (Greedy)**:
    - 한 배열은 오름차순, 다른 배열은 내림차순으로 정렬합니다.
    - 같은 인덱스끼리 곱해서 더하면 최솟값이 됩니다.
    - 증명: 재배열 부등식 (Rearrangement Inequality).

## Python 풀이

```python
def solution(A, B):
    # A는 오름차순 정렬
    A.sort()
    # B는 내림차순 정렬
    B.sort(reverse=True)
    
    answer = 0
    # zip으로 묶어서 순차적으로 곱함
    for a, b in zip(A, B):
        answer += a * b
        
    return answer
```

### 코드 설명
- `[1, 2, 4]` 와 `[5, 4, 4]`
    - `1*5 + 2*4 + 4*4 = 5 + 8 + 16 = 29`
    - 잠깐, 예시를 다시 보면 `A=[1, 4, 2]`, `B=[5, 4, 4]`
    - A 정렬: `[1, 2, 4]`
    - B 역정렬: `[5, 4, 4]`
    - 곱: `1*5 + 2*4 + 4*4 = 29`
    - 다른 조합: `1*4 + 2*4 + 4*5 = 4 + 8 + 20 = 32` (더 큼)
    - 가장 작은 것(1)과 가장 큰 것(5)을 곱하면 5만큼 커짐. 만약 1과 4를 곱하면 4만큼 커짐.
    - 직관: 큰 숫자를 최대한 작은 숫자와 곱해서 영향력을 죽여야 합니다.
