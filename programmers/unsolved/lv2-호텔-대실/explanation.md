# 호텔 대실

## 문제 설명
호텔 대실 예약 시각이 주어집니다 (`[["15:00", "17:00"], ... ]`).
객실은 사용 후 10분간 청소를 해야 다음 손님을 받을 수 있습니다.
예약 손님을 모두 받기 위해 필요한 최소 객실 수를 구하는 문제입니다.

## 풀이 개념
**그리디 알고리즘**과 **최소 힙(Min-Heap)**을 사용합니다.
1. 모든 시간은 분 단위 정수로 변환합니다. (`HH * 60 + MM`).
   - 종료 시간은 청소 시간 10분을 더해 저장합니다.
2. 예약 목록을 **시작 시간 순서대로 정렬**합니다.
3. 현재 사용 중인 객실들의 **"사용 가능해지는 시각(종료+청소)"**을 최소 힙에 저장합니다.
4. 새로운 예약을 처리할 때:
   - 힙의 최솟값(가장 빨리 비는 방)이 현재 예약 시작 시간보다 작거나 같다면, 그 방을 이어서 쓸 수 있습니다. -> 힙에서 pop (방 비움).
   - 힙에 현재 예약의 종료 시각을 push (방 사용).
5. 힙의 크기는 현재 동시에 사용 중인 방의 개수가 되며, 힙이 가장 커졌을 때가 필요한 방의 개수가 아닙니다. 
   - 정확히는, 우리는 방을 재사용할 때 pop을 하므로, **루프를 도는 동안 힙의 크기는 "현재 사용 중인 방의 수"**입니다.
   - 하지만 힙의 크기가 줄어들 수도 있으므로, **매 순간 힙의 크기를 체크하여 최댓값**을 구하거나, 단순히 힙에 `push`만 할 때(방 추가)와 `pop/push`(방 재사용)를 구분하여 생각하면 됩니다.
   - 논리적으로: "가장 빨리 끝나는 방보다 더 빨리 시작해야 하면 새 방이 필요하다".
   - 즉, `if room_available_time <= start_time: pop`.
   - 무조건 `push(new_end_time)`.
   - 이러면 힙의 크기(`len(heap)`)가 자연스럽게 필요한 방의 수로 유지됩니다.
   - 모든 예약을 처리한 후 힙의 크기가 답이 될까요? 아니요, 중간에 힙이 커졌다가 줄어들 수 있습니다?
   - 아니요, 방을 "비운다(pop)"는 것은 "이 방을 재사용한다"는 의미입니다. 즉 *물리적인 방 개수*는 줄어들지 않습니다. (현실에서는 청소 끝나면 빈 방이 되지만, 알고리즘 상 `pop` 후 `push`면 방 개수 유지, `pop` 없이 `push`면 방 추가입니다.)
   - 따라서 최종적으로 힙의 크기가 필요한 방의 개수가 됩니다. (재사용 가능한 방은 계속 갱신되고, 재사용 불가능하면 쌓이므로).

## 코드 (Python)

```python
import heapq

def time_to_min(t):
    h, m = map(int, t.split(':'))
    return h * 60 + m

def solution(book_time):
    # 시작 시간 순 정렬
    times = []
    for start, end in book_time:
        times.append([time_to_min(start), time_to_min(end) + 10])
    
    times.sort(key=lambda x: x[0])
    
    rooms = [] # min-heap: 사용 중인 방들의 '사용 가능해지는 시간'
    
    for start, end in times:
        if rooms and rooms[0] <= start:
            # 가장 빨리 비는 방을 쓸 수 있으면 대실 (pop으로 기존 마감 시간 제거)
            heapq.heappop(rooms)
            
        # 새 대실 정보 등록 (기존 방을 쓰든 새 방을 쓰든 종료 시간 push)
        heapq.heappush(rooms, end)
        
    return len(rooms)
```
