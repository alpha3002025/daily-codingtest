# 귤 고르기
Greedy 한 접근이다. 가장 적은 종류수를 충족하는 k개를 충족하려면 다음의 순서로 귤을 골라내면 된다.
- (1) 제일 많은 개수를 가진 kind(0) 인 0번 귤들을 뽑아낸다. (최대한 많이 빼내는 전략)
- (2) 그 다음으로 많은 개수를 가진 kind(1) 인 1번 귤들을 뽑아낸다. (최대한 많이 빼내는 전략)
- (3) ...
- (n) n-1 번째로 많은 개수를 가진 kind(n-1) 인 n-1번 귤들을 뽑아낸다. (최대한 많이 빼내는 전략)

결론만 이야기해보자면, 전략은 이렇다.
- 매 순간 가장 개수를 많이 보유한 품종의 귤을 뽑아내서 가장 빠르게 종료시키고자 하는 전략

<br/>

즉 "그리디"한 접근 방식이다.<br/>
<br/>

이 그리디 방식이 코테를 연습하고나서 어려워지는 이유는 이론을 모를때는 그리디로 풀려고 하는 경우가 많기에 쉽게 느껴지지만 이론을 많이 알고나서는 그리디로 푸는게 어려워지는 것 같다.<br/>

마치 동적프로그래밍을 사용해야 할 것 같은 착각을 하기도 한다.<br/>

결론은 "그리디 문제의 스토리 라인들을 어느 정도는 소설처럼 기억이 나면 응용이 가능하지 않을까?" 인것 같다.<br/>
<br/>


## 문제 설명
수확한 귤 중 `k`개를 골라 상자에 담아 판매하려고 합니다.
귤의 크기가 다를 수 있는데, 상자에 담긴 귤의 크기 종류가 최소가 되도록 골라야 합니다.
서로 다른 종류의 수의 최솟값을 반환합니다.

## 풀이 개념
**그리디 (Greedy)** 알고리즘과 **해시 맵 (Counter)**, **정렬**을 사용합니다.
적은 종류로 `k`개를 채우려면, **개수가 많은 종류(빈도수가 높은 크기)**부터 우선적으로 선택해야 합니다.

1. `Counter`를 이용해 각 크기별 귤의 개수를 셉니다.
2. 개수(value)만 뽑아서 **내림차순 정렬**합니다. (어떤 크기인지는 중요하지 않고, 몇 개가 있는지가 중요)
3. 정렬된 개수를 순서대로 더해가며 `k` 이상이 될 때까지 종류 수를 카운트합니다.

## 코드 (Python)

```python
from collections import Counter

def solution(k, tangerine):
    # 크기별 개수 세기
    counts = Counter(tangerine)
    
    # 개수가 많은 순으로 정렬
    sorted_counts = sorted(counts.values(), reverse=True)
    
    answer = 0
    current_count = 0
    
    for count in sorted_counts:
        current_count += count
        answer += 1
        
        if current_count >= k:
            break
            
    return answer
```
