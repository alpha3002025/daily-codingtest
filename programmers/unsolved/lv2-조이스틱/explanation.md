# 조이스틱

## 문제 설명
조이스틱을 조작하여 이름을 완성하는데 필요한 최소 조작 횟수를 구합니다.
- ▲/▼: 알파벳 변경 (다음/이전 알파벳)
- ◀/▶: 커서 이동 (왼쪽/오른쪽)
- 초기 상태는 `A`로만 이루어져 있습니다.

### 핵심 개념
1.  **상하 조작 (알파벳 맞추기)**: 각 위치에서 `A`를 해당 알파벳으로 바꾸는 횟수는 고정되어 있습니다. `min(ord(char)-ord('A'), ord('Z')-ord(char)+1)`.
    - 예: `J` -> `A`부터 9번 위로 or `Z`부터 아래로... 간단히 9번.
2.  **좌우 조작 (커서 이동)**:
    - 기본적으로 오른쪽으로 쭉 가면 `len(name) - 1`회입니다.
    - 하지만 중간에 연속된 `A`가 있다면, `A`가 없는 쪽으로 돌아가는 것이 빠를 수 있습니다.
    - 예: `JAAAAAAAZ` -> 오른쪽으로 가면 8번이나 이동해야 하지만, 첫 글자 `J` 처리 후 왼쪽으로 돌아서(`-1` 인덱스) `Z`로 가면 이동 거리가 짧아집니다.
    - **모든 위치에서 "오른쪽으로 갔다가 다시 왼쪽으로 꺾는 경우"를 계산**하여 최솟값을 찾습니다.

## Python 풀이

```python
def solution(name):
    answer = 0
    n = len(name)
    
    # 1. 상하 조작 횟수 계산 (고정값)
    for char in name:
        answer += min(ord(char) - ord('A'), ord('Z') - ord(char) + 1)
        
    # 2. 좌우 이동 횟수 계산 (그리디)
    min_move = n - 1 # 기본값: 한 방향으로 쭉 가는 경우
    
    for i in range(n):
        # 현재 위치 i 다음부터 연속된 A의 끝을 찾음
        next_i = i + 1
        while next_i < n and name[next_i] == 'A':
            next_i += 1
            
        # i까지 왔다가, 다시 왼쪽으로 돌아가서 뒤쪽(next_i)을 공략하는 거리
        # (원점 -> i) 거리: i
        # (i -> 원점) 거리: i
        # (원점 -> 뒤쪽) 거리: n - next_i
        # 총 거리 = 2*i + (n - next_i)
        
        # 반대로, 뒤쪽을 먼저 갔다가(n - next_i) 다시 돌아와서(n - next_i) i로 가는 경우도 있음
        # 총 거리 = 2*(n - next_i) + i
        
        distance = min(i, n - next_i) + i + n - next_i
        min_move = min(min_move, distance)
        
    answer += min_move
    return answer
```

### 코드 설명
- `i`: 현재 위치까지 오른쪽으로 진행.
- `next_i`: `i` 오른쪽의 연속된 `A`가 끝나는 지점. 즉, `A`가 아닌 문자가 다시 나오는 지점.
- `distance`: `i` 지점과 `next_i` 지점(뒤에서부터 접근)을 모두 방문하기 위해, 원점에서 `i`로 갔다가 돌아가거나, 원점에서 뒤로 돌아 `next_i`로 갔다가 다시 돌아가는 경로 중 짧은 것.
    - 수식: `min(i, n - next_i) * 2 + max(i, n - next_i)` 형태가 아니라, **짧은 구간을 왕복**하고 긴 구간은 편도입니다.
    - `i`가 짧으면: `i`(가기) + `i`(오기) + `(n-next_i)`(뒤쪽 가기)
    - `(n-next_i)`가 짧으면: `(n-next_i)`(가기) + `(n-next_i)`(오기) + `i`(앞쪽 가기)
