# 조이스틱

## 개념 설명 코드
```python
def solution(name):
    answer = 0
    n = len(name)
    
    ## 알파벳 상하 이동 횟수
    alphabet_move_cnt = 0
    for c in name:
        alphabet_move_cnt += min(abs(ord(c) - ord('A')), abs(ord('Z') - ord(c)) + 1)
    
    ## 문자열 좌우 이동횟수
    horizontal_move_cnt = n - 1
    for i in range(n):
        next_i = i + 1
        while next_i < n and name[next_i] == 'A':
            next_i += 1
            
            ## 오른쪽으로 갔다가 돌아오기 
            ##    e.g. BBBAAZ : 0 → 2(이동2), 2 → 0(복귀2), 0 → 5(이동1) = 2+2+1=5
            dist_right_first = i * 2 + (n - next_i)
            
            ## 왼쪽으로 갔다가 돌아오기 
            ##    e.g. BBBAAZ : 0 → 5(왼쪽1), 5 → 0(오른쪽1), 0 → 1,1 → 2 (오른쪽2) = 1+1+2=4
            dist_left_first = (n - next_i) * 2 + i
            
            ## distance = min(오른쪽 갔다가 돌아오기, 왼쪽으로 갔다가 돌아오기)
            distance = min(dist_right_first, dist_left_first)
            
            ## 최소값 업데이트
            horizontal_move_cnt = min(horizontal_move_cnt, distance)
    
    ## 알파벳 이동횟수 + 좌우 이동횟수
    return alphabet_move_cnt + horizontal_move_cnt
```

<br/>

## 문제 설명
조이스틱을 조작하여 이름을 완성하는데 필요한 최소 조작 횟수를 구합니다.
- ▲/▼: 알파벳 변경 (다음/이전 알파벳)
- ◀/▶: 커서 이동 (왼쪽/오른쪽)
- 초기 상태는 `A`로만 이루어져 있습니다.

### 핵심 개념
1.  **상하 조작 (알파벳 맞추기)**: 각 위치에서 `A`를 해당 알파벳으로 바꾸는 횟수는 고정되어 있습니다. `min(ord(char)-ord('A'), ord('Z')-ord(char)+1)`.
    - 예: `J` -> `A`부터 9번 위로 or `Z`부터 아래로... 간단히 9번.
2.  **좌우 조작 (커서 이동)**:
    - 기본적으로 오른쪽으로 쭉 가면 `len(name) - 1`회입니다.
    - 하지만 중간에 연속된 `A`가 있다면, `A`가 없는 쪽으로 돌아가는 것이 빠를 수 있습니다.
    - 예: `JAAAAAAAZ` -> 오른쪽으로 가면 8번이나 이동해야 하지만, 첫 글자 `J` 처리 후 왼쪽으로 돌아서(`-1` 인덱스) `Z`로 가면 이동 거리가 짧아집니다.
    - **모든 위치에서 "오른쪽으로 갔다가 다시 왼쪽으로 꺾는 경우"를 계산**하여 최솟값을 찾습니다.

## Python 풀이

```python
def solution(name):
    answer = 0
    n = len(name)
    
    # 1. 상하 조작 횟수 계산 (고정값)
    for char in name:
        answer += min(ord(char) - ord('A'), ord('Z') - ord(char) + 1)
        
    # 2. 좌우 이동 횟수 계산 (그리디)
    min_move = n - 1 # 기본값: 한 방향으로 쭉 가는 경우
    
    for i in range(n):
        # 현재 위치 i 다음부터 연속된 A의 끝을 찾음
        next_i = i + 1
        while next_i < n and name[next_i] == 'A':
            next_i += 1
            
        # i까지 왔다가, 다시 왼쪽으로 돌아가서 뒤쪽(next_i)을 공략하는 거리
        # (원점 -> i) 거리: i
        # (i -> 원점) 거리: i
        # (원점 -> 뒤쪽) 거리: n - next_i
        # 총 거리 = 2*i + (n - next_i)
        
        # 반대로, 뒤쪽을 먼저 갔다가(n - next_i) 다시 돌아와서(n - next_i) i로 가는 경우도 있음
        # 총 거리 = 2*(n - next_i) + i
        
        distance = min(i, n - next_i) + i + n - next_i
        min_move = min(min_move, distance)
        
    answer += min_move
    return answer
```

## 코드 설명
### next_i 이동
현재 위치 `i` 다음 위치부터 연속된 'A'를 모두 건너뛰어 'A'가 아닌 문자가 다시 나오는 지점을 찾습니다. 코드에서는 `while next_i < n and name[next_i] == 'A': next_i += 1` 로직을 사용합니다.

### distance 계산
`i` 지점과 뒤쪽의 `next_i` 지점까지 모두 방문하기 위한 최소 이동 거리를 계산합니다.
- `i`: 시작점에서 오른쪽으로 `i`만큼 이동
- `n - next_i`: 시작점에서 왼쪽으로 `n - next_i`만큼 이동 (뒤에서부터 접근)
- `min(i, n - next_i)`: 둘 중 더 짧은 거리를 왕복(갔다가 되돌아오기)으로 처리합니다.
- `distance = i + (n - next_i) + min(i, n - next_i)`
    - 오른쪽으로 갔다가(`i`) 다시 원점으로 돌아와(`i`) 왼쪽으로 가는 경우(`n - next_i`): `2*i + n - next_i`
    - 왼쪽으로 갔다가(`n - next_i`) 다시 원점으로 돌아와(`n - next_i`) 오른쪽으로 가는 경우(`i`): `2*(n - next_i) + i`
이 두 경우 중 최솟값을 구하는 식을 한 줄로 표현한 것입니다.

- **예시**: `JAZ` (n=3)
    - `i=0` ('J')일 때, 다음으로 'A'가 아닌 문자는 `next_i=2` ('Z')입니다.
    - `n - next_i` = `3 - 2` = `1`.
    - 즉, 원점에서 왼쪽(뒤)으로 1칸 이동하면 'Z'에 도착한다는 의미입니다.

- **상세 이동 경로 비교 예시**: `BBBAAZ` (n=6)
    - `i=2` (세 번째 'B')까지 이동 후, A를 건너뛰고 `next_i=5` ('Z')로 가는 상황입니다.
    - `i` (오른쪽 이동 거리) = 2
    - `n - next_i` (왼쪽 이동 거리) = 6 - 5 = 1
    
    1.  **오른쪽 먼저 (오 → 왼)**: `i` 구간을 왕복
        - 0 → 2 (이동: 2)
        - 2 → 0 (복귀: 2)
        - 0 → 5 (이동: 1)
        - 총 거리: `2 + 2 + 1 = 5`
        
    2.  **왼쪽 먼저 (왼 → 오)**: `n - next_i` 구간을 왕복 (**최단 경로**)
        - 0 → 5 (왼쪽 1칸): 맨 뒤의 `Z`를 처리하러 이동
        - 5 → 0 (오른쪽 1칸): 다시 앞쪽의 `B`들을 처리하기 위해 원점으로 복귀
        - 0 → 2 (오른쪽 2칸): 남은 `B`들(인덱스 1, 2)을 처리하러 이동
        - 0 → 2 (오른쪽 2칸): 남은 `B`들(인덱스 1, 2)을 처리하러 이동
        - 총 거리: `1 + 1 + 2 = 4`

### 식 풀어서 쓰기
`distance = i + (n - next_i) + min(i, n - next_i)` 식을 `min` 없이 풀어서 쓰면 다음과 같은 두 가지 경우의 최솟값을 구하는 것과 같습니다.

1.  **오른쪽으로 갔다 돌아오기 (Right First)**
    - `0`에서 `i`까지 갔다가(`i`), 다시 `0`으로 돌아와서(`i`), 뒤쪽 `next_i`로 이동(`n - next_i`)
    - `(i * 2) + (n - next_i)`

2.  **왼쪽으로 갔다 돌아오기 (Left First)**
    - `0`에서 뒤쪽 `next_i`까지 갔다가(`n - next_i`), 다시 `0`으로 돌아와서(`n - next_i`), 앞쪽 `i`로 이동(`i`)
    - `(n - next_i) * 2 + i`

즉, 코드로 표현하면 다음과 같습니다.
```python
dist_right_first = i * 2 + (n - next_i)
dist_left_first = (n - next_i) * 2 + i
distance = min(dist_right_first, dist_left_first)
```
<br/>

## Q&A
### Q1. `abs(ord('Z') - ord(c)) + 1` 의 의미는 무엇인가요?

이 수식은 조이스틱을 **아래쪽(▼)**으로 조작하여 **'A'에서 거꾸로('Z' 방향으로) 알파벳을 찾는 경우**의 조작 횟수를 의미합니다.

*   **원리**: 'A'에서 아래로 한 번 조작하면 바로 'Z'가 나옵니다.
    1.  'A' → 'Z'로 가는 이동 횟수는 **1회**입니다. (수식의 `+1` 부분)
    2.  'Z'에서 해당 문자 `c`까지의 거리(`ord('Z') - ord(c)`)를 더해줍니다.
    
    즉, **A → Z → ... → c** 로 이동하는 총 횟수를 계산하는 식입니다.

**예시**: 만약 문자 'Y'를 만든다면:
- **위로(▲) 조작**: A → B → ... → Y (24회)
- **아래로(▼) 조작**: `abs(ord('Z') - ord('Y')) + 1` = `1 + 1` = **2회** (A → Z → Y)

따라서 `min(위로 이동, 아래로 이동)` 중 더 작은 값을 선택하여 최소 조작 횟수를 구하게 됩니다.

<br/>

### Q2. `i * 2 + (n - next_i)` (오른쪽으로 갔다가 돌아오기)의 의미는 무엇인가요?

이 부분은 조이스틱의 **좌우 이동 최적화** 중 **"오른쪽으로 먼저 갔다가 다시 왼쪽으로 돌아오는 경우"**를 계산하는 로직입니다. 문자열 중간에 연속된 'A'가 있을 때, 이를 피해서 이동하는 것이 더 효율적일 수 있기 때문입니다.

**상황 설명**
예시: `BBBAAZ` (길이 6, 'A'가 중간에 있음)
- **현재 위치(`i`)**: 인덱스 2 (세 번째 'B')
- **다음 타겟(`next_i`)**: 인덱스 5 ('Z')
- 중간의 인덱스 3, 4는 'A'이므로 건너뜁니다.

**이동 경로 계산 (`dist_right_first`)**
1.  **시작 → 현재 위치(`i`)**: `0`번 인덱스에서 `i`번 인덱스까지 오른쪽으로 이동합니다. (거리: `i`)
2.  **현재 위치(`i`) → 시작**: 다시 원점(`0`)으로 돌아옵니다. (거리: `i`)
    -   여기까지 총 `i * 2` 이동 (왔다 갔다).
3.  **시작 → 뒤쪽 타겟(`next_i`)**: 원점에서 문자열의 끝방향(역방향/왼쪽)으로 이동하여 `next_i`에 도달합니다. (거리: `n - next_i`)

**수식 종합**
$$i \times 2 + (n - \text{next\_i})$$
- `i * 2`: 오른쪽 찍고 다시 원점 복귀
- `n - next_i`: 원점에서 왼쪽으로 돌아서 남은 문자들 중 가장 오른쪽에 있는 타겟 도달

**예시 `BBBAAZ` (i=2, next_i=5, n=6)**:
- 0 → 2 (`B`->`B`->`B`): 거리 2
- 2 → 0 (복귀): 거리 2
- 0 → 5 (`Z`): 거리 1 (뒤로 한 칸)
- **총 거리**: 2 + 2 + 1 = 5


### Q3. `(n - next_i) * 2 + i` (왼쪽으로 갔다가 돌아오기)의 의미는 무엇인가요?

이 부분은 **"왼쪽(역방향)으로 먼저 최대한 갔다가 다시 오른쪽(정방향)으로 돌아오는 경우"**를 계산하는 로직입니다. 문자열의 끝부분에 있는 문자들을 먼저 처리하는 것이 더 빠를 수 있기 때문입니다.

**상황 설명**
예시: `BBBAAZ` (길이 6, 'A'가 중간에 있음)
- **현재 위치(`i`)**: 인덱스 2 (세 번째 'B')
- **다음 타겟(`next_i`)**: 인덱스 5 ('Z')

**이동 경로 계산 (`dist_left_first`)**
1.  **시작 → 뒤쪽 타겟 (`next_i`)**: 원점(`0`)에서 왼쪽(역방향)으로 이동하여 `next_i`에 먼저 도달합니다.
    -   이동 거리: `n - next_i` (끝에서부터 역순으로 얼마나 왔는지)
2.  **뒤쪽 타겟(`next_i`) → 시작**: 다시 원점(`0`)으로 돌아옵니다. (오른쪽으로 이동)
    -   이동 거리: `n - next_i`
    -   여기까지 총 `(n - next_i) * 2` 이동 (왔다 갔다).
3.  **시작 → 앞쪽 위치 (`i`)**: 원점에서 오른쪽(정방향)으로 이동하여 `i`에 도달합니다. (거리: `i`)

**수식 종합**
$$(n - \text{next\_i}) \times 2 + i$$
- `(n - next_i) * 2`: 왼쪽으로 가서 뒤쪽 문자들을 처리하고 다시 원점으로 복귀
- `i`: 복귀한 원점에서 다시 오른쪽으로 이동하여 앞쪽 문자들 처리

**예시 `BBBAAZ` (i=2, next_i=5, n=6)**:
- 0 → 5 (`Z`): 거리 1 (뒤로 이동)
- 5 → 0 (복귀): 거리 1
- 0 → 2 (`B`->`B`->`B`): 거리 2
- **총 거리**: 1 + 1 + 2 = **4**

이 경우(4)가 앞서 계산한 "오른쪽 먼저(5)"보다 더 효율적임을 알 수 있습니다.

