# [PCCE 기출문제] 9번 / 이웃한 칸

## 문제 설명
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/250125)

2차원 격자 보드판(`board`)에서 특정 칸(`h`, `w`)을 선택했을 때, 상하좌우로 이웃한 칸들 중 **같은 색으로 칠해진 칸의 개수**를 구하는 문제입니다.

**입력**:
- `board`: 색칠된 2차원 문자열 배열
- `h`, `w`: 선택한 칸의 좌표 (행, 열)

## 해결 전략
2차원 배열 탐색의 가장 기초적인 문제로, **방향 벡터(Direction Vectors)**를 사용하여 상하좌우를 탐색하는 방법을 익히기 좋습니다.

1. **방향 정의**: 상, 하, 좌, 우를 나타내는 변화량 리스트를 정의합니다.
    - `dh = [-1, 1, 0, 0]` (행 변화)
    - `dw = [0, 0, -1, 1]` (열 변화)
2. **이웃 탐색**: 4가지 방향에 대해 반복문을 돌며 이웃 칸의 좌표 `(nh, nw)`를 계산합니다.
3. **유효성 검사**: 계산된 좌표가 보드 범위(`0 <= nh < n`, `0 <= nw < n`) 내에 있는지 확인합니다.
4. **색깔 비교**: 범위 내라면, `board[h][w]`와 `board[nh][nw]`가 같은지 비교하고, 같다면 카운트를 증가시킵니다.

### 알고리즘 순서
1. `n` = `len(board)` (보드 크기)
2. `count` = 0 초기화
3. `dh`, `dw` 정의
4. 4방향 루프 (`i` from 0 to 3):
    - `nh = h + dh[i]`, `nw = w + dw[i]`
    - 범위 체크: `0 <= nh < n` and `0 <= nw < n`
    - 색깔 체크: `board[h][w] == board[nh][nw]`
    - 조건 만족 시 `count += 1`
5. `count` 반환

## Python 코드

```python
def solution(board, h, w):
    n = len(board)
    count = 0
    
    # 상, 하, 좌, 우 이동 방향
    dh = [-1, 1, 0, 0]
    dw = [0, 0, -1, 1]
    
    for i in range(4):
        nh = h + dh[i]
        nw = w + dw[i]
        
        # 보드 범위를 벗어나지 않는지 확인
        if 0 <= nh < n and 0 <= nw < n:
            # 같은 색인지 확인
            if board[h][w] == board[nh][nw]:
                count += 1
                
    return count
```

## 배운 점 / 팁
- **방향 벡터(`dx`, `dy`)**: 2차원 배열 탐색(DFS/BFS 등)에서 필수적으로 사용되는 테크닉입니다. 하드코딩된 `if-else`보다 확장이 용이하고 코드가 간결해집니다.
- **범위 체크 (`Boundary Check`)**: 배열 인덱스 접근 전에는 항상 유효한 범위인지 먼저 검사해야 `IndexError`를 방지할 수 있습니다.
