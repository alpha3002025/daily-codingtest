# 구명보트
이것 역시 그리디다. 마치 lv2. 귤 고르기 와 유사하게 가중치를 줘서 판단해야 한다.

모든 사람을 구출할때 구명보트를 최소한으로 사용하려면
- 제일 뚱뚱한 사람 `P[r1]` 과 제일 가벼운 사람 `P[l1]` 을 함께 태우는 시도를 한다.
  - 이때 용량 초과면 l1 은 안태우고 r1 혼자 태운다. (boats += 1)
  - "가벼운 l1 니가 참아, 기다렸다가 타자구!!"
- 두번째 뚱뚱한 사람 `P[r2]` 과 그 다음 가벼운 사람 `P[l1 또는 l2]` 을 함께 태우는 시도를 한다.
  - 이때 용량 초과면 l1 또는 l2 는 안태우고 r2 혼자 태운다. (boats += 1)
  - "가벼운 l1 또는 l2 니가 참아, 기다렸다가 타자구!!"

...

이렇게 반복하다보면 심각하게 뚜디한 형들은 다타고 가벼운 친구들만 계속해서 남게되는데 
점점 가벼운 친구들로 l,r 이 구성될때 결국은 가벼운 친구들을 죄다 싸그리 모아서 보트에 한번에 태우는 것도 가능할 수 있다.<br/>

문제에서 묻는건 이런 개념은 아니지만, 결국 right 는 무조건 차감되며 boat 수는 항상 차감되지만 (문제에서 원하는 구명보트의 정원이 2 이기에) 결국 뚱뚱한 사람은 다른 n번째 뚱뚱한 사람과는 같이 탈수 없어서 많이 슬프다. 그래서 똥뚱한 사람이 탔을때 빈 공간을 가벼운 친구를 끼워넣어서 메우던가, 아니면 뚱뚱한 친구 한명만 태워서 보내든가 둘 중 하나다.<br/>

이 방식을 투 포인터로 푼다.<br/>

만약 n명을 태우는 문제라면, 귤 고르기 문제 처럼 풀게된다.<br/>
<br/>



## 문제 설명
최대 2명씩 탈 수 있고, 무게 제한 `limit`이 있는 구명보트를 이용하여 모든 사람을 구출해야 합니다.
구명보트 개수의 최솟값을 구하세요.

### 핵심 개념
1.  **그리디 (Greedy) 알고리즘**: 가장 무거운 사람을 태울 때, 가장 가벼운 사람을 같이 태울 수 있는지 확인하는 것이 이득입니다.
    - 같이 탈 수 있다면 2명 태워 보냄.
    - 안 된다면 무거운 사람 혼자 보냄. (어차피 다른 누구와도 못 탐)
2.  **투 포인터 (Two Pointers)**:
    - 사람들을 몸무게 순으로 **정렬**합니다.
    - `left` 포인터(가장 가벼운 사람)와 `right` 포인터(가장 무거운 사람)를 사용합니다.

## Python 풀이

```python
def solution(people, limit):
    people.sort()
    
    left = 0
    right = len(people) - 1
    boats = 0
    
    while left <= right:
        # 가장 무거운 사람과 가장 가벼운 사람이 같이 탈 수 있는지 확인
        if people[left] + people[right] <= limit:
            left += 1 # 가벼운 사람 탑승 성공
            
        # 무거운 사람은 항상 탑승 (혼자든 같이든)
        right -= 1
        boats += 1
        
    return boats
```

### 코드 설명
- 정렬: $O(N \log N)$.
- 투 포인터 탐색: $O(N)$.
- 가장 무거운 사람(`people[right]`)은 무조건 보트를 타야 합니다. 남은 공간에 가장 가벼운 사람(`people[left]`)이 들어갈 수 있으면 같이 태우고(`left += 1`), 아니면 무거운 사람만 태웁니다(`right -= 1`은 항상 수행).
- 2명 제한이 있으므로, 가벼운 사람을 더 태울 수 있어도 1명만 확인하면 됩니다.
