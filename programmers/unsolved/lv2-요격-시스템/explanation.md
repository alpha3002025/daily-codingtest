# 요격 시스템

## 문제 설명
A 나라가 B 나라를 침공했습니다. B 나라의 요격 시스템은 적의 미사일을 요격하기 위해 미사일 요격기를 발사합니다.
각 폭격 미사일은 x축에 평행한 직선 형태의 개구간 (s, e)로 표현됩니다.
요격기는 x좌표 하나를 선택하여 발사하며, 해당 x좌표가 개구간 (s, e)에 포함되면 (s < x < e) 미사일이 요격됩니다.
모든 폭격 미사일을 요격하기 위해 필요한 요격기의 최소 개수를 구하는 문제입니다.

## 풀이 개념
**그리디 알고리즘 (Greedy Algorithm)** 을 사용합니다.

1. 미사일 구간들을 끝나는 지점 `e`를 기준으로 오름차순 정렬합니다.
   - 끝나는 지점이 같을 경우 시작 지점 `s`를 기준으로 정렬해도 되지만, 핵심은 끝나는 지점입니다.
2. 정렬된 미사일들을 순회하며 요격 시스템을 배치합니다.
   - 현재 가장 먼저 끝나는 미사일을 요격하기 위해서는, 해당 미사일의 끝나는 지점 직전에 요격기를 배치하는 것이 가장 유리합니다. 요격 위치를 최대한 뒤쪽으로 잡아야 이후에 시작하는 다른 미사일들도 함께 요격할 가능성이 높아지기 때문입니다.
3. 구체적인 로직:
   - 마지막 요격 지점(`last_intercept`)을 `-1`로 초기화합니다.
   - 정렬된 각 미사일 `[s, e)`에 대해:
     - 만약 미사일의 시작 지점 `s`가 `last_intercept`보다 크거나 같다면 (즉, 이전에 설치한 요격기로 커버가 안 된다면),
     - 새로운 요격기가 필요하므로 `answer`를 1 증가시킵니다.
     - 새로운 요격 지점은 현재 미사일의 끝점 `e` 직전으로 설정합니다. (문제의 조건인 정수/실수 여부와 상관없이, 논리적으로 `e`보다 아주 조금 작은 위치로 설정한다고 생각하면 됩니다. 비교 시에는 `limit = e`로 설정하고, 다음 미사일의 `s`가 이 `limit`보다 작은지로 판단합니다. `s < e` 조건에 의해 같은 `e`값을 가지는 위치는 커버가 안 되므로, 다음 미사일의 `s`가 현재 `limit` 이상이면 요격 불가능입니다.)
     - 따라서 `last_intercept = e`로 갱신합니다.

## 코드 (Python)

```python
def solution(targets):
    # 끝나는 지점(e)을 기준으로 오름차순 정렬
    targets.sort(key=lambda x: x[1])
    
    answer = 0
    last_intercept = -1
    
    for s, e in targets:
        # 현재 미사일의 시작점(s)이 마지막 요격 지점보다 크거나 같다면
        # 이전 요격기로는 이 미사일을 요격할 수 없음 (개구간이라 s == last_intercept여도 요격 불가)
        # 따라서 새로운 요격기를 해당 미사일의 끝점(e) 부근에 설치
        if s >= last_intercept:
            answer += 1
            last_intercept = e
            
    return answer
```
