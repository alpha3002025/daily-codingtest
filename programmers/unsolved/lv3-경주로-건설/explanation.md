# 경주로 건설

## 문제 설명
$N \times N$ 크기의 격자 도면 `board`가 주어집니다.
- 0은 빈 칸, 1은 벽입니다.
- (0, 0)에서 (N-1, N-1)까지 경주로를 건설하려고 합니다.
- 상하좌우로 인접한 두 빈 칸을 연결하면 **직선 도로** (비용 100원).
- 두 직선 도로가 서로 직각(코너)으로 만나면 **코너** (비용 500원 추가).
- 최소 비용으로 경주로를 건설할 때의 비용을 구하세요.

## 문제 해결 전략

**BFS (너비 우선 탐색)** 또는 **다익스트라**를 사용합니다.
단순히 `(x, y)` 위치뿐만 아니라, **진입 방향**에 따라 비용이 달라지므로 상태를 확장해야 합니다.
- 상태: `(x, y, dir, cost)`
- `visited` 또는 `cost` 배열: `cost[x][y][dir]` -> 해당 위치에 해당 방향으로 도달했을 때의 최소 비용 저장.
- 방향: 상(0), 하(1), 좌(2), 우(3).
- 비용 계산:
  - 같은 방향으로 진행: 직선 도로 (+100)
  - 다른 방향으로 진행: 직선 도로 + 코너 (+100 + 500 = +600)
  - 코너 비용은 '꺾인 후 직선 하나'에서 발생하므로, 그냥 이동할 때 100원을 기본으로 하고 방향이 바뀌면 500원을 추가한다고 생각하면 됩니다.

## Python 코드

```python
from collections import deque

def solution(board):
    n = len(board)
    # 방향: 상, 하, 좌, 우
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]
    
    # 3차원 비용 배열: costs[x][y][direction]
    # 초기값 무한대
    costs = [[[float('inf')] * 4 for _ in range(n)] for _ in range(n)]
    
    q = deque()
    
    # 시작점 (0,0) 처리
    # 시작할 때는 방향이 없으므로, (0,0)에서 갈 수 있는 곳(오른쪽, 아래)으로 미리 보내거나
    # (0,0) 에서는 비용 0, 방향 -1로 시작해도 됨.
    # 여기서는 (0,0) 비용 0으로 초기화하고, 4방향 모두 0으로 둠.
    for i in range(4):
        costs[0][0][i] = 0
    
    # (x, y, cost, dir)
    # 출발은 방향이 없지만, 오른쪽(3)이나 아래(1)로만 갈 수 있음 (0,0은 벽이 아니므로)
    # 0,0에서 출발하는 첫 스텝은 코너 비용이 안 듦 (100원만 듦).
    # 따라서 큐에 직접 (0,0)을 넣기보다, 갈 수 있는 인접 칸을 넣어주는 게 편함.
    
    if board[0][1] == 0:
        costs[0][1][3] = 100
        q.append((0, 1, 100, 3)) # 우
    
    if board[1][0] == 0:
        costs[1][0][1] = 100
        q.append((1, 0, 100, 1)) # 하
        
    min_cost = float('inf')
    
    while q:
        x, y, cost, direction = q.popleft()
        
        # 목적지 도착 시 최소값 갱신
        if x == n - 1 and y == n - 1:
            min_cost = min(min_cost, cost)
            continue
            
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            
            if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 0:
                # 비용 계산
                new_cost = cost + 100
                if direction != i: # 방향이 다르면 코너 비용 추가
                    new_cost += 500
                
                # 최소 비용 갱신 조건 (등호 포함 주의: 비용이 같아도 방향이 다르면 유리할 수 있음 -> 아니면 걍 작을 때만?)
                # 보통 BFS 최단거리는 '작을 때' 갱신.
                # 하지만 여기선 방향에 따라 미래가 달라지므로 direction별로 관리 중.
                # 따라서 costs[nx][ny][i]보다 작으면 갱신.
                # 예외: 같은 값이어도 큐에 넣어야 하나? -> 다익스트라가 아니므로 BFS에서는 작거나 같으면 통과 시키는 게 안전할 수 있음.
                if new_cost <= costs[nx][ny][i]:
                    costs[nx][ny][i] = new_cost
                    q.append((nx, ny, new_cost, i))
                    
    # 도착점의 4방향 중 최소값
    return min(costs[n-1][n-1])
```
