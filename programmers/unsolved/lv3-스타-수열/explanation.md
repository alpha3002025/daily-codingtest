# 스타 수열

## 문제 설명
배열 `a`에서 부분 수열을 만들어 "스타 수열"을 만듭니다.
스타 수열 조건:
1. 길이가 2 이상의 짝수.
2. 2개씩 묶었을 때 `(x[0], x[1]), (x[2], x[3]), ...` 각 집합의 교집합이 1개 이상 존재. (즉, 모든 쌍에 공통된 숫자가 있어야 함)
3. 각 묶음의 두 숫자는 서로 달라야 함 (`x[2i] != x[2i+1]`).

가장 긴 스타 수열의 길이를 구하세요.

## 문제 해결 전략

1. **교집합 원소 (Anchor) 결정**:
   - 스타 수열이 되려면 모든 쌍에 공통적으로 들어가는 숫자(교집합)가 하나 있어야 합니다.
   - 그 숫자를 `k`라고 가정하고 문제를 풉니다.
   - 가능한 `k`의 후보는 `a`에 등장하는 모든 숫자입니다.
   - `k`의 등장 횟수가 스타 수열 길이의 최대 한계이므로(쌍마다 `k`가 하나씩 들어가야 하니), 등장 횟수가 많은 순서대로 `k`를 시도하여 가지치기(Pruning)를 할 수 있습니다.

2. **`k`를 기준으로 스타 수열 길이 계산**:
   - 배열 `a`를 순회하면서 `k`를 포함하는 유효한 쌍 `(any, k)` 또는 `(k, any)`를 최대한 많이 만듭니다.
   - $index$를 0부터 시작:
     - 현재 `a[i]`와 `a[i+1]`을 봅니다.
     - 두 수 중 하나라도 `k`여야 합니다.
     - 두 수는 서로 달라야 합니다.
     - 조건 만족하면 길이 +2, 인덱스 +2 (다음 쌍으로).
     - 만족 안 하면 `i`를 1 증가시켜서 (`a[i]`를 버리고) `a[i+1], a[i+2]`를 봅니다.
   - 주의: `a[i]`가 `k`가 아니라면 `a[i+1]`이 `k`여야 하므로, 그리디하게 짝을 지을 때 `k` 중심에서 양옆을 볼 필요 없이, 순차적으로 짝을 지으면 됩니다.

## Python 코드

```python
from collections import Counter

def solution(a):
    counts = Counter(a)
    answer = 0
    
    # 등장 횟수가 많은 숫자부터 시도 (Pruning)
    # k: 공통 원소 후보
    for k, cnt in counts.most_common():
        # 만약 k의 등장 횟수 * 2가 현재 찾은 최대 길이보다 작다면, 더 볼 필요 없음
        if cnt * 2 <= answer:
            break
            
        local_len = 0
        i = 0
        while i < len(a) - 1:
            # 두 수 (a[i], a[i+1]) 검사
            if (a[i] != k and a[i+1] != k):
                # 둘 다 k가 없음 -> 넘김
                i += 1
                continue
            
            if a[i] == a[i+1]:
                # 두 수가 같음 -> 스타 수열 조건 위배 -> 넘김
                # 여기서 i+=1을 하면, 다음은 (a[i+1], a[i+2])를 봄.
                # a[i+1]은 k일 수도 있으므로 재활용 가능성?
                # 아니, a[i]==a[i+1]이면 이 쌍은 못 씀.
                # a[i]를 버린다고 생각하고 i+=1.
                i += 1
                continue
                
            # 하나는 k이고, 둘이 다름 -> 매칭 성공
            local_len += 2
            i += 2 # 두 개 다 썼으므로 점프
            
        answer = max(answer, local_len)
        
    return answer
```
