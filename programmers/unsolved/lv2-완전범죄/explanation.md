# 프로그래머스 - 완전범죄 (Lv.2)

## 1. 문제 분석
두 명의 도둑 A와 B가 팀을 이뤄 물건을 훔칩니다. 각 물건마다 A가 훔칠 때 남기는 흔적과 B가 훔칠 때 남기는 흔적이 다릅니다.
- **목표**: 모든 물건을 훔치면서, A와 B 모두 경찰에 잡히지 않아야 합니다. 이때 **A가 남긴 흔적의 합을 최소화**해야 합니다.
- **제한 조건**:
  - A는 누적 흔적이 `n` 이상이면 잡힙니다. (즉, `n` 미만이어야 함)
  - B는 누적 흔적이 `m` 이상이면 잡힙니다. (즉, `m` 미만이어야 함)
  - 불가능한 경우 `-1`을 반환합니다.

## 2. 알고리즘 설계 (Dynamic Programming)
이 문제는 전형적인 배낭 문제(Knapsack Problem)의 변형으로 볼 수 있습니다.
각 물건에 대해 **"A가 훔친다"** 또는 **"B가 훔친다"** 두 가지 선택지가 있으며, 이 선택에 따라 두 개의 상태값(A의 흔적, B의 흔적)이 변합니다.

우리는 **A의 흔적을 최소화**하는 것이 목표이므로, DP 테이블의 인덱스를 **B의 흔적 합**으로, 값을 **A의 최소 흔적 합**으로 설정하여 관리할 수 있습니다.

### 상태 정의 (State Definition)
`dp[j]` = **B의 누적 흔적이 `j`일 때, 가능한 A의 최소 누적 흔적**

- `j`의 범위: `0`부터 `m-1`까지 (B가 잡히지 않는 범위)
- `dp` 값: A가 잡히지 않는 범위(`0` ~ `n-1`) 내의 최소값. 초기값은 무한대(`INF`)로 설정.

### 점화식 (Transition)
각 물건(Item)을 순회하며 기존 DP 테이블을 갱신합니다.
현재 물건의 흔적이 `trace_A`, `trace_B`일 때, 기존 `dp[b]` (B의 흔적이 `b`, A의 흔적이 `dp[b]`) 상태에서 두 가지 경우로 파생됩니다.

1.  **A가 훔치는 경우**:
    - 새로운 A 흔적: `dp[b] + trace_A`
    - 새로운 B 흔적: `b` (변화 없음)
    - 조건: `dp[b] + trace_A < n`
    - 갱신: `new_dp[b] = min(new_dp[b], dp[b] + trace_A)`

2.  **B가 훔치는 경우**:
    - 새로운 A 흔적: `dp[b]` (변화 없음)
    - 새로운 B 흔적: `b + trace_B`
    - 조건: `b + trace_B < m`
    - 갱신: `new_dp[b + trace_B] = min(new_dp[b + trace_B], dp[b])`

### 시간 복잡도
- 물건의 개수(`len(info)`) × B의 한계(`m`)
- 최대 연산 횟수: 40 × 120 = 4,800회 (매우 효율적)

## 3. Python 풀이 코드

```python
def solution(info, n, m):
    # dp[j] = B의 누적 흔적이 j일 때, A의 최소 누적 흔적
    # 초기화: 불가능한 상태는 INF로 설정
    INF = float('inf')
    dp = [INF] * m
    dp[0] = 0  # 초기 상태: 아무것도 훔치지 않았을 때 (A=0, B=0)
    
    for trace_a, trace_b in info:
        new_dp = [INF] * m  # 이번 아이템을 처리한 후의 상태를 저장할 배열
        
        for b in range(m):
            if dp[b] == INF:  # 도달 불가능한 상태는 건너뜀
                continue
            
            # 현재 상태: A의 흔적 = dp[b], B의 흔적 = b
            current_a = dp[b]
            
            # 1. A가 훔치는 경우
            if current_a + trace_a < n:
                new_dp[b] = min(new_dp[b], current_a + trace_a)
            
            # 2. B가 훔치는 경우
            if b + trace_b < m:
                new_dp[b + trace_b] = min(new_dp[b + trace_b], current_a)
        
        dp = new_dp  # DP 테이블 업데이트

    # 모든 아이템 처리 후, 가능한 상태 중 A의 최소 흔적 찾기
    answer = min(dp)
    
    return answer if answer != INF else -1
```

### 코드 상세 설명
#### `current_a = dp[b]` 와 `b`의 의미

1. **`b` (인덱스) = B의 흔적**
   - 우리가 배열의 인덱스를 `0`부터 `m-1`까지 만들었을 때, **인덱스 숫자 자체를 B가 가진 흔적의 양**으로 약속했습니다.
   - 즉, `dp[3]`에 접근한다는 것은 **"B의 흔적이 3인 상황"**을 보겠다는 뜻입니다.

2. **`dp[b]` (값) = A의 흔적**
   - 그 인덱스(`b`) 칸에 들어있는 값은 **그때 A가 가진 흔적**입니다.
   - 정확히는 A가 가질 수 있는 여러 흔적 중 **최솟값**입니다.

**결론**: `for b in range(m)` 루프 안에서 `dp[b]`를 읽는 순간,
- **B의 흔적은 `b`** (현재 인덱스이므로)
- **A의 흔적은 `dp[b]`** (거기에 적혀있는 값이므로)
가 성립합니다.

### Q&A
#### Q1. `dp[b]`는 "이전 턴"의 결과인가요?
**네, 맞습니다.**
반복문이 돌고 있는 시점에서 `dp[b]`는 **"직전 물건까지 처리가 끝난 상태"**입니다.
즉, **"저번까지 B가 `b`만큼 먹었을 때(인덱스), A는 최소 `dp[b]`만큼 먹은 상태였다"**는 기록을 불러와서, **"이번 물건"**을 더하는 계산을 시작하는 것입니다.

<br/>

#### Q2. 왜 하필 `B`를 인덱스로 썼나요? (A가 아니라)
**"A의 흔적을 최소화"하는 것이 목표이기 때문입니다.**
DP에서 **구하고 싶은 최적값(최소/최대)**은 보통 **값(Value)**으로 관리하는 것이 편합니다. (`min()` 함수를 쓰기 좋으니까요.)
- **목표**: A 흔적의 **최솟값** 구하기 -> **A를 값(Value)으로** 설정
- **남은 조건**: B 흔적 -> 자연스럽게 **인덱스(Key)로** 설정

(반대로 A를 인덱스로 잡고 B를 값으로 저장해도 풀리긴 하지만, 'A 최소화'라는 목적에는 A를 값으로 두는 게 더 직관적입니다.)

<br/>

#### Q3. 원래 질문: dp 의 사이즈를 `n`이 아니라 `m`으로 잡은 이유는?

`dp`의 크기를 A의 한계값 `n`이 아닌 **B의 한계값 `m`**으로 잡은 이유는, **"DP의 인덱스(Key)를 B의 흔적으로 사용하기 때문"**입니다.
-   **왜 B를 인덱스로 쓰는가?**:    
    -   이 문제는 **"배낭 문제"** 의 변형입니다. 보통 용량 제한이 있는 쪽을 배낭의 크기(인덱스)로 둡니다.
    -   A는 **"최소화해야 할 대상(목표)"**이고, B는 **"한계(`< m`)만 지키면 되는 제약 조건"**이기 때문입니다.
    -   따라서 **"B가 `b`만큼 흔적을 가질 때(인덱스), A의 흔적은 몇인가(값)?"** 형태로 DP를 설계하는 것이 효율적입니다.

-   **A를 인덱스로 쓰면 안 되나?**:   
    -   가능은 하지만, 문제에 따라 `m`이 `n`보다 작거나, 로직상 B를 기준으로 상태를 전이시키는 것이 더 직관적일 때 `m`을 사용합니다.
    -   무엇보다 **최종 정답이 A의 최솟값**을 구하는 것이므로, `dp` 배열의 값(Value) 자체를 A의 흔적 누적값으로 두는 것이 `min()` 함수를 써서 갱신하기 자연스럽습니다.

    -   `dp[b]` = **"B가 `b`만큼 흔적을 남겼을 때, A가 남긴 최소 흔적"**
    -   우리가 관심 있는 것은 B가 `0`부터 `m-1`까지 흔적을 남기는 상황뿐입니다.
    -   B가 `m` 이상의 흔적을 남기게 되는 상황은 '실패(잡힘)'이므로, 계산하거나 저장할 필요가 없습니다.

따라서 인덱스를 `0`부터 `m-1`까지만 사용하기 위해 크기를 `m`으로 설정합니다. (`b < m`인 경우만 유효)


#### Q4. `n`이 `m`의 범위 내에서 수행되도록 한 것의 원리를 설명하세요

`n`이 `m`을 기준으로 한 DP 테이블 내에서 어떻게 처리되는지, 즉 **"배낭 문제에서의 제약 조건 분리(Separation of Constraints)"** 원리를 설명해 드리겠습니다.

### 핵심 원리: 구조(Index)와 값(Value)의 역할 분담

이 풀이는 두 가지 제약 조건을 서로 다른 차원에서 처리합니다.

1.  **`m` (B의 한계) → 구조적 제약 (Index)**
    -   DP 테이블의 **인덱스**로 사용합니다.
    -   `dp` 배열의 크기를 `m`으로 고정함으로써, **B의 흔적이 `m`을 넘는 경우는 아예 저장 공간(상태)을 만들지 않습니다.**
    -   즉, 알고리즘이 돌아가는 **구조 자체**가 B의 한계를 넘지 못하도록 설계되어 있습니다.

2.  **`n` (A의 한계) → 값의 제약 (Value Filter)**
    -   DP 테이블에 저장되는 **값(Value)**으로 관리합니다.
    -   DP를 다 채운 후, 마지막에 **"값이 `n`보다 작은가?"**를 확인합니다.
    -   구조적으로 막는 것이 아니라, **계산된 결과값(`dp[b]`)이 `n` 미만인 것만 정답 후보로 인정**하는 방식입니다.

### 요약
-   **m**: DP의 **검색 범위(인덱스)**를 제한하여 물리적으로 범위를 넘지 못하게 함.
-   **n**: DP의 **결과값(Value)**을 검사하여 조건에 맞지 않는 답을 탈락시킴.

따라서 `n`과 `m`의 크기 관계는 중요하지 않으며, **m은 "탐색 공간의 크기"**를, **n은 "유효성 검사 기준"**을 담당하여 서로 독립적으로 작동합니다.

<br/>



#### Q5. A 도둑이 잡히는 최소값은 B 도둑이 잡히는 최소값 내로 좁혀서 찾는건가요?
네, 맞습니다!

**"A 도둑이 잡히는 최소값(흔적)은, B 도둑이 잡히지 않는(`m` 미만) 범위 내에서만 탐색"**하는 것이라고 이해하시면 정확합니다.

1.  **우리의 목표**: A의 흔적을 최소로 줄이는 것.
2.  **하지만 조건**: B의 흔적은 절대로 `m`을 넘으면 안 됨.

따라서 우리가 찾는 것은 **"B가 `0`~`m-1` 사이로 흔적을 남기는 모든 가능한 시나리오들 중에서, A의 흔적이 가장 작게 나오는 경우"**를 찾는 것입니다.

그래서 DP 테이블(`dp[b] = a_min_trace`)을 다 채운 뒤에, 마지막에 `dp` 배열 전체를 훑으면서 가장 작은 값을 찾는 것이죠. (단, `n` 미만인 것 중에서요!)

<br/>
<br/>


#### Q6. 배낭문제에서의 주요 개념들을 설명하고 이번 문제에서 사용된 개념에 대해 설명하세요
**1. 배낭 문제(Knapsack Problem)란?**
보통 배낭 문제는 이런 상황을 말해요.
> "내 배낭에는 **무게 제한(Limit)**이 있어. 그리고 훔칠 물건들은 각각 **무게(Weight)**와 **가치(Value)**가 다르지. 배낭이 터지지 않는 선에서 **가치가 가장 높게** 물건을 담으려면 어떻게 해야 할까?"

여기서 세 가지 키워드가 중요해요.
1.  **Item (물건)**: 내가 선택해야 할 대상들. (각각 무게와 가치를 가짐)
2.  **Capacity (용량 제한)**: 배낭이 견딜 수 있는 최대 무게. (이걸 넘으면 안 됨!)
3.  **Objective (목표)**: 어떤 가치를 최대화(또는 최소화)할 것인가.

<br/>

**2. 이번 "완전범죄" 문제와의 연결 ("역발상 배낭 문제")**
이 문제는 배낭 문제랑 아주 비슷하지만, 살짝 뒤틀려 있어요.

-   **물건 (Item)**: 우리가 훔쳐야 할 각 물건들. 
    -   A가 훔칠 때의 흔적(`INFO[i][0]`)과 B가 훔칠 때의 흔적(`INFO[i][1]`) 두 가지 속성을 동시에 가지고 있죠.
-   **용량 제한 (Capacity)**: **B의 흔적 한계(`m`)**.
    -   배낭 문제의 "무게 제한"과 똑같아요. B는 절대 `m`을 넘으면 안 되니까, 이게 바로 우리 배낭의 크기인 셈이죠.
-   **목표 (Objective)**: **A의 흔적을 "최소화"**.
    -   보통 배낭 문제는 "가치 최대화"인데, 여기서는 "흔적(비용) 최소화"가 목표예요.

<br/>

**3. 왜 이렇게 매칭했나요?**
자, 이제 우리가 DP 테이블을 짤 때 고민을 하게 돼요.
"A의 흔적(`n`)도 제한이 있고, B의 흔적(`m`)도 제한이 있는데 누굴 배낭 크기(인덱스)로 쓸까?"

여기서 **"배낭 문제의 철학"**을 빌려오는 거예요.
> "제한이 더 명확하고, '이걸 넘으면 절대 안 돼!'라고 하는 쪽을 **인덱스(배낭 크기)**로 삼자. 그리고 우리가 줄이고 싶거나 늘리고 싶은 '목표 값'은 **DP 테이블 안에 저장하는 값(Value)**으로 두자!"

그래서 이렇게 역할 분담이 된 거예요.
1.  **배낭 크기 (인덱스) = B의 흔적 (`m`)**: "B야, 넌 0부터 m-1까지만 딱 움직여. 그 이상은 안 돼." 라고 판을 깔아주는 거죠.
2.  **물건의 가치 (값) = A의 흔적**: "B가 이만큼 배낭을 채웠을 때, 그때 A의 흔적은 최소 얼마지?" 라고 계산해서 적어두는 거예요.

**결론적으로:**
이 문제는 "**B의 흔적이라는 무게**를 가진 물건들을 배낭(`m`)에 담으면서, **A의 흔적이라는 비용**을 최소화하는 배낭 문제"라고 보면 딱 맞습니다! 다만 마지막에 A의 흔적 합이 `n`보다 작은지 한 번 더 검사하는 과정이 추가된 것뿐이죠.





### Deep Dive: DP 사이즈와 인덱스 설계 상세
1.  **B의 한계**: B는 도둑 `B`가 남기는 흔적의 총합이 **`m` 미만**이어야 합니다. (즉, `m` 이상이면 경찰에 잡힘)
2.  **DP의 정의**:
    -   `dp[b]` = **"B가 `b`만큼 흔적을 남겼을 때, A가 남긴 최소 흔적"**
    -   우리가 관심 있는 것은 B가 `0`부터 `m-1`까지 흔적을 남기는 상황뿐입니다.
    -   B가 `m` 이상의 흔적을 남기게 되는 상황은 '실패(잡힘)'이므로, 계산하거나 저장할 필요가 없습니다.

따라서 인덱스를 `0`부터 `m-1`까지만 사용하기 위해 크기를 `m`으로 설정합니다. (`b < m`인 경우만 유효)


