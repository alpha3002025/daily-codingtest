<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>두 원 사이의 정수 쌍 시각화</title>
    <style>
        /* Modern Dark Theme & Reset */
        :root {
            --bg-color: #0f172a;
            --text-color: #e2e8f0;
            --accent-color: #38bdf8;
            --accent-glow: rgba(56, 189, 248, 0.3);
            --secondary-bg: #1e293b;
            --grid-color: #334155;
            --valid-point: #4ade80;
            --ghost-point: rgba(255, 255, 255, 0.15);
            --circle-stroke: #f472b6;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        h1 {
            margin-top: 1.5rem;
            font-weight: 300;
            letter-spacing: -0.025em;
            color: #fff;
        }

        .container {
            display: flex;
            gap: 2rem;
            padding: 1rem;
            flex-grow: 1;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 1200px;
        }

        canvas {
            background: var(--secondary-bg);
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.2);
            cursor: crosshair;
        }

        .controls {
            width: 320px;
            background: var(--secondary-bg);
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        label {
            font-size: 0.875rem;
            color: #94a3b8;
            display: flex;
            justify-content: space-between;
            font-weight: 500;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent-color);
        }

        .stats {
            margin-top: 0.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--grid-color);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.75rem;
            font-variant-numeric: tabular-nums;
            font-size: 0.95rem;
        }

        .formula {
            font-family: 'Fira Code', monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 0.75rem;
            border-radius: 8px;
            font-size: 0.8rem;
            line-height: 1.5;
            color: #cbd5e1;
            border: 1px solid var(--grid-color);
        }

        .highlight {
            color: var(--accent-color);
            font-weight: bold;
        }

        .hover-info {
            min-height: 1.5em;
            color: var(--accent-color);
            font-size: 0.9rem;
            margin-top: 0.5rem;
            font-weight: 500;
            text-align: center;
            background: rgba(56, 189, 248, 0.1);
            padding: 0.5rem;
            border-radius: 6px;
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
                gap: 1rem;
            }

            .controls {
                width: 90%;
                max-width: 500px;
            }

            canvas {
                max-width: 90%;
                height: auto;
                aspect-ratio: 1/1;
            }
        }
    </style>
</head>

<body>
    <h1>두 원 사이의 정수 쌍 시각화</h1>
    <div class="container">
        <canvas id="canvas" width="600" height="600"></canvas>
        <div class="controls">
            <div class="formula">
                <strong>Algorithm Logic:</strong><br>
                1. Loop x from 1 to r2<br>
                2. Max Y: floor(√(r2² - x²))<br>
                3. Min Y: ceil(√(r1² - x²)) <span style="opacity:0.6">(if x < r1 else 0)</span><br>
                        4. Count = (Max Y - Min Y + 1)<br>
                        5. Total = Sum * 4
            </div>

            <div class="control-group">
                <label>작은 원 반지름 (r1) <span id="val-r1" class="highlight">2</span></label>
                <input type="range" id="r1" min="1" max="15" value="2" step="1">
            </div>

            <div class="control-group">
                <label>큰 원 반지름 (r2) <span id="val-r2" class="highlight">4</span></label>
                <input type="range" id="r2" min="2" max="20" value="4" step="1">
            </div>

            <div class="stats">
                <div class="stat-item">
                    <span>1사분면 개수 (Σ):</span>
                    <span id="q1-sum" class="highlight">0</span>
                </div>
                <div class="stat-item">
                    <span>전체 정수 쌍 (*4):</span>
                    <span id="total-sum" style="color:#4ade80; font-weight:bold;">0</span>
                </div>
                <div id="hover-info" class="hover-info">
                    그래프 위에 마우스를 올려보세요
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const r1Input = document.getElementById('r1');
        const r2Input = document.getElementById('r2');
        const valR1 = document.getElementById('val-r1');
        const valR2 = document.getElementById('val-r2');
        const q1SumEl = document.getElementById('q1-sum');
        const totalSumEl = document.getElementById('total-sum');
        const hoverInfo = document.getElementById('hover-info');

        let r1 = 2;
        let r2 = 4;
        let scale = 20;
        let hoveredX = null;

        function updateValues() {
            r1 = parseInt(r1Input.value);
            r2 = parseInt(r2Input.value);

            if (r1 >= r2) {
                if (document.activeElement === r1Input) r2 = r1 + 1;
                else r1 = r2 - 1;
                r1 = Math.max(1, r1);
                r2 = Math.min(20, r2);
            }

            r1Input.value = r1;
            r2Input.value = r2;
            valR1.textContent = r1;
            valR2.textContent = r2;

            // Dynamic scaling
            const maxR = Math.max(r2, 5);
            scale = 280 / (maxR + 1);

            draw();
        }

        function toCanvas(x, y) {
            return {
                x: canvas.width / 2 + x * scale,
                y: canvas.height / 2 - y * scale
            };
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            // Grid
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 1;

            ctx.beginPath();
            ctx.moveTo(0, cy); ctx.lineTo(canvas.width, cy);
            ctx.moveTo(cx, 0); ctx.lineTo(cx, canvas.height);
            ctx.stroke();

            const limit = Math.ceil(canvas.width / 2 / scale);
            ctx.strokeStyle = 'rgba(51, 65, 85, 0.3)';
            ctx.beginPath();
            for (let i = 1; i <= limit; i++) {
                ctx.moveTo(cx + i * scale, 0); ctx.lineTo(cx + i * scale, canvas.height);
                ctx.moveTo(cx - i * scale, 0); ctx.lineTo(cx - i * scale, canvas.height);
                ctx.moveTo(0, cy - i * scale); ctx.lineTo(canvas.width, cy - i * scale);
                ctx.moveTo(0, cy + i * scale); ctx.lineTo(canvas.width, cy + i * scale);
            }
            ctx.stroke();

            // Circles
            // r2
            ctx.beginPath();
            ctx.arc(cx, cy, r2 * scale, 0, Math.PI * 2);
            ctx.strokeStyle = '#38bdf8';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = 'rgba(56, 189, 248, 0.08)';
            ctx.fill();

            // r1
            ctx.beginPath();
            ctx.arc(cx, cy, r1 * scale, 0, Math.PI * 2);
            ctx.strokeStyle = '#f472b6';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            ctx.arc(cx, cy, r1 * scale - 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            let totalQ1 = 0;

            for (let x = 1; x <= r2; x++) {
                const max_y = Math.floor(Math.sqrt(Math.pow(r2, 2) - Math.pow(x, 2)));

                let min_y = 0;
                if (x < r1) {
                    min_y = Math.ceil(Math.sqrt(Math.pow(r1, 2) - Math.pow(x, 2)));
                } else {
                    min_y = 0;
                }

                const count = max_y - min_y + 1;
                totalQ1 += count;

                const isHovered = (x === hoveredX);

                if (isHovered) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = scale;
                    ctx.beginPath();
                    ctx.moveTo(cx + x * scale, 0);
                    ctx.lineTo(cx + x * scale, canvas.height);
                    // Using a very wide line as a highlight strip instead of just a line
                    // Changed back to line for clarity or maybe a rect
                }

                // Draw points
                for (let y = 0; y <= max_y + 1; y++) {
                    const isValid = y >= min_y && y <= max_y;

                    if (isValid) {
                        drawPoint(x, y, true, isHovered);
                        drawPoint(-x, y, false, false, true);
                        drawPoint(-x, -y, false, false, true);
                        drawPoint(x, -y, false, false, true);
                    }
                }
            }

            q1SumEl.textContent = totalQ1;
            totalSumEl.textContent = totalQ1 * 4;
        }

        function drawPoint(x, y, isPrimary, isHovered, isGhost = false) {
            const pos = toCanvas(x, y);
            ctx.beginPath();

            const pointRadius = isHovered ? scale * 0.25 : scale * 0.15;
            const clampedRadius = Math.max(2, Math.min(pointRadius, 6));

            ctx.arc(pos.x, pos.y, isGhost ? 2 : clampedRadius, 0, Math.PI * 2);

            if (isGhost) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            } else {
                ctx.fillStyle = isHovered ? '#fff' : '#4ade80';
                if (isHovered) {
                    ctx.shadowColor = '#4ade80';
                    ctx.shadowBlur = 10;
                } else {
                    ctx.shadowBlur = 0;
                }
            }

            ctx.fill();
            ctx.shadowBlur = 0;
        }

        r1Input.addEventListener('input', updateValues);
        r2Input.addEventListener('input', updateValues);

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates to match canvas internal resolution vs css size
            // But here width/height are 1:1 usually.
            const scaleX = canvas.width / rect.width;
            const mouseX = (e.clientX - rect.left) * scaleX;

            const cx = canvas.width / 2;
            const rawX = (mouseX - cx) / scale;
            const roundedX = Math.round(rawX);

            if (roundedX >= 1 && roundedX <= r2) {
                if (hoveredX !== roundedX) {
                    hoveredX = roundedX;

                    const x = hoveredX;
                    const max_y = Math.floor(Math.sqrt(Math.pow(r2, 2) - Math.pow(x, 2)));
                    let min_y = 0;
                    if (x < r1) {
                        min_y = Math.ceil(Math.sqrt(Math.pow(r1, 2) - Math.pow(x, 2)));
                    }
                    const count = max_y - min_y + 1;

                    hoverInfo.innerHTML = `x = <span class="highlight">${x}</span> : y range [${min_y}, ${max_y}] (Count: ${count})`;
                    draw();
                }
            } else {
                if (hoveredX !== null) {
                    hoveredX = null;
                    hoverInfo.textContent = "그래프 위에 마우스를 올려보세요";
                    draw();
                }
            }
        });

        canvas.addEventListener('mouseleave', () => {
            hoveredX = null;
            hoverInfo.textContent = "그래프 위에 마우스를 올려보세요";
            draw();
        });

        updateValues();
    </script>
</body>

</html>