# 택배상자

## 문제 설명
메인 컨베이어 벨트에 1번부터 n번까지 순서대로 상자가 옵니다.
기사님이 원하는 순서(`order`)대로 상자를 트럭에 실어야 합니다.
순서에 맞지 않는 상자는 보조 컨베이어 벨트(스택, Stack)에 보관할 수 있습니다.
몇 개의 상자를 실을 수 있는지 구합니다.

## 풀이 개념
**스택 (Stack)** 자료구조를 사용하는 시뮬레이션 문제입니다.
보조 벨트는 맨 앞(마지막에 넣은 것)만 꺼낼 수 있으므로 LIFO(Stack) 구조입니다.

1. 메인 벨트의 현재 박스 번호 `idx`를 1로 초기화합니다.
2. `order` 리스트를 순회하며 현재 목표(target) 상자를 확인합니다.
3. 루프를 돌며 트럭에 실을 수 있는지 확인합니다:
   - **Case 1**: 메인 벨트의 현재 상자(`idx`)가 목표 상자(`target`)라면?
     - 바로 트럭에 싣습니다 (`idx` 증가, 다음 target으로).
   - **Case 2**: 보조 벨트(스택)의 맨 위 상자가 목표 상자라면?
     - 스택에서 꺼내 트럭에 싣습니다 (다음 target으로).
   - **Case 3**: 둘 다 아니라면?
     - 메인 벨트의 상자를 보조 벨트(스택)에 보관합니다 (`idx` 증가).
     - 주의: 메인 벨트 상자(`idx`)가 목표 상자보다 커져버리면(이미 지나갔으면) 더 이상 기회는 없으므로 종료합니다.
     - 혹은 `while`문으로 `idx <= target` 일 때까지 스택에 넣고, 그 후 스택 top을 확인하는 로직으로 구현할 수도 있습니다.

## 코드 (Python)

```python
def solution(order):
    stack = [] # 보조 컨베이어 벨트
    idx = 1
    n = len(order)
    loaded_count = 0
    
    for target in order:
        # 현재 메인 벨트 박스 번호가 타겟보다 작거나 같으면,
        # 타겟이 나올 때까지 스택에 넣음
        while idx <= target:
            stack.append(idx)
            idx += 1
            
        # 스택의 맨 위가 타겟과 일치하면 적재
        if stack and stack[-1] == target:
            stack.pop()
            loaded_count += 1
        else:
            # 스택 맨 위도 아니고, 메인 벨트도 이미 지나갔으면 더 이상 진행 불가
            break
            
    return loaded_count
```
