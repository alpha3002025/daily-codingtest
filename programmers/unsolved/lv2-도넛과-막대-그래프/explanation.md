# 도넛과 막대 그래프

## 문제 설명
한 정점(생성된 정점)에서 시작하여 여러 개의 그래프로 나가는 간선들이 추가된 형태의 그래프가 주어집니다.
그래프의 종류는 3가지입니다:
1. **도넛 모양**: `n`개 정점, `n`개 간선. 단순 사이클. (모든 정점 in=1, out=1)
2. **막대 모양**: `n`개 정점, `n-1`개 간선. 선형. (시작: out=1, 중간: out=1, 끝: in=1/out=0)
   - 핵심 특징: 끝 정점은 들어오는 것만 있고 나가는 것이 없음 (`out=0`). (단, 1개 정점일 경우 in=0, out=0일 수 있으나 생성 정점에서 연결되므로 in>=1).
3. **8자 모양**: `2n+1`개 정점, `2n+2`개 간선. 2개의 도넛이 한 점(중심)을 공유.
   - 핵심 특징: 중심 정점은 `in>=2, out=2`. 나머지 정점은 도넛과 같음.

생성된 정점의 번호와, 도넛, 막대, 8자 그래프의 개수를 구하는 문제입니다.

## 풀이 개념
그래프 탐색을 하지 않고 **정점의 진입/진출 차수(In/Out Degree)** 만으로 판별할 수 있습니다.

1. **생성된 정점 찾기**:
   - 이 정점은 그래프들을 연결하기 위해 생성되었으므로, **들어오는 간선(In)이 없고(0)**, **나가는 간선(Out)이 2개 이상**이어야 합니다.
   - `In == 0`이고 `Out >= 2`인 정점을 찾습니다.
   - 단, 전체 그래프 개수가 2개 미만일 수도 있지만 문제 특성상 `Out`이 가장 많은 `In=0` 정점을 찾으면 됩니다. 보통 `Out >= 2`가 보장됩니다.
   
2. **그래프 개수 파악**:
   - 생성된 정점의 `Out` 차수 = **총 그래프의 개수**입니다.

3. **각 그래프 모양 판별**:
   - 생성된 정점을 제외하고 나머지 정점들의 차수를 봅니다.
   - **막대 그래프**: 구성원 중 `Out == 0`인 정점(끝점)이 반드시 하나 존재합니다.
     - 따라서 전체에서 `Out == 0`인 정점의 개수 = 막대 그래프의 개수.
   - **8자 그래프**: 구성원 중 중심 정점은 `Out == 2`이고 `In >= 2`입니다.
     - 도넛 그래프의 정점들은 모두 `Out=1`.
     - 막대 그래프의 정점들은 `Out=1` 혹은 `0`.
     - 따라서 `Out == 2`인 정점의 개수 = 8자 그래프의 개수.
   - **도넛 그래프**: 
     - `총 그래프 수 - (막대 개수 + 8자 개수)`

## 코드 (Python)

```python
def solution(edges):
    # 정점별 차수 계산 (key: node, value: [in, out])
    degree = {}
    
    for u, v in edges:
        if u not in degree: degree[u] = [0, 0]
        if v not in degree: degree[v] = [0, 0]
        
        degree[u][1] += 1 # out
        degree[v][0] += 1 # in
        
    created_node = 0
    donut_cnt = 0
    bar_cnt = 0
    eight_cnt = 0
    
    # 1. 생성된 정점 찾기
    # in = 0, out >= 2
    # 예외) 그래프가 1개일 경우 out=1일 수도 있음. 
    # 하지만 생성 정점은 반드시 in=0이며 그래프들로 연결함.
    # in=0인 노드 중 out이 가장 큰 것을 선택하거나 보편적 기준 사용.
    # 문제에서 그래프 수는 2개 이상이라 명시. 따라서 out >= 2.
    
    for node, (in_d, out_d) in degree.items():
        if in_d == 0 and out_d >= 2:
            created_node = node
            break
            
    total_graphs = degree[created_node][1]
    
    # 2. 나머지 정점들로 모양 판별
    # 생성된 정점을 제외하고 순회
    for node, (in_d, out_d) in degree.items():
        if node == created_node:
            continue
            
        # 막대 그래프 탐지: Out이 0인 정점 수
        if out_d == 0:
            bar_cnt += 1
            
        # 8자 그래프 탐지: Out이 2인 정점 수
        # (중심점은 반드시 out=2. in은 생성정점 연결 여부에 따라 다름)
        elif out_d == 2:
            eight_cnt += 1
            
    # 도넛 그래프 = 전체 - 나머지
    donut_cnt = total_graphs - bar_cnt - eight_cnt
    
    return [created_node, donut_cnt, bar_cnt, eight_cnt]
```
