# 공 이동 시뮬레이션

## 문제 설명
$N \times M$ 격자에 공이 하나 있습니다.
여러 쿼리(방향, 거리)에 따라 공을 이동시킵니다.
만약 공이 벽에 부딪히면 멈춥니다(이동 거리가 남았어도).
모든 쿼리를 수행한 후 결과 위치가 `(x, y)`인 **초기 시작 위치들의 개수**를 구하세요.
$N, M$은 최대 $10^9$, 쿼리는 최대 20만 개.

## 문제 해결 전략

$N, M$이 매우 크므로 모든 칸에 대해 시뮬레이션할 수 없습니다.
**역방향 추적(Reverse Simulation)**을 사용합니다.
도착 지점 `(x, y)`로 올 수 있는 "가능한 시작점의 범위(직사각형)"를 유지하며 쿼리를 거꾸로 실행합니다.
현재 가능한 범위가 `[r_min, r_max]`, `[c_min, c_max]`라고 합시다. (도착 시점엔 `x, x`, `y, y`)

쿼리가 "왼쪽으로 $dx$ 이동"이었다면, 역으로 생각하면 "오른쪽으로 $dx$ 이동"해서 현재 범위에 들어와야 합니다.
- **이동**: 범위 `[left, right]` -> `[left + dx, right + dx]`
- **벽 처리(중요)**:
  - 정방향에서 왼쪽 벽(0)에 부딪혀서 멈춘 경우들이 있음.
  - 역방향에서, 현재 범위의 왼쪽 끝(`c_min`)이 벽(0)이라면?
    - 이는 정방향 시뮬레이션 때 0으로 몰렸던 모든 애들이 후보가 된다는 뜻.
    - 따라서, 정방향 쿼리가 "왼쪽($dL$)" 이동이었는데 역추적 중 현재 범위가 왼쪽 벽에 닿아 있다면, 이전 범위의 왼쪽 끝(`prev_c_min`)은 $0$부터 가능하게 확장됨. (`c_min`은 $0$ 그대로 유지, `c_max`는 $c_max + dx$)
  - 벽이 아니라면 단순히 평행이동.
  - 범위가 격자를 벗어나면 잘라냄.
  - 범위가 유효하지 않게 되면(min > max), 답은 0.

## Python 코드

```python
def solution(n, m, x, y, queries):
    # 가능한 시작점 범위 (행, 열)
    # [r1, r2], [c1, c2] (inclusive)
    r1, r2 = x, x
    c1, c2 = y, y
    
    # 쿼리 역순 순회
    for command, dx in reversed(queries):
        # 0: 좌, 1: 우, 2: 상, 3: 하
        
        # 역방향:
        # 0(좌) -> 우로 이동해야 함
        if command == 0: 
            # 정방향이 왼쪽 이동이었음.
            # 역으로 오른쪽으로 이동시켜서 범위를 찾음.
            if c1 != 0: 
                c1 += dx
            # c1 == 0 이면, 정방향 때 벽에 막혀서 0이 된 애들도 포함되므로 
            # 역방향에선 min 범위를 늘릴 필요 없음 (그대로 0 유지).
            # 단, max 범위는 무조건 이동해야 함.
            c2 = min(m - 1, c2 + dx)
            
            if c1 > m - 1: return 0 # 범위가 맵 밖으로 나감
            
        elif command == 1: # 우 -> 좌
            if c2 != m - 1:
                c2 -= dx
            c1 = max(0, c1 - dx)
            if c2 < 0: return 0
            
        elif command == 2: # 상 -> 하
            if r1 != 0:
                r1 += dx
            r2 = min(n - 1, r2 + dx)
            if r1 > n - 1: return 0
            
        elif command == 3: # 하 -> 상
            if r2 != n - 1:
                r2 -= dx
            r1 = max(0, r1 - dx)
            if r2 < 0: return 0
            
    return (r2 - r1 + 1) * (c2 - c1 + 1)
```
