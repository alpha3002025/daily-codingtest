# 인사고과

## 문제 설명
회사의 인센티브 지급 조건을 따져서, '완호'가 몇 등인지 구하는 문제입니다.
- 각 사원은 (근무 태도 점수, 동료 평가 점수)를 가집니다.
- 만약 어떤 사원 A가 다른 사원 B보다 두 점수 모두 낮다면, A는 인센티브를 받지 못합니다. (탈락)
- 인센티브를 받는 사원들끼리는 두 점수의 합으로 석차를 매깁니다. 동점자가 있으면 공동 등수가 되며, 다음 등수는 건너뜁니다.
- 완호의 등수를 반환하세요. 완호가 인센티브를 못 받으면 -1을 반환합니다.

## 문제 해결 전략

$N$이 최대 10만이라 $O(N^2)$ 비교는 불가능합니다. **정렬(Sorting)**을 이용하여 효율적으로 필터링해야 합니다.

1. **정렬 기준**:
   - 근무 태도 점수(내림차순)
   - 동료 평가 점수(오름차순) -> 왜?
   - 근무 태도가 같은데 동료 평가가 더 높은 사람이 앞에 오면, 뒤에 있는 사람은 두 점수가 "모두 낮은" 경우가 발생하지 않게 하기 위함입니다. (근무 태도 같음, 동료 평가 높음) -> 탈락 아님.
   - 반면 근무 태도가 더 높은 사람과 비교할 때는 동료 평가만 비교하면 됩니다.

2. **탈락 여부 판별**:
   - 근무 태도 내림차순 정렬 상태이므로, 앞사람은 뒷사람보다 근무 태도 점수가 크거나 같습니다.
   - 따라서 뒷사람이 탈락하려면, **앞선 사람들 중 누군가보다 동료 평가 점수가 작으면** 됩니다.
   - 이를 위해 순회하면서 "지금까지 만난 사람들의 최대 동료 평가 점수"(`max_peer_score`)를 유지합니다.
   - 현재 사원의 동료 평가 점수가 `max_peer_score`보다 작다면, 근무 태도는 이미 작거나 같은데 동료 평가도 작은 것이므로 탈락입니다.
   - 단, 근무 태도가 같은 경우는 정렬 기준(동료 평가 오름차순) 때문에 현재 사원이 `max_peer_score`보다 작을 일이 없습니다. (작거나 같은 그룹 내에서는 뒤로 갈수록 커지므로) -> 잘못 이해했습니다.
   - **다시 정렬 기준**: 근무 태도 내림차순, 동료 평가 **오름차순**.
   - 예: (7, 2), (7, 3), (7, 5) ... -> 뒤로 갈수록 동료 평가 커짐. 앞사람보다 근무 태도 동일, 동료 평가 큼 -> 탈락 X.
   - 예: 이전 그룹 (8, 5) 가 있었음. `max_peer`=5. (7, 2)는 8>7, 5>2 이므로 탈락. (7, 6)은 8>7이지만 5<6이므로 생존.
   - 즉, 정렬 덕분에 근무 태도는 항상 작거나 같음이 보장되므로, "동료 평가 점수"만 이전 최대값(`max_peer`)보다 작은지 확인하면 됩니다.

3. **완호의 등수 계산**:
   - 완호가 탈락하는지 먼저 확인합니다.
   - 살아남은 사람들 중, 완호보다 총합이 큰 사람 수를 셉니다. `등수 = (완호보다 총합 큰 사람 수) + 1`

## Python 코드

```python
def solution(scores):
    # 완호 점수
    wanho = scores[0]
    wanho_sum = sum(wanho)
    
    # 정렬: 근무 태도 내림차순, 동료 평가 오름차순
    # scores를 순회하면서 필터링할 것이므로 완호가 포함된 상태로 정렬해도 되지만, 
    # 완호가 탈락했는지는 별도 로직이나 순회 중 확인 필요.
    scores.sort(key=lambda x: (-x[0], x[1]))
    
    max_peer_score = 0
    rank = 1
    
    for score in scores:
        work, peer = score
        
        # 탈락 조건: 내 동료 평가 점수가 앞사람(들)의 최대 동료 평가 점수보다 낮으면 탈락
        # (근무 태도는 이미 정렬에 의해 앞사람보다 작거나 같음)
        # (근무 태도가 같은 경우는 동료 평가 오름차순 정렬했으므로 뒤쪽이 더 큼 -> 탈락 안 함)
        if peer < max_peer_score:
            # 완호인지 확인
            if score == wanho:
                return -1
        else:
            # 생존
            max_peer_score = max(max_peer_score, peer) # 최대값 갱신
            
            # 등수 계산: 완호보다 총점이 높은 경우
            if work + peer > wanho_sum:
                rank += 1
                
    return rank
```
