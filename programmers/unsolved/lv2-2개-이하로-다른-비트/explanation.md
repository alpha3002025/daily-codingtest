# 2개 이하로 다른 비트

## 문제 설명
양의 정수 `x`에 대해, `x`보다 크고 `x`와 비트(Binary Bit)가 1~2개 다른 수들 중에서 제일 작은 수를 구하는 문제입니다. 모든 `numbers` 배열의 수에 대해 이 값을 구해 반환해야 합니다.

### 핵심 개념
1.  **비트 마스킹 / 규칙 찾기**: $x$보다 크면서 비트 차이가 최소인 수를 찾아야 합니다. 단순히 1씩 더해가며 비교하면 시간 초과가 발생합니다 (최대 $10^{15}$). $O(1)$ 규칙을 찾아야 합니다.
2.  **짝수(Even)**: 2진수로 끝이 `0`입니다. (`...10`, `...00`). 제일 마지막 비트(`0`)를 `1`로 바꾸면 됩니다. 이는 단순히 `x + 1`과 같습니다. (비트 1개 차이)
3.  **홀수(Odd)**: 2진수로 끝이 `1`입니다. (`...0111`).
    - $x$보다 크면서 가장 작은 수는, 가장 낮은 자리에 있는 `0`을 `1`로 바꾸고, 그 바로 다음(오른쪽)의 `1`을 `0`으로 바꾸는 것입니다.
    - 예: `0111` ($7$) -> `1011` ($11$) : `0`을 `1`로(`1111`), 그리고 그 다음 비트(`1`)를 `0`으로(`1011`). 차이점 2개.
    - 예: `1001` ($9$) -> `1010` ($10$) : 가장 뒤의 `0`(`10`**`0`**`1`)을 `1`로. (이 경우는 그냥 +1과 같음? 아님. 뒤에 1들이 연속된 경우를 봐야 함)
    - 일반화: **가장 낮은 자리의 `0`을 `1`로 바꾸고, 그보다 한 칸 낮은 자리의 `1`을 `0`으로 바꾼다.**

## Python 풀이

```python
def solution(numbers):
    answer = []
    
    for number in numbers:
        if number % 2 == 0:
            # 짝수: 맨 마지막 비트가 0이므로 1로 바꾸면 됨 -> number + 1
            answer.append(number + 1)
        else:
            # 홀수: 가장 낮은 0 을 찾아서 1로, 그 다음(오른쪽) 비트를 0으로
            # 예: 0111 (7) -> 가장 낮은 0은 4번째 비트 (값 8 자리)
            # '0'111 -> '1'111 -> 1'0'11 (11)
            
            bin_str = '0' + bin(number)[2:] # 앞에 0 하나 붙여줌 (모두 1인 경우 대비)
            
            # 오른쪽에서부터 처음 등장하는 '0'의 인덱스 찾기
            idx = bin_str.rfind('0')
            
            # idx 위치는 '1'로, idx+1 위치는 '0'으로 변경
            # list로 변환하여 수정
            bin_list = list(bin_str)
            bin_list[idx] = '1'
            bin_list[idx+1] = '0'
            
            # 다시 정수로 변환
            answer.append(int("".join(bin_list), 2))
            
    return answer
```

### 코드 설명
- **짝수 처리**: 짝수 $x$의 마지막 비트는 0입니다. 이를 1로 바꾸면 $x+1$이 되고 비트는 1개만 다릅니다. 이것이 $x$보다 큰 수 중 가장 작습니다.
- **홀수 처리**:
    - 비트열의 가장 뒤쪽(LSB)부터 연속된 1들이 있습니다.
    - 예: `xx011...1` 형태.
    - $x$보다 크면서 변형을 최소화하려면, 가장 낮은 `0`을 `1`로 바꿔 값을 키우고(`xx111...1`), 증가분을 최소화하기 위해 바로 뒤의 `1`을 `0`으로 깎습니다(`xx101...1`).
    - Python의 `bin()` 함수는 `0b` 접두사가 붙으므로 슬라이싱`[2:]`하고, 비트가 모두 1인 경우(예: `111`)를 대비해 앞에 `0`을 하나 붙여줍니다(`0111`).
    - `rfind('0')`: 오른쪽에서부터 0을 찾습니다.
    - 찾은 0을 1로, 그 바로 뒤(오른쪽) 문자(`idx+1`)를 0으로 바꿉니다.

### 비트 연산 활용 풀이 (심화)
문자열 변환 없이 비트 연산으로도 가능합니다.
- `number`와 `number + 1`을 XOR 등을 이용...하기엔 복잡할 수 있으나, 규칙은 다음과 같습니다:
- `~number & (number + 1)` : 가장 오른쪽의 연속된 1 블록 바로 위의 0 비트 위치(Lowest Zero Bit)를 찾을 수 있습니다.

```python
def solution_bitwise(numbers):
    answer = []
    for num in numbers:
        if num % 2 == 0:
            answer.append(num + 1)
        else:
            # 가장 오른쪽 0 찾기 (비트가 0인 지점 중 최하위)
            # n이 ...0111 이면 ~n은 ...1000
            # n+1은 ...1000
            # (num ^ (num + 1)) >> 2  를 이용해 더해야 할 값을 찾음
            # 공식: num + (lowest_zero_bit) - (lowest_zero_bit >> 1)
            
            # 가장 낮은 0비트를 1로 만드는 값 (예: 0111 -> 8)
            # (num + 1) & - (num + 1) 은 num이 짝수일 때만 유효...
            # 홀수일 때:
            # num ^ (num + 1) => 연속된 1들이 전부 1로 변하고 그 위 0도 1로 변한 값?
            # ex: 7(0111) + 1 = 8(1000). 7^8 = 1111(15). 
            # (XOR값 + 1) >> 2 만큼 더해주면 됨.
            # 16 >> 2 = 4. 7 + 4 = 11. 정답.
            
            answer.append(num + ((num ^ (num + 1)) >> 2) + 1)   
    return answer
```
비트 연산 공식은 직관적이지 않으므로 문자열 방식이 이해하기엔 훨씬 좋습니다.<br/>
<br/>


# 문법 관련 
## `int(문자열, 2)`
`int(문자열, 2)` : 이진수 형태의 문자열을 10진수 정수로 변환하는 함수입니다.<br/>
<br/>


- 문법: int(x, base)는 base 진수로 표현된 문자열 x를 10진수로 바꿉니다.
- 동작: 문자열 "1011"을 2진수로 해석하여 계산합니다. ($1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2^0$)
- 결과: "1011" -> 11 (10진수)

<br/>
