# 마법의 엘리베이터
손으로 직접 써봐야 이해가 간다. 아래는 직접 손으로 써본 각각의 경우들이다.
```plain
5 초과 (lsb > 5):
  e.g. 6,7,8,9 : 1을 6번,7번,8번,9번 써야 하는 수
  차라리 10을 올린후 10 에서부터 내려오는게 빠르다. (다음 턴에서 10부터 내려오도록 세팅)
  storey += 10
  answer += 10-lsb

5 일때 (조건부 계산, lsb == 5): 
  answer += 5(=lsb) ## 1 을 다섯번 쓰되 
  그 앞자리가 5 이상일 경우 에는 10층을 올려서 다음 턴에서 10에서부터 내려오도록 세팅 

5 미만 (lsb < 5):
  e.g. 1,2,3,4 : 1을 1번,2번,3번,4번 쓰는게 나은 경우
  answer += lsb
```
<br/>

## link
- https://school.programmers.co.kr/learn/courses/30/lessons/148653


## 문제 설명
마법의 엘리베이터가 있는 층 `storey`가 주어집니다.
버튼은 10^c (c >= 0) 형태의 정수들이 적혀있으며, `+` 또는 `-` 버튼을 누르면 해당 값만큼 층이 이동합니다.
0층으로 이동하기 위해 필요한 버튼 누름의 최소 횟수를 구하는 문제입니다.

## 풀이 개념
**그리디 알고리즘**과 **재귀** 또는 반복문을 사용합니다.
각 자릿수(일의 자리부터)를 0으로 만들기 위해 "내림(버림)"을 할지 "올림"을 할지 결정해야 합니다.
목표는 현재 자릿수를 0으로 만들면서, 필요하다면 윗자리에 영향을 주어 전체 횟수를 최소화하는 것입니다.

1. 일의 자리 숫자 `d`를 봅니다.
2. `d < 5`: 내리는 것이 이득입니다. 횟수에 `d`를 더하고, 윗자리로 넘어갑니다.
3. `d > 5`: 올리는 것이 이득입니다. 횟수에 `10 - d`를 더하고, 윗자리(`storey // 10`)에 1을 더해줍니다(올림 발생).
4. `d == 5`: 
   - 다음 자릿수(십의 자리)를 확인해야 합니다.
   - 다음 자릿수가 5 이상이라면 (`>= 5`) 현재를 올려서 다음 자릿수도 올림 효과를 받게 하는 것이 유리합니다. (예: 55 -> 60 -> 100).
   - 다음 자릿수가 5 미만이라면 (`< 5`) 현재를 내려서 그냥 없애는 것이 유리합니다. (예: 45 -> 40).
   
이 과정을 `storey`가 0이 될 때까지 반복합니다.

## 코드 (Python)

```python
def solution(sto의rey):
    answer = 0
    
    while storey > 0:
        digit = storey % 10
        next_digit = (storey // 10) % 10
        
        if digit > 5:
            answer += (10 - digit)
            storey += 10 # 윗자리 올림
        elif digit == 5:
            answer += 5
            # 5일 때는 앞자리가 5 이상이면 올리는게 이득 (연쇄 올림 가능성)
            if next_digit >= 5:
                storey += 10
        else:
            answer += digit
            
        storey //= 10
        
    return answer
```

## 나의 설명
e.g.
```plain
5 초과 (lsb > 5):
  e.g. 6,7,8,9 : 1을 6번,7번,8번,9번 써야 하는 수
  차라리 10을 올린후 10 에서부터 내려오는게 빠르다. (다음 턴에서 10부터 내려오도록 세팅)
  storey += 10
  answer += 10-lsb

5 일때 (조건부 계산, lsb == 5): 
  answer += 5(=lsb) ## 1 을 다섯번 쓰되 
  그 앞자리가 5 이상일 경우 에는 10층을 올려서 다음 턴에서 10에서부터 내려오도록 세팅 

5 미만 (lsb < 5):
  e.g. 1,2,3,4 : 1을 1번,2번,3번,4번 쓰는게 나은 경우
  answer += lsb
```
<br/>


## 핵심 원리 (반올림)
이 문제는 본질적으로 **"최소한의 버튼 조작으로 0을 만들기 위해, 각 자릿수에서 반올림(Round)을 할 것인가 말 것인가?"**를 묻는 문제입니다.

- `1~4`: 반할(내림)하는 게 이득 (예: 24 -> 20. 4번)
- `6~9`: 반올림(올림)하는 게 이득 (예: 26 -> 30. 4번 + 윗자리 부담)
- `5`: **결정의 순간**. 5를 0으로 내리는 비용(5번)과 10으로 올리는 비용(5번)이 같습니다.
  - 이때는 **"다음 자릿수(윗자리)가 5 이상인가?"**를 보고 결정합니다.
  - 윗자리가 크다면(5, 6, 7...), 지금 올려줘서 윗자리도 같이 10쪽으로 밀어주는 게 연쇄적으로 이득(`...55` -> `...60` -> `...100`)을 줄 확률이 높기 때문입니다.

**예시 상세 분석**:

1. **Case: 45 (앞자리가 5 미만)**
    - **내림 선택**: `45` $\rightarrow$ (-5) $\rightarrow$ `40` $\rightarrow$ (-40) $\rightarrow$ `0`
        - 비용: $5 + 4 = 9$
    - **올림 선택**: `45` $\rightarrow$ (+5) $\rightarrow$ `50` $\rightarrow$ (+50) $\rightarrow$ `100` $\rightarrow$ (-100) $\rightarrow$ `0`
        - 비용: $5 + 5 + 1 = 11$
    - **결론**: 내림이 이득 ($9 < 11$)

2. **Case: 55 (앞자리가 5 이상)**
    - **내림 선택**: `55` $\rightarrow$ (-5) $\rightarrow$ `50` $\rightarrow$ (+50) $\rightarrow$ `100` $\rightarrow$ `0`
        - 비용: $5 + 5 + 1 = 11$
    - **올림 선택**: `55` $\rightarrow$ (+5) $\rightarrow$ `60`
        - 이제 `60`에서 6은 5보다 크므로 올림 선택: `60` $\rightarrow$ (+40) $\rightarrow$ `100` $\rightarrow$ (-100) $\rightarrow$ `0`
        - 비용: $5 + 4 + 1 = 10$
    - **결론**: 올림이 이득 ($10 < 11$). 여기서 핵심은 **일의 자리에서 올려서 십의 자리를 6으로 만듦으로써, 십의 자리에서도 올림 전략을 쓰게 유도**한 점입니다.

3. **Case: 95**
    - **올림 선택**: `95` $\rightarrow$ (+5) $\rightarrow$ `100` $\rightarrow$ (-100) $\rightarrow$ `0`
        - 비용: $5 + 1 = 6$
    - **내림 선택**: `95` $\rightarrow$ (-5) $\rightarrow$ `90` $\rightarrow$ (+10) $\rightarrow$ `100` $\rightarrow$ `1` (비효율적)
        - 비용: $5 + 1 + 1 = 7$ (혹은 90에서 9번 내려서 14번)
    - **결론**: 올림이 이득 ($6 < 14$)




### 코드 (재귀 방식)
DFS 형태의 완전 탐색(또는 재귀적 그리디)으로도 풀 수 있습니다. 각 자릿수에서 **내림**을 선택한 경우와 **올림**을 선택한 경우 중 최솟값을 반환합니다.

```python
def solution(storey):
    # Base Case: 1자리 수일 때
    if storey < 10:
        # min(그냥 내리기, 10으로 올려서 한 번 더 누르기)
        # 예: 6 -> 4번(올림+10처리) vs 6번(내림) -> 4번 선택
        return min(storey, 10 - storey + 1)
    
    digit = storey % 10
    
    # 1. 내림 선택 (나머지만큼 누르고, 윗자리는 그대로)
    down = digit + solution(storey // 10)
    
    # 2. 올림 선택 (10-나머지만큼 누르고, 윗자리 +1)
    up = (10 - digit) + solution(storey // 10 + 1)
    
    return min(down, up)
```

**재귀 방식 설명**:
- `down`: 현재 자리를 0으로 내리는 경우입니다. 비용은 `digit`만큼 들고, 윗자리는 `storey // 10` 상태로 재귀 호출합니다.
- `up`: 현재 자리를 0으로 올리는(10으로 만드는) 경우입니다. 비용은 `10 - digit`만큼 들고, 윗자리는 하나 증가된 상태(`storey // 10 + 1`)로 재귀 호출합니다.
- Base Case(`storey < 10`)에서 `min(storey, 10 - storey + 1)`을 통해 마지막 자리를 처리합니다. (`+1`은 10이 되었을 때 1번 눌러 제거하는 비용)


