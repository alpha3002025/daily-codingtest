# 억억단을 외우자

## 문제 설명
영재는 억억단을 외웁니다. 억억단은 1억 x 1억 크기의 행렬인데, `map[i][j] = i * j`입니다.
이 문제는, "주어진 숫자 `e` 이하의 수들 중에서, 가장 많이 등장하는 수(`appear_cnt`가 최대인 수)를 구하라"는 문제입니다.
단, `starts` 리스트에 있는 각 `s`에 대해, `s <= x <= e` 범위 내에서 등장 횟수가 최대인 `x`를 각각 찾아야 합니다.
등장 횟수가 같다면 가장 작은 수를 선택합니다.

## 문제 해결 전략

1. **등장 횟수의 의미**: 억억단에서 숫자 $N = a \times b$ 형태로 등장하는 횟수는 곧 $N$의 **약수의 개수**와 같습니다. (단, 억억단의 범위가 무한하지 않다면 제약이 있겠지만, 문제에서의 범위 $e \le 5,000,000$이고 $i, j$가 $e$까지 가능하므로, 그냥 약수의 개수로 간주해도 무방합니다. 500만 x 500만이 아니라 곱해서 $e$ 이하인 경우만 따지면 되니까요. $a \times b \le e$ 조건에서 $a, b$는 최대 $e$이므로 억억단 행렬 인덱스 범위를 벗어나지 않습니다.)

2. **약수의 개수 구하기**:
   $e$가 최대 500만이므로, 각 수마다 약수의 개수를 구하면 오래 걸립니다.
   **에라토스테네스의 체**와 유사한 방식으로, $1$부터 $e$까지 순회하며 배수들에게 카운트를 더해주는 방식으로 $O(e \log e)$에 모든 수의 약수 개수를 구할 수 있습니다.

3. **구간 내 최대 등장 횟수 찾기**:
   - `starts` 배열의 원소 개수가 많으므로(최대 10만), 매번 `s`부터 `e`까지 순회하며 최대값을 찾으면 $O(100,000 \times 5,000,000)$으로 시간 초과가 납니다.
   - 따라서 **DP(역방향 탐색)** 또는 **최댓값 미리 구하기**를 사용합니다.
   - $x$부터 $e$까지의 구간에서 약수 개수가 가장 많은 숫자 `max_pos[x]`를 미리 계산해둡니다.
   - $x$를 $e$부터 1까지 감소시키면서:
     - `if count[x] >= count[max_pos[x+1]]: max_pos[x] = x`
     - `else: max_pos[x] = max_pos[x+1]`
     - (등호가 들어가는 이유: 등장 횟수가 같으면 작은 수가 답이므로, 현재 $x$가 이전 최적값보다 작으니 갱신)

## Python 코드

```python
def solution(e, starts):
    # 1. 1부터 e까지 각 숫자의 약수의 개수(count) 구하기
    # O(e log e)
    count = [0] * (e + 1)
    
    for i in range(1, e + 1):
        if i * i > e: # 최적화: i의 배수가 시작하는 i*i가 e를 넘으면 루프 종료? 아니, i가 1부터 e까지 돌아야 함. i*j 방식?
            # 일반적인 방식:
            # for j in range(i, e+1, i):
            #    count[j] += 1
            # 이렇게 하면 i=1일 때 e번, i=2일 때 e/2번 ... -> e log e
            break
            
        # 아래 방식은 i를 약수로 가지는 수들을 찾는 것
        # i*i 이전은 대칭성으로 이미 카운트되었으므로 중복 방지?
        # 아니, 그냥 단순 loop이 낫다.
        pass
        
    # Python에서 단순 이중 루프는 느릴 수 있음.
    # 1차원 순회가 빠름.
    
    for i in range(1, e + 1):
        for j in range(i, e + 1, i):
            count[j] += 1
            
    # 위 코드도 e가 5,000,000이면 약 7~8천만 연산이라 파이썬에서 아슬아슬할 수 있음.
    # 하지만 통과 가능.
    
    # 2. DP로 x ~ e 구간의 최빈값(약수 개수 최대인 수) 미리 계산
    # max_num[i]: i부터 e까지 중 약수 개수가 가장 많은 수 (같으면 작은 수)
    
    max_num = [0] * (e + 1)
    
    # 뒤에서부터 채우기
    # 초기값: e의 구간 최빈값은 e 자신이 유일
    max_num[e] = e
    
    for i in range(e - 1, 0, -1):
        # i의 약수 개수와 (i+1 ~ e) 구간의 최대 약수 개수를 가진 수의 약수 개수 비교
        if count[i] >= count[max_num[i+1]]:
            max_num[i] = i
        else:
            max_num[i] = max_num[i+1]
            
    # 3. 정답 추출
    answer = []
    for s in starts:
        answer.append(max_num[s])
        
    return answer
```
