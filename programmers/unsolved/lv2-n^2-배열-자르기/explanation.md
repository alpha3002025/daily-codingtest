# n^2 배열 자르기

## 문제 설명
정수 `n`, `left`, `right`가 주어집니다.
1. `n`행 `n`열 크기의 2차원 배열을 만듭니다.
2. `i`행 `i`열까지의 모든 빈칸을 숫자 `i+1`로 채웁니다. (문제 예시 참조)
   - 실제로는 `arr[r][c] = max(r, c) + 1` 규칙을 따릅니다.
3. 이 2차원 배열을 행 단위로 잘라 이어 붙여 1차원 배열로 만듭니다.
4. 이 1차원 배열의 `left` 인덱스부터 `right` 인덱스까지의 값만 남겨 반환합니다.

### 핵심 개념
1.  **메모리 제한 (Memory Limit)**: $n$이 최대 $10^7$입니다. $n^2$ 크기의 2차원 배열을 실제로 생성하면 메모리 초과가 발생합니다 ($10^{14}$개 요소).
2.  **인덱스 매핑 (Index Mapping)**: 1차원 배열의 인덱스 `idx`를 알면, 가상의 2차원 배열에서의 위치 `(row, col)`을 알 수 있습니다.
    - `row = idx // n`
    - `col = idx % n`
3.  **값 유추**: `(row, col)` 위치의 값은 `max(row, col) + 1` 입니다.
4.  **범위 처리**: 전체를 구하지 않고, `left`부터 `right`까지만 반복문을 돌며 값을 계산하여 리스트에 담습니다.

## Python 풀이

```python
def solution(n, left, right):
    answer = []
    
    # left부터 right까지 순회 (range는 끝값 미포함이므로 right + 1)
    for idx in range(left, right + 1):
        # 1차원 인덱스 idx를 2차원 좌표 (row, col)로 변환
        row = idx // n
        col = idx % n
        
        # 해당 좌표의 값 계산 Rule: max(row, col) + 1
        value = max(row, col) + 1
        answer.append(value)
        
    return answer
```

### 코드 설명
- 문제의 핵심은 **"2차원 배열을 실제로 만들지 않는 것"**입니다.
- `left`부터 `right` 범위의 길이는 최대 $10^5$ 이므로, 이 구간에 대해서만 반복문을 돌리면 시간 및 메모리 제한을 통과할 수 있습니다.
- `divmod`를 사용하면 몫(row)과 나머지(col)를 한 번에 구할 수 있지만, 직관적으로 보여주기 위해 `//`와 `%`를 사용했습니다.
- 예시: `n=3`, `left=2` (1차원 index 2는 2차원에서 (0, 2))
    - `row = 0`, `col = 2` -> `max(0, 2) + 1 = 3`.
    - 실제 문제 그림에서도 (0, 2) 위치는 3입니다.
