# 가장 큰 수

- `2025/12/17` : '문법 설명' 섹션 참고

<br/>


## 문제 설명
0 또는 양의 정수가 담긴 배열 `numbers`가 주어졌을 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 반환하세요.
예: `[6, 10, 2]` -> "6210"

### 핵심 개념
1.  **정렬 기준 재정의**: 숫자 크기대로 정렬하면 안 됩니다. (10 vs 2 -> 102 vs 210)
    - 두 문자열 $a, b$가 있을 때, $a+b$와 $b+a$를 비교해서 더 큰 쪽이 앞으로 와야 합니다.
    - 예: "6" vs "10" -> "610" > "106". 따라서 "6"이 앞.
    - 예: "3" vs "30" -> "330" > "303". 따라서 "3"이 앞.
2.  **문자열 곱셈 트릭**: Python 문자열 비교는 사전 순입니다. 숫자의 자릿수가 다르므로, 문자열을 반복해서 길이를 맞춘 뒤 비교하는 트릭이 자주 쓰입니다.
    - $N$이 1000 이하이므로, 문자열을 3번 반복(`num*3`)하면 충분히 비교 가능합니다.
    - "3" -> "333", "30" -> "303030". "333" > "303030".

## Python 풀이

```python
def solution(numbers):
    # 1. 문자열 리스트로 변환
    numbers_str = list(map(str, numbers))
    
    # 2. 정렬 조건 설정
    # x*3을 하는 이유: 문자열 길이 확장하여 사전 순 비교
    # 예: '3', '30' -> '333', '303030'
    # '333'이 '303'보다 크므로 '3'이 앞에 옴 (큰 순서대로 정렬해야 하므로 reverse=True)
    numbers_str.sort(key=lambda x: x*3, reverse=True)
    
    # 3. 조인 후 반환
    answer = "".join(numbers_str)
    
    # 예외 처리: [0, 0, 0] -> "000"이 아니라 "0"이어야 함
    return str(int(answer))
```

### 코드 설명
- `key=lambda x: x*3`: 문자열 길이가 최대 1000이므로 3자리까지만 비교해도 순서가 결정되는 경우가 많지만, 엄밀하게는 **A+B vs B+A** 논리입니다. 파이썬의 Sort Key 트릭으로 `x`를 반복해서 붙여서 사전 순으로 비교하면, 두 숫자를 이어 붙였을 때 큰 순서대로 정렬되는 효과가 있습니다.
- `int(answer)` 변환 후 다시 `str` 하는 이유: 모든 숫자가 0일 때 "0000" 대신 "0"을 출력하기 위함입니다.


## 문법 설명
### lambda 를 sort 안에서 사용하는 의미
`key=lambda x: x*3` 를 sort 구문 안에서 `numbers_str.sort(key=lambda x:x*3, reverse=True)` 를 사용했다. `lambda x: x*3` 은 배열의 요소들 각각을 3개씩 이어붙인 후 사전 순으로 정렬하겠다는 것이 아니라 `x: x*3` 을 기준으로 정렬하며, 원본 배열 요소는 수정하지 않는다는 의미다.<br/>

내가 혼동했던건 배열의 원본이 변경된다고 착각했던 것 이었다.<br/>
<br/>
