# 예상 대진표

## 문제 설명
N명이 참가하는 토너먼트에서 A번 참가자와 B번 참가자가 몇 번째 라운드에서 만나는지 구하는 문제입니다.
이긴 사람은 다음 라운드에서 번호가 바뀝니다.
- 1번, 2번 -> 승자는 다음 라운드 1번
- 3번, 4번 -> 승자는 다음 라운드 2번
- 일반화: `(n + 1) // 2` 번호 부여.

### 핵심 개념
1.  **수학적 규칙**: 다음 라운드 번호는 `(현재번호 + 1) // 2` 입니다.
2.  **종료 조건**: 두 사람의 번호가 같아질 때까지 반복...하면 안 되고, **두 사람이 서로 경쟁하는 대진일 때** 즉, `(a+1)//2 == (b+1)//2` 가 되는 순간이 만나는 라운드입니다.
    - 더 간단하게는, A와 B가 같아질 때까지 번호를 줄여나가면서 카운트하면 됩니다. (같은 그룹에 속하게 되는 순간)

## Python 풀이

```python
def solution(n, a, b):
    round_count = 0
    
    # 두 번호가 같아질 때까지 반복
    # (둘 다 같은 부모 노드 아래에 있을 때까지 2로 나눔)
    while a != b:
        a = (a + 1) // 2
        b = (b + 1) // 2
        round_count += 1
        
    return round_count
```

### 코드 설명
- 토너먼트 대진표는 이진 트리 구조입니다.
- 라운드가 올라갈수록 번호는 부모 노드의 인덱스처럼 변합니다.
- `a`와 `b`가 같아졌다는 것은 그들의 부모가 같다는 뜻, 즉 직전 라운드에서 둘이 대결했다는 뜻입니다.
- 예: A=4, B=7
    - R1: A->2, B->4 (안 만남)
    - R2: A->1, B->2 (안 만남)
    - R3: A->1, B->1 (만남!) -> 정답 3


## 참고
아래 예시를 통해서 (a+1)//2, (b+1)//2 를 반복해보자.
```plain
1,2 / 3,4 / 5,6 / 7,8

1,2 / 3/4

1/2
```
<br/>


## 코드 설명 (Q&A)

### Q. 다음 라운드의 번호를 `(현재번호 + 1) // 2` 로 지정하는 것은 부모를 찾아가는 원리인가요?
A<br/>
네, 정확합니다! **완전 이진 트리(Complete Binary Tree)에서 자식 노드가 부모 노드를 찾아가는 원리**와 동일합니다.

### 원리 설명

토너먼트 대진표를 트리 구조로 생각해보면 다음과 같습니다:

1.  **리프 노드(맨 아래)**: 1라운드에 참가하는 모든 선수들입니다.
2.  **부모 노드(위)**: 두 선수가 경기를 치르고 올라간 **다음 라운드의 자리**입니다.

이때, 인덱스 규칙을 보면:
-   `1번`과 `2번`이 싸워서 이긴 사람은 -> 다음 라운드의 `1번` 자리에 배정됩니다.
    -   `(1 + 1) // 2 = 1`
    -   `(2 + 1) // 2 = 1`
-   `3번`과 `4번`이 싸워서 이긴 사람은 -> 다음 라운드의 `2번` 자리에 배정됩니다.
    -   `(3 + 1) // 2 = 2`
    -   `(4 + 1) // 2 = 2`

즉, **`k`번째 노드의 부모 인덱스는 `(k + 1) // 2`** 가 되는 이진 트리의 속성을 그대로 사용한 것입니다. (일반적인 힙(Heap)나 세그먼트 트리에서 인덱스를 1부터 시작할 때 자식 `k`의 부모가 `k // 2`인 것과 거의 비슷하며, 여기선 대진표 규칙에 맞춰 `(k+1)//2`가 된 것입니다.)
