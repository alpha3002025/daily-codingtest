<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÏòàÏÉÅ ÎåÄÏßÑÌëú ÏãúÍ∞ÅÌôî (Tournament Logic)</title>
    <style>
        :root {
            --bg-color: #1a1b26;
            --card-bg: #24283b;
            --primary: #7aa2f7;
            --secondary: #bb9af7;
            --success: #9ece6a;
            --danger: #f7768e;
            --text-main: #c0caf5;
            --text-muted: #565f89;
            --border: #414868;
            --accent: #e0af68;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 900px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        h1 {
            color: var(--primary);
            margin-bottom: 20px;
            text-align: center;
        }

        .card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.85rem;
            color: var(--text-muted);
            font-weight: 600;
        }

        input {
            background: var(--bg-color);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 8px 12px;
            border-radius: 6px;
            width: 80px;
            text-align: center;
            font-family: inherit;
        }

        button {
            background: var(--primary);
            color: #15161e;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            margin-top: 20px;
        }

        button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .viz-area {
            position: relative;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            /* build from bottom */
            padding: 20px;
            overflow: hidden;
        }

        .round-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            /* dynamic */
            margin-bottom: 40px;
            width: 100%;
            position: relative;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .player-node {
            width: 40px;
            height: 40px;
            background: var(--bg-color);
            border: 2px solid var(--border);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: var(--text-muted);
            position: relative;
            z-index: 2;
            transition: all 0.3s;
        }

        .player-node.active-a {
            background: var(--success);
            color: #15161e;
            border-color: var(--success);
            box-shadow: 0 0 10px rgba(158, 206, 106, 0.4);
        }

        .player-node.active-b {
            background: var(--danger);
            color: #15161e;
            border-color: var(--danger);
            box-shadow: 0 0 10px rgba(247, 118, 142, 0.4);
        }

        .player-node.winner {
            background: var(--accent);
            color: #15161e;
            border-color: var(--accent);
            transform: scale(1.2);
            z-index: 10;
        }

        /* Connecting lines */
        .connector {
            position: absolute;
            border: 2px solid var(--border);
            border-bottom: none;
            top: -20px;
            z-index: 1;
        }

        .round-label {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 14px;
            font-weight: bold;
            color: var(--text-muted);
            background: var(--bg-color);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--border);
        }

        .info-panel {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1rem;
            color: var(--secondary);
        }

        .match-highlight {
            font-weight: bold;
            color: var(--accent);
        }

        .steps-log {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            border-top: 1px solid var(--border);
            padding-top: 10px;
        }

        .step-item {
            font-family: monospace;
            font-size: 13px;
            color: var(--text-muted);
        }

        .step-val {
            color: var(--text-main);
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>üèÜ ÏòàÏÉÅ ÎåÄÏßÑÌëú ÏãúÍ∞ÅÌôî</h1>

        <div class="card">
            <div class="controls">
                <div class="input-group">
                    <label>Ï∞∏Í∞ÄÏûê Ïàò (N)</label>
                    <input type="number" id="inp-n" value="8" min="2" max="32" step="2">
                </div>
                <div class="input-group">
                    <label>A Ï∞∏Í∞ÄÏûê</label>
                    <input type="number" id="inp-a" value="4" min="1">
                </div>
                <div class="input-group">
                    <label>B Ï∞∏Í∞ÄÏûê</label>
                    <input type="number" id="inp-b" value="7" min="1">
                </div>
            </div>
            <div style="text-align:center;">
                <button onclick="initSimulation()">Reset (Start)</button>
                <div style="display: inline-block; width: 20px;"></div>
                <button id="btn-prev" onclick="prevStep()" disabled
                    style="background:var(--border); color:var(--text-main)">‚óÄ Prev</button>
                <button id="btn-next" onclick="nextStep()" disabled
                    style="background:var(--secondary); color:#15161e">Next ‚ñ∂</button>
            </div>
        </div>

        <div class="card">
            <div class="info-panel" id="result-msg">Í≤∞Í≥ºÍ∞Ä Ïó¨Í∏∞Ïóê ÌëúÏãúÎê©ÎãàÎã§.</div>
            <div class="viz-area" id="viz-root">
                <!-- Visualization rendered here -->
            </div>
            <div class="steps-log" id="log-root"></div>
        </div>
    </div>

    <script>
        function runSimulation() {
            const n = parseInt(document.getElementById('inp-n').value) || 8;
            let a = parseInt(document.getElementById('inp-a').value) || 4;
            let b = parseInt(document.getElementById('inp-b').value) || 7;

            if (a > n || b > n || a < 1 || b < 1) {
                alert(`Ï∞∏Í∞ÄÏûê Î≤àÌò∏Îäî 1 ~ ${n} ÏÇ¨Ïù¥Ïó¨Ïïº Ìï©ÎãàÎã§.`);
                return;
            }

            const vizRoot = document.getElementById('viz-root');
            const logRoot = document.getElementById('log-root');
            const resultMsg = document.getElementById('result-msg');

            vizRoot.innerHTML = '';
            logRoot.innerHTML = '';
            resultMsg.innerText = 'Í≥ÑÏÇ∞ Ï§ë...';

            let round = 0;
            let currentA = a;
            let currentB = b;
            let maxRound = Math.log2(n);

            // Data snapshot for rendering
            const history = [];

            // Logic loop
            while (true) {
                round++;
                history.push({
                    round: round,
                    a: currentA,
                    b: currentB,
                    meet: currentA === currentB // actually logic checks a==b after update? 
                    // The problem says "answer" is the round they meet.
                    // The logic: a = (a+1)//2, b=(b+1)//2 -> if a==b break. 
                    // Wait, if a=1, b=2. (a+1)//2 = 1, (b+1)//2 = 1. -> Meet at R1.
                    // So verify BEFORE or calculate NEXT?
                    // The python code: 
                    // while a != b:
                    //    a = (a+1)//2
                    //    b = (b+1)//2
                    //    ans += 1
                    // return ans

                    // So, initially A!=B.
                    // Loop 1: R1 calc -> check if same.
                });

                // Calculate Next
                const nextA = Math.floor((currentA + 1) / 2);
                const nextB = Math.floor((currentB + 1) / 2);

                // Check if they become same NEXT round (means they meet THIS round)
                if (nextA === nextB && currentA !== currentB) {
                    // Wait, logic check:
                    // A=4, B=7
                    // R1: A->2, B->4. Ans=1. (Meet? No)
                    // R2: A->1, B->2. Ans=2. (Meet? No)
                    // R3: A->1, B->1. Ans=3. (Meet? YES)

                    // The loop should run until they are equal
                }

                // Let's just follow the python code faithfully for values
            }
        }

        let history = [];
        let currentStep = -1;

        function initSimulation() {
            const nNodes = parseInt(document.getElementById('inp-n').value) || 8;
            let a = parseInt(document.getElementById('inp-a').value);
            let b = parseInt(document.getElementById('inp-b').value);

            const vizRoot = document.getElementById('viz-root');
            const logRoot = document.getElementById('log-root');
            const resultMsg = document.getElementById('result-msg');

            // Reset UI
            vizRoot.innerHTML = '';
            logRoot.innerHTML = '';
            resultMsg.innerText = 'Ï§ÄÎπÑ ÏôÑÎ£å. Next Î≤ÑÌäºÏùÑ ÎàåÎü¨ ÏßÑÌñâÌïòÏÑ∏Ïöî.';
            document.getElementById('btn-prev').disabled = true;
            document.getElementById('btn-next').disabled = false;

            // Calculate all steps beforehand
            history = [];
            let round = 0;
            let currA = a;
            let currB = b;

            // Step 0: Start
            history.push({
                round: 0,
                a: currA,
                b: currB,
                isMet: false,
                msg: "ÏãúÎÆ¨Î†àÏù¥ÏÖò ÏãúÏûë"
            });

            // Loop Calculation
            while (currA !== currB) {
                round++;
                currA = Math.floor((currA + 1) / 2);
                currB = Math.floor((currB + 1) / 2);
                const isMet = currA === currB;

                history.push({
                    round: round,
                    a: currA,
                    b: currB,
                    isMet: isMet,
                    msg: `Round ${round}: A -> ${currA}, B -> ${currB}` + (isMet ? " (MATCH!)" : "")
                });
            }

            currentStep = -1;
            nextStep(); // Show Step 0 immediately
        }

        function nextStep() {
            if (currentStep < history.length - 1) {
                currentStep++;
                renderStep();
            }
            updateButtons();
        }

        function prevStep() {
            if (currentStep > 0) {
                currentStep--;
                renderStep();
            }
            updateButtons();
        }

        function updateButtons() {
            document.getElementById('btn-prev').disabled = currentStep <= 0;
            document.getElementById('btn-next').disabled = currentStep >= history.length - 1;

            // Final result message
            if (currentStep === history.length - 1) {
                const finalStep = history[history.length - 1];
                document.getElementById('result-msg').innerHTML = `ÏµúÏ¢Ö Í≤∞Í≥º: <span class="match-highlight">${finalStep.round}Î≤àÏß∏ ÎùºÏö¥Îìú</span>ÏóêÏÑú ÎßåÎÇ©ÎãàÎã§.`;
            } else {
                document.getElementById('result-msg').innerText = `ÏßÑÌñâ Ï§ë... (Step ${currentStep}/${history.length - 1})`;
            }
        }

        function renderStep() {
            const vizRoot = document.getElementById('viz-root');
            const logRoot = document.getElementById('log-root');

            // Clear and rebuild up to current step
            vizRoot.innerHTML = '';
            logRoot.innerHTML = '';

            for (let i = 0; i <= currentStep; i++) {
                const step = history[i];
                drawRow(step.round, step.a, step.b, step.isMet);

                if (i > 0) { // Log skip step 0
                    const logItem = document.createElement('div');
                    logItem.className = 'step-item';
                    if (i === currentStep) logItem.style.color = "var(--primary)";
                    logItem.innerText = step.msg;
                    logRoot.appendChild(logItem);
                }
            }

            vizRoot.scrollTop = 0;
            logRoot.scrollTop = logRoot.scrollHeight;
        }

        function drawRow(roundIdx, valA, valB, isMet) {
            const container = document.getElementById('viz-root');

            const row = document.createElement('div');
            row.className = 'round-row';

            if (roundIdx > 0) {
                const label = document.createElement('div');
                label.className = 'round-label';
                label.innerText = `Round ${roundIdx}`;
                row.appendChild(label);
            } else {
                const label = document.createElement('div');
                label.className = 'round-label';
                label.innerText = `Start (Leaves)`;
                row.appendChild(label);
            }

            // Tree Visualization Logic
            // We want to preserve relative horizontal positions to look like a tree.
            // The width of the container is fixed-ish. Let's use flex-basis or exact widths.

            // Actually, a simpler way for 1D stacking is to have placeholder nodes.
            // A full tree has N / (2^round) nodes.
            // We only care about A and B paths.

            // Let's create a container for nodes that has relative spacing
            const nodesContainer = document.createElement('div');
            nodesContainer.style.display = 'flex';
            nodesContainer.style.flex = '1';
            nodesContainer.style.justifyContent = 'space-around'; // Distribute evenly
            nodesContainer.style.alignItems = 'center';

            // Logic:
            // Round 0: 8 slots. A at pos A-1, B at pos B-1. Others are faint dots.
            // Round 1: 4 slots. A at pos (A+1)//2 -1.

            // Determine total max slots in this row
            const nNodes = parseInt(document.getElementById('inp-n').value) || 8;
            const slotsInRow = nNodes / Math.pow(2, roundIdx);

            for (let i = 1; i <= slotsInRow; i++) {
                // Check if this slot corresponds to A or B
                let content = null;
                let type = null;

                if (i === valA) {
                    content = valA;
                    type = 'A';
                } else if (i === valB) {
                    content = valB;
                    type = 'B';
                }

                if (isMet && valA === valB && i === valA) {
                    content = `${valA} vs ${valB}`;
                    type = 'Winner';
                }

                const nodeWrapper = document.createElement('div');
                nodeWrapper.style.display = 'flex';
                nodeWrapper.style.flexDirection = 'column';
                nodeWrapper.style.alignItems = 'center';
                nodeWrapper.style.width = '40px';

                if (content) {
                    if (type === 'Winner') {
                        const winNode = document.createElement('div');
                        winNode.className = 'player-node winner';
                        winNode.innerText = "MATCH";
                        winNode.style.fontSize = "10px";
                        nodeWrapper.appendChild(winNode);
                    } else {
                        const node = createNode(content, type);
                        nodeWrapper.appendChild(node);

                        // Draw line to parent if this is not the last round (future improvement)
                    }
                } else {
                    // Empty placeholder slot
                    const dot = document.createElement('div');
                    dot.style.width = '8px';
                    dot.style.height = '8px';
                    dot.style.backgroundColor = 'var(--border)';
                    dot.style.borderRadius = '50%';
                    dot.style.marginTop = '16px'; // center align bit lower
                    nodeWrapper.appendChild(dot);
                }

                nodesContainer.appendChild(nodeWrapper);
            }

            row.appendChild(nodesContainer);

            // Insert at TOP to build tree upwards (Root at top, leaves at bottom)
            container.prepend(row);
        } // End drawRow

        function createNode(val, type) {
            const div = document.createElement('div');
            div.className = `player-node active-${type.toLowerCase()}`;
            div.innerText = val;

            const tag = document.createElement('span');
            tag.style.position = 'absolute';
            tag.style.bottom = '-20px';
            tag.style.fontSize = '10px';
            tag.style.color = 'var(--text-muted)';
            tag.innerText = type;
            div.appendChild(tag);

            return div;
        }

        function addSpacer(row) {
            const line = document.createElement('div');
            line.style.width = "50px";
            line.style.height = "2px";
            line.style.background = "var(--border)";
            line.style.alignSelf = "center";
            row.appendChild(line);
        }

        // Init with default
        window.onload = initSimulation;

    </script>
</body>

</html>