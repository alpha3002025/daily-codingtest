# 문자열 압축

## 문제 설명
문자열 `s`를 1개 단위, 2개 단위, ..., `len(s)//2`개 단위로 잘라 압축했을 때, 가장 짧게 압축된 문자열의 길이를 구하는 문제입니다.
압축 규칙: 반복되는 문자열은 "개수+단위문자열"로 표현 (예: `aabbaccc` -> 1개 단위: `2a2ba3c`, 1문자는 생략).

### 핵심 개념
1.  **완전 탐색 (Exhaustive Search)**: 문자열 길이가 최대 1,000이므로, 자르는 단위를 1부터 $N/2$까지 모두 시도해봐도 충분합니다.
    - $N=1000$ 일 때, $500 \times (1000/Unit)$ 정도의 연산 -> 매우 적음.
2.  **문자열 슬라이싱**: `s[i:i+unit]` 형태로 자를 수 있습니다.
3.  **구현**: 이전 문자열(`prev`)과 현재 문자열(`curr`)을 비교하며 카운팅합니다.

## Python 풀이

```python
def solution(s):
    n = len(s)
    # 문자열 길이가 1이면 압축 불가, 길이는 1
    if n == 1:
        return 1
        
    min_length = n # 압축 안 했을 때가 초기값
    
    # 단위(unit) 크기: 1 ~ n//2
    for unit in range(1, n // 2 + 1):
        compressed = ""
        prev = s[:unit]
        count = 1
        
        # unit 간격으로 순회
        for i in range(unit, n, unit):
            curr = s[i:i+unit]
            
            if prev == curr:
                count += 1
            else:
                # 이전까지의 패턴 기록
                if count > 1:
                    compressed += str(count) + prev
                else:
                    compressed += prev
                    
                # 초기화
                prev = curr
                count = 1
        
        # 남은 마지막 조각 처리
        if count > 1:
            compressed += str(count) + prev
        else:
            compressed += prev
            
        min_length = min(min_length, len(compressed))
        
    return min_length
```

### 코드 설명
- `unit` 크기로 자르기 위해 `range(unit, n, unit)`을 사용합니다.
- `prev`는 직전 블록, `curr`은 현재 블록.
- 루프가 끝나고 마지막에 남아있는 `prev` 처리를 잊지 말아야 합니다.
- 압축된 문자열 `compressed`를 실제로 만들지 않고 길이만 계산해도 되지만, 문자열을 만드는 게 직관적이고 디버깅하기 좋습니다. (길이가 짧으므로 성능 문제 X)


## 참고

### Q. 왜 N/2 까지만 검사할까요?
압축이라는 것은 **"같은 패턴이 최소 2번 이상 반복"**되어야 의미가 있습니다. 만약 자르는 단위가 문자열 길이의 절반(N/2)을 넘어선다면, 그 패턴은 절대 2번 반복될 수 없습니다. (예: 길이가 10인데 6글자 단위로 자르면, 남은 글자는 4글자뿐이라 반복 불가능)

따라서 압축 효율을 확인하기 위한 자르는 단위의 최댓값은 전체 길이의 절반까지만 확인하면 충분합니다.<br/>
<br/>

요약<br/>
Q : 왜 `1`부터 `N/2`까지만 검사하나요?<br/>

A 
- **자르는 단위(Unit Length)**에 대한 탐색 범위입니다.
- 압축은 **"같은 패턴이 최소 2번 이상 반복"**되어야 줄어드는 효과가 있습니다.
- 만약 자르는 단위가 문자열 전체 길이($N$)의 절반($N/2$)을 넘는다면, 남은 글자 수가 단위보다 적어서 **절대로 2번 반복될 수 없습니다.**
    - 예: 길이 10인 문자열을 6글자 단위로 자르면, 뒤에 4글자밖에 안 남으므로 반복 불가.
- 따라서 효율적인 탐색을 위해 자르는 단위는 **최대 절반 길이**까지만 확인하면 충분합니다.

<br/>


### 짜투리 문자열, 마지막 단위 문자열 처리
마지막 조각 처리(`L47-L51`)는 **루프가 끝난 뒤, 아직 `compressed` 문자열에 추가되지 않고 `prev` 변수에 남아 있는 마지막 패턴을 처리하는 단계**입니다.

이 로직은 사실 **모든 케이스에서 필수적으로 실행**되지만, 구체적인 예시는 다음과 같습니다.
<br/>
<br/>

### 예시 1: 마지막에 반복이 없는 경우 (`abcabcabc`)
*   **unit = 3** (`abc`)
*   루프 진행:
    1.  `abc` (prev) vs `abc` (curr) -> count = 2
    2.  `abc` (prev) vs `abc` (curr) -> count = 3
*   **루프 종료 후**:
    *   `prev`에는 여전히 `'abc'`가 남아 있고, `count`는 `3`인 상태입니다.
    *   하지만 루프가 끝났으므로 이 내용을 `compressed`에 더해주지 않으면 최종 결과가 빈 문자열이 됩니다.
    *   따라서 **L47-L51**에서 `3abc`를 추가하여 결과를 완성합니다.

<br/>

### 예시 2: 마지막에 찌꺼기(?)가 남는 경우 (`abcabcd`)
*   **unit = 3** (`abc`)
*   루프 진행:
    1.  `abc` (prev) vs `abc` (curr) -> count = 2
    2.  루프 범위(`range(3, 7, 3)`)가 끝나서 `d`는 루프 안에서 `curr`로 처리되지 못함 (혹은 루프 로직에 따라 다름, 코드 상 `curr`가 `s[i:i+unit]`이므로 `d`는 마지막 `curr`가 됨)
    *   정확히 수정하면:
        1. `unit=3`, `i=3`: `curr`='abc'. `prev`==`curr`. `count`=2.
        2. `i=6`: `curr`='d'. `prev`!='curr'.
           - `compressed` += `2abc`.
           - `prev` = 'd', `count` = 1.
*   **루프 종료 후**:
    *   `prev`에는 마지막 글자 `'d'`가 남아 있음.
    *   `count`는 `1`.
    *   **L47-L51**이 실행되어 `compressed` 뒤에 `d`를 붙여줍니다.

### 요약
이 부분이 없으면 **마지막 패턴 덩어리**나 **뒤에 남은 꼬투리 문자열**이 결과에서 **증발**하게 됩니다.

<br/>
<br/>


