# 큰 수 만들기

## 문제 설명
어떤 숫자 문자열 `number`에서 `k`개의 수를 제거했을 때 얻을 수 있는 **가장 큰 숫자**를 구해야 합니다.

### 핵심 개념
1.  **그리디 (Greedy) 알고리즘**: 앞에서부터 숫자를 차례대로 선택하되, **지금 선택한 숫자보다 뒤에 더 큰 숫자가 있다면, 지금 숫자를 버리는(제거하는) 것이 이득**입니다.
    - 예: `1924`, `k=2`
    - `1`을 봄. 뒤에 `9`가 있으므로 `1` 제거. (k=1)
    - `9`를 봄. 제일 큼. 유지.
    - `2`를 봄. 뒤에 `4`가 있으므로 `2` 제거. (k=0)
    - 남은 `94`.
2.  **스택 (Stack)**:
    - 현재 숫자를 스택에 넣기 전에, 스택의 `top`이 현재 숫자보다 작으면 `pop` 하고 `k`를 감소시킵니다. (작은 수는 큰 수보다 앞에 오면 손해이므로)
    - `k`가 남아있다면 계속 반복합니다.

## Python 풀이

```python
def solution(number, k):
    stack = []
    
    for num in number:
        # 스택에 값이 있고, k가 아직 남아있고,
        # 스택의 마지막 값(앞자리)보다 현재 값(뒷자리)이 더 크면
        # 스택의 값을 제거 (앞자리를 큰 수로 교체)
        while stack and k > 0 and stack[-1] < num:
            stack.pop()
            k -= 1
        stack.append(num)
        
    # 만약 k가 남았다면 뒤에서부터 제거
    # 예: "54321", k=2 -> loop에서 제거 안 됨 -> 뒤의 2개 자름
    if k > 0:
        stack = stack[:-k]
        
    return "".join(stack)
```

### 코드 설명
- 시간 복잡도: 각 숫자는 최대 한 번 `push`되고 한 번 `pop`되므로 $O(N)$입니다. $N$이 최대 1,000,000이므로 효율적입니다.
- 내림차순으로 정렬된 경우(예: `98765`), `while`문의 조건(`stack[-1] < num`)을 만족하지 않아 아무것도 제거되지 않습니다. 마지막에 `stack[:-k]`로 뒤쪽을 잘라줘야 합니다.
