# 산 모양 타일링

## 문제 설명
사다리꼴 모양의 산을 타일로 채우는 문제입니다. 기본적으로 정삼각형들이 일렬로 연결되어 있고, 일부 정삼각형 위에는 추가적인 정삼각형(뿔)이 붙어 있습니다. 이를 정삼각형 타일과 마름모 타일(정삼각형 2개)로 채우는 방법의 수를 구해야 합니다.

## 문제 해결 전략

이 문제는 **다이나믹 프로그래밍(DP)**으로 해결할 수 있습니다.
산을 구성하는 각 "단위(Unit)"를 순서대로 처리하면서 경우의 수를 누적합니다.

### 상태 정의
$i$번째 단위까지 채웠을 때, $i$번째 단위의 오른쪽 변이 타일로 덮였는지 여부에 따라 상태를 나눕니다.
- `a[i]`: $i$번째 단위까지 완벽하게 채워진 경우의 수 (오른쪽 변이 덮이지 않음, 즉 이전 단위와 다음 단위가 독립적임)
- `b[i]`: $i$번째 단위의 오른쪽 변이 마름모 타일의 절반으로 덮여 있어, $i+1$번째 단위로 "넘어가는" 경우의 수

### 점화식
$i$번째 단위에 '뿔(top)'이 있는지(`tops[i] == 1`) 없는지(`tops[i] == 0`)에 따라 달라집니다.

1. **뿔이 있는 경우 (`tops[i] == 1`)**:
   - 삼각형이 총 4개(좌, 우, 중, 상)의 공간을 가짐. (형상에 따라 다를 수 있으나, 보통 Bottom-Left, Bottom-Right, Center, Top으로 구성)
   - 문제의 도형 구조상: $i$번째 구간은 밑변에 역삼각형 1개, 그 좌우에 정삼각형, 그리고 위에 정삼각형(뿔)이 있습니다.
   - `a[i]` (완료됨)를 만드는 방법:
     - `a[i-1]`에서: 3가지 (가운데+뿔 마름모, 왼쪽+가운데 마름모, 등...) -> 구체적으로 3가지.
     - `b[i-1]`에서: 2가지.
     - Recurrence: `a[i] = a[i-1] * 3 + b[i-1] * 2`
   - `b[i]` (오른쪽으로 넘어감)를 만드는 방법:
     - `a[i-1]`에서: 1가지.
     - `b[i-1]`에서: 1가지.
     - Recurrence: `b[i] = a[i-1] + b[i-1]`

2. **뿔이 없는 경우 (`tops[i] == 0`)**:
   - `a[i]` (완료됨):
     - `a[i-1]`에서: 2가지.
     - `b[i-1]`에서: 1가지.
     - Recurrence: `a[i] = a[i-1] * 2 + b[i-1]`
   - `b[i]` (오른쪽으로 넘어감):
     - `a[i-1]`에서: 1가지.
     - `b[i-1]`에서: 1가지.
     - Recurrence: `b[i] = a[i-1] + b[i-1]`

### 최종 결과
마지막 $n-1$번째 인덱스까지 계산한 후, 오른쪽으로 넘어가는 경우는 없으므로 `a[n-1] + b[n-1]`이 답입니다. (여기서 `a`는 닫힌 상태, `b`는 열린 상태인데 마지막은 닫혀야 하므로 `a`만? 아닙니다. 마지막 변이 열려있다는건 $n+1$로 넘어간다는 뜻인데 $n+1$이 없으므로 불가능합니다. 하지만 보통 `b` 정의가 "오른쪽 끝 정삼각형 하나만 남은 상태"를 의미하므로, 마지막에 남은 삼각형을 채우는 방법이 포함되어야 합니다. 문제 구조상 오른쪽 끝을 공유하는 마름모가 불가능하니까 `a`와 `b`의 합으로 해석되기도 합니다. 정확한 식은 마지막 `a`값입니다. 하지만 DP 정의에 따라 다릅니다. 여기서는 "현재 블록 내부 처리가 끝난 상태"를 `a`, "다음 블록과 연결된 상태"를 `b`라 하면, 마지막엔 다음 블록과 연결될 수 없으므로 `b` 상태는 불가능하거나 0입니다. 그러나 점화식을 "현재 블록의 오른쪽 삼각형을 비워둠"으로 정의하면 합쳐야 할 수도 있습니다. 통상적인 풀이인 `a[i] = 3a + 2b` 로직에서는 마지막 `a`값을 취하거나, `b`가 불가능함을 고려합니다. 검색된 풀이에 따르면 `(a + b) % mod`를 반환합니다. 의미상 `a`: 현재 단계에서 마무리, `b`: 오른쪽 반쪽 마름모로 덮임(다음 칸 침범). 마지막 칸은 침범 불가.
즉, 마지막 단계에서는 `b` 경우가 생성될 수 없습니다(오른쪽 벽). 따라서 마지막 루프에서 `b` 계산을 제외하거나, `a`만 취해야 합니다. 또는 문제에서 오른쪽 끝이 막혀있다고 가정하므로 `tops` 마지막 처리는 `a`로 귀결됩니다. 실제로 많은 풀이에서 `a[n-1] + b[n-1]`을 리턴하는데, 이는 정의의 차이일 수 있습니다.
가장 깔끔한 정의: $i$번째 역삼각형까지 채움.
- $A[i]$: $i$번째 뿔/역삼각형 다 채우고 오른쪽 정삼각형 비움(다음이랑 연결).
- $B[i]$: $i$번째 오른쪽 정삼각형까지 다 채움.
- 답: $B[n-1]$.

재정리:
- $dp[i][0]$: $i$번째 사다리꼴의 오른쪽 삼각형을 채우지 않음 (다음과 겹침).
- $dp[i][1]$: $i$번째 사다리꼴의 오른쪽 삼각형을 채움.
- Top 있을 때:
  - $dp[i][1] = dp[i-1][0] * 2 + dp[i-1][1] * 3$
  - $dp[i][0] = dp[i-1][0] * 1 + dp[i-1][1] * 1$
- Top 없을 때:
  - $dp[i][1] = dp[i-1][0] * 1 + dp[i-1][1] * 2$
  - $dp[i][0] = dp[i-1][0] * 1 + dp[i-1][1] * 1$
- 답: $dp[n-1][1]$ (오른쪽까지 다 채워야 함)

## Python 코드

```python
def solution(n, tops):
    MOD = 10007
    
    # a: 오른쪽 삼각형을 채움 (완료)
    # b: 오른쪽 삼각형을 비움 (다음 칸과 연결 예정)
    
    # 초기값 (첫 번째 칸, 인덱스 0)
    if tops[0] == 1:
        a = 3
        b = 1
    else:
        a = 2
        b = 1
        
    for i in range(1, n):
        # 이전 상태 a_prev, b_prev
        # a_new 계산:
        # 1. 이전이 a (완료됨):
        #    - Top 있음: 4가지 중 왼쪽 연결 불가(이미 완료됐으니) -> 3가지
        #    - Top 없음: 3가지 중 왼쪽 연결 불가 -> 2가지
        # 2. 이전이 b (비어있음 = 왼쪽 연결 필수):
        #    - 무조건 왼쪽 삼각형을 채우는 마름모 써야 함.
        #    - 나머지를 채우는 경우의 수.
        #    - Top 있음: 나머지(가운데+위+오른쪽) 채우는 법. 4-1(왼쪽마름모)-1(오른쪽연결?아니 a니까 오른쪽채움).
        #      Top-Center, Center-Right, Top, Right... 
        #      간담: 이전 b -> 이번에 왼쪽 삼각형 먹힘. 남은건 (Top), Center, Right.
        #      Right 채워야 함(a니까).
        #      (Top, Center) 마름모 가능, (Top), (Center) 각각 가능. 총 2가지. (Top 없음: 1가지)
        
        # 정리된 식 사용
        prev_a, prev_b = a, b
        
        if tops[i] == 1:
            # a: 이전 a * 3 + 이전 b * 2
            a = (prev_a * 3 + prev_b * 2) % MOD
            # b: 이전 a * 1 + 이전 b * 1
            b = (prev_a + prev_b) % MOD
        else: # tops[i] == 0
            # a: 이전 a * 2 + 이전 b * 1
            a = (prev_a * 2 + prev_b * 1) % MOD
            # b: 이전 a * 1 + 이전 b * 1
            b = (prev_a + prev_b) % MOD
            
    return a
```
