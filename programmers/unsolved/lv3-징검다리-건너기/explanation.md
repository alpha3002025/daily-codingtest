# 징검다리 건너기

## 문제 설명
징검다리의 디딤돌에 숫자가 적혀 있고, 한 명이 밟을 때마다 1씩 줄어듭니다. 숫자가 0이 되면 밟을 수 없습니다.
최대 `k`칸을 건너뛸 수 있습니다. (밟을 수 없는 돌이 `k`개 연속으로 나오면 못 건넙니다)
최대 몇 명이 건널 수 있는지 구하세요.

## 문제 해결 전략

두 가지 방법이 있습니다.
1. **이분 탐색 (Parametric Search)**:
   - "N명이 건널 수 있는가?"를 판별하는 함수 `can_cross(N)`을 만듭니다.
   - `can_cross(N)`: 모든 돌에서 `N`을 뺀 값들이 있을 때, 연속된 0 이하(못 밟는 돌) 구간의 길이가 `k`보다 작은지 확인.
     - 즉, 연속해서 `N`보다 작은 숫자가 `k`개 이상 있으면 못 건넙니다.
   - 범위: 1 ~ 2억(최대 돌 숫자). $O(M \log(\max\_stone))$. 효율적.

2. **슬라이딩 윈도우 최댓값 (Sliding Window Maximum)**:
   - 문제를 뒤집어 생각하면, **"연속된 k개의 돌 중 최댓값"**이 그 구간을 통과할 수 있는 최대 인원수입니다. (왜냐하면 k개 중 가장 큰 숫자만큼 사람이 지나가면 k개 모두 0이 되어 못 지나가기 때문... 아님 반대인가?)
   - 정확히는: 개구리가 점프해서 지나가려면, 어떤 연속된 `k`개 구간에서도 **적어도 하나의 돌은 살아있어야** 합니다.
   - 즉, 모든 연속된 `k`개 구간들의 "최댓값"들 중 "최솟값"이 답입니다. (병목 구간 찾기)
   - 예를 들어 3칸 점프 가능(`k=3`)인데 `[1, 2, 1]` 구간이 있다면, 2명이 지나가면 `[0, 0, 0]`이 되어 3번째 사람은 못 건넙니다. 즉 `max([1,2,1]) = 2`명까지만 가능.
   - 이 "구간 최댓값"이 가장 작은 구간(병목)이 전체 통행량을 제한합니다.
   - 슬라이딩 윈도우 최대값 구하기 -> 덱(Deque) 사용 $O(N)$.

이분 탐색이 구현이 쉽고 직관적이므로 일반적으로 추천됩니다.

## Python 코드 (이분 탐색)

```python
def solution(stones, k):
    def can_cross(n):
        # n명이 건널 때, 연속으로 못 밟는 돌(값 < n)이 k개 이상인지 확인
        skip = 0
        for s in stones:
            if s < n:
                skip += 1
                if skip >= k:
                    return False
            else:
                skip = 0
        return True

    left = 1
    right = 200000000
    answer = 0
    
    while left <= right:
        mid = (left + right) // 2
        if can_cross(mid):
            answer = mid
            left = mid + 1
        else:
            right = mid - 1
            
    return answer
```
