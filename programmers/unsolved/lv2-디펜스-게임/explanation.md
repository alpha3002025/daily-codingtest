# 디펜스 게임

## 문제 설명
병사 `n`명과 무적권 `k`개가 있습니다.
`enemy` 배열에 라운드별 적의 수가 주어집니다.
라운드마다 적의 수만큼 병사를 소모하여 막거나, 무적권을 사용하여 병사 소모 없이 막을 수 있습니다.
병사가 부족하면 게임이 종료됩니다. 최대 몇 라운드까지 막을 수 있는지 구합니다.

## 풀이 개념
**최대 힙 (Max Heap)**을 사용한 **그리디(Greedy)** 문제입니다.

1. 라운드를 진행하며 적의 수를 누적해서 병사(`n`)에서 뺍니다. (일단 병사로 막는다고 가정)
2. 동시에 만난 적의 수를 최대 힙에 저장합니다. (Python `heapq`는 최소 힙이므로 음수로 저장).
3. 만약 병사가 부족해지면(`n < 0`):
   - 무적권(`k`)을 사용할 수 있는지 확인합니다.
   - `k > 0`이라면, 지금까지 만난 적 중 가장 수가 많은 적(힙의 최대값)에 무적권을 사용한 것으로 처리합니다.
   - 힙에서 최대값을 꺼내서 다시 병사 수에 더해주고(복구), `k`를 1 감소시킵니다.
   - 이렇게 해도 여전히 `n < 0`이라면 게임 종료입니다.
4. 모든 라운드를 통과하면 전체 길이를 반환합니다.

## 코드 (Python)

```python
import heapq

def solution(n, k, enemy):
    max_heap = []
    
    for i, e in enumerate(enemy):
        n -= e
        # 최대 힙을 위해 음수로 저장
        heapq.heappush(max_heap, -e)
        
        if n < 0:
            if k > 0:
                # 가장 큰 적을 무적권으로 처리 (병사 복구)
                max_e = -heapq.heappop(max_heap)
                n += max_e
                k -= 1
            else:
                # 무적권도 없고 병사도 부족하면 종료
                return i
                
    return len(enemy)
```
