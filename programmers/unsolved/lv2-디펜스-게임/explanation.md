# 디펜스 게임
heap 문제들은 시뮬레이션에 넣는게 맞는데, 시뮬레이션과 섞어서 풀기에는 또 이것 저것 섞이기에 heap 문제만 골라서 풀수 있도록 heap 디렉터리에 넣었다. 문제 풀이시에는 heap 과 시뮬레이션을 한세트로 같이 풀어야 한다.

- (1) heap 문제는 항상 골치아프다. 특히 최대힙의 경우 - 곱해서 넣고, 빼서 계산시에 다시 - 를 곱해야 하는데, 이게 매번 실수를 하는 요소다.
- (2) Greedy 사고 방식은 시간이 부족할때의 존나 급박한 상황에서는 절대 아이디어를 떠올릴수 없는 방식이다. 그래도 익숙해져야 이런 문제가 이거였네 한다.

<br/>

## link
- https://school.programmers.co.kr/learn/courses/30/lessons/142085

## 문제 설명
병사 `n`명과 무적권 `k`개가 있습니다.
`enemy` 배열에 라운드별 적의 수가 주어집니다.
라운드마다 적의 수만큼 병사를 소모하여 막거나, 무적권을 사용하여 병사 소모 없이 막을 수 있습니다.
병사가 부족하면 게임이 종료됩니다. 최대 몇 라운드까지 막을 수 있는지 구합니다.

<br/>

## 풀이 개념
**최대 힙 (Max Heap)**을 사용한 **그리디(Greedy)** 문제입니다.

1. 라운드를 진행하며 적의 수를 누적해서 병사(`n`)에서 뺍니다. (일단 병사로 막는다고 가정)
2. 동시에 만난 적의 수를 최대 힙에 저장합니다. (Python `heapq`는 최소 힙이므로 음수로 저장).
3. 만약 병사가 부족해지면(`n < 0`):
   - 무적권(`k`)을 사용할 수 있는지 확인합니다.
   - `k > 0`이라면, 지금까지 만난 적 중 가장 수가 많은 적(힙의 최대값)에 무적권을 사용한 것으로 처리합니다.
   - 힙에서 최대값을 꺼내서 다시 병사 수에 더해주고(복구), `k`를 1 감소시킵니다.
   - 이렇게 해도 여전히 `n < 0`이라면 게임 종료입니다.
4. 모든 라운드를 통과하면 전체 길이를 반환합니다.

<br/>

## 코드 (Python)

```python
import heapq

def solution(n, k, enemy):
    max_heap = []
    
    for i, e in enumerate(enemy):
        n -= e
        # 최대 힙을 위해 음수로 저장
        heapq.heappush(max_heap, -e)
        
        if n < 0:
            if k > 0:
                # 가장 큰 적을 무적권으로 처리 (병사 복구)
                max_e = -heapq.heappop(max_heap)
                n += max_e
                k -= 1
            else:
                # 무적권도 없고 병사도 부족하면 종료
                return i
                
    return len(enemy)
```

<br/>

## 코드 설명
- **일단 맞고 나중에 무르기 (Proactive Approach vs Retroactive Approach)**:
  - 무적권을 미리 언제 쓸지 결정하는 것이 아니라, **"일단 병사로 막다가 더 이상 못 막을 때, 과거에 가장 아팠던 적을 무적권으로 막았던 걸로 치환"**하는 전략입니다.
  - 이를 위해 `heapq`에 지금까지 만난 적들의 수를 저장해둡니다.
- **최대 힙 사용**: Python의 `heapq`는 최소 힙만 지원하므로, 값을 음수(`-e`)로 저장하여 최대 힙처럼 사용했습니다.
- **n < 0 조건시**:
  - `k`가 남아있다면, 힙에서 가장 큰 값(가장 많은 적)을 꺼내서 병사 수를 복구합니다(`n += max_e`).
  - 즉, 과거의 가장 큰 피해를 무효화하고 무적권을 하나 소모시킨 것입니다.
  - 이렇게 해야 현재 라운드뿐만 아니라 미래를 위해서도 병사를 최대한 아낄 수 있습니다.
- **모든 라운드 통과 (`return len(enemy)`)**:
  - 반복문이 중간에 `return i`로 종료되지 않고 끝까지 문제없이 돌았다면, 모든 적을 막아낸 것입니다.
  - 따라서 적의 총 수(`len(enemy)`)가 즉 최대 통과 라운드 수가 됩니다.

