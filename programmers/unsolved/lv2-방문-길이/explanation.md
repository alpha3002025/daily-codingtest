# 방문 길이

## 문제 설명
좌표평면의 (0,0)에서 시작하여 명령어("U", "D", "R", "L")대로 움직입니다. 경계를 넘어가는 명령어는 무시하며, **처음 걸어본 길의 길이**를 구해야 합니다. 같은 길을 반대 방향으로 걸어도 이미 본 길(방문한 길)로 취급합니다.

### 핵심 개념
1.  **길(Edge)의 표현**: 단순히 방문한 점(Node)을 기록하는 게 아니라, 점과 점 사이의 **경로(Path)**를 기록해야 합니다.
    - `(current_x, current_y, next_x, next_y)` 형태로 저장.
2.  **방향성 무시 (Undirected)**: A->B 로 간 것과 B->A 로 간 것은 같은 길입니다.
    - 따라서 집합(Set)에 넣을 때 `(curr, next)`와 `(next, curr)` 둘 다 확인 or 둘 다 저장 후 나누기 2.
3.  **좌표 경계 체크**: -5 ~ 5 범위를 벗어나면 이동하지 않습니다.

## Python 풀이

```python
def solution(dirs):
    x, y = 0, 0
    visited_paths = set()
    
    # 명령어에 따른 이동 변화량
    move = {'U': (0, 1), 'D': (0, -1), 'R': (1, 0), 'L': (-1, 0)}
    
    for command in dirs:
        dx, dy = move[command]
        nx, ny = x + dx, y + dy
        
        # 경계 체크 (-5 ~ 5)
        if -5 <= nx <= 5 and -5 <= ny <= 5:
            # 길은 방향이 없으므로, (출발, 도착) 순서쌍을 정렬해서 넣거나
            # 양방향 모두 넣고 나중에 2로 나눔.
            # 여기서는 (출발, 도착), (도착, 출발) 둘 다 set에 넣음
            visited_paths.add((x, y, nx, ny))
            visited_paths.add((nx, ny, x, y))
            
            # 이동
            x, y = nx, ny
            
    # 양방향을 다 넣었으므로, 실제 길의 개수는 절반
    return len(visited_paths) // 2
```

### 코드 설명
- `set` 자료구조를 사용하여 중복된 길을 자동으로 제거합니다.
- `(0,0) -> (0,1)`로 이동했을 때, `((0,0), (0,1))`과 `((0,1), (0,0))`을 모두 저장합니다. 이렇게 하면 나중에 `(0,1)`에서 `(0,0)`으로 내려올 때도 이미 방문한 길로 인식됩니다.
- 마지막에 `len // 2`를 해서 고유한 길의 개수를 반환합니다.
