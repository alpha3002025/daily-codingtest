# [3차] n진수 게임

## 문제 설명
튜브가 참여하는 게임은 숫자를 0부터 시작해서 차례대로 말하는 게임입니다. 단, 10 이상의 숫자는 한 자리씩 끊어서 말합니다. 이 게임을 `n`진법으로 진행할 때, 튜브가 말해야 하는 숫자들을 구하세요.
- `n`: 진법
- `t`: 미리 구할 숫자의 개수
- `m`: 참가 인원
- `p`: 튜브의 순서

### 풀이 전략
이 코드는 **"전체 게임 진행 문자열을 미리 다 구해놓고, 튜브의 차례만 골라내는"** 전략을 사용합니다.
1. **전체 문자열 생성**: 0부터 숫자를 1씩 늘려가며 n진법으로 변환해 쭉 이어 붙입니다. 튜브가 `t`개를 말해야 하므로 최소 `t * m` 길이까지 만듭니다.
2. **튜브의 차례 추출**: 생성된 전체 문자열에서 튜브의 순서(`p`)에 맞는 글자들만 `m` 간격으로 뽑아냅니다.
    - **장점**: 매 턴마다 누구 차례인지 계산하는 복잡한 로직 없이, 슬라이싱 한 번으로 처리가 가능합니다.

### 핵심 개념
1.  **진법 변환**: 0부터 숫자를 1씩 증가시키면서 `n`진수로 변환한 문자열을 계속 이어 붙입니다.
    - 예(n=2): `0`, `1`, `10`, `11`, `100`... -> "011011100..."
2.  **문자열 인덱싱**: 만들어진 전체 문자열에서 튜브의 순서(`p`)에 해당하는 글자만 뽑아냅니다.
    - 인덱스 규칙: `p-1`부터 시작하여 `m` 간격 (`idx % m == p - 1`)

## Python 풀이

```python
# 10진수 이상의 숫자 변환을 위한 테이블
DIGITS = "0123456789ABCDEF"

def to_base_n(num, n):
    if num == 0:
        return "0"
    
    res = ""
    while num > 0:
        res += DIGITS[num % n]
        num //= n
    return res[::-1]

def solution(n, t, m, p):
    # 튜브가 말해야 할 t개의 숫자를 구하기 위해,
    # 전체 게임 진행 문자열을 충분히 길게 생성
    # (t * m) 길이 정도면 충분함
    
    full_str = ""
    num = 0
    
    # 필요한 길이만큼 확보할 때까지 루프
    while len(full_str) < t * m:
        full_str += to_base_n(num, n)
        num += 1
        
    # 튜브의 순서에 해당하는 글자 추출
    # 0-based index이므로 p-1 부터 시작
    # 슬라이싱 [start:end:step] 활용
    answer = full_str[p-1 : t*m : m]
    
    return answer
```

### 코드 설명
- `to_base_n`: 일반적인 `to_hex` 등의 함수를 n진법으로 확장한 것입니다. 나머지를 이용해 자릿수를 구하고 뒤집습니다.
- `full_str`: 게임에서 불리는 모든 숫자를 나열한 문자열입니다. 우리가 필요한 건 `t * m` 글자까지만 있으면 됩니다(그 뒤는 튜브의 턴이 오지 않거나 필요 없음).
- `full_str[p-1::m]`: Python 슬라이싱의 step 기능을 이용하면 `for`문과 `if`문 없이 한 줄로 추출 가능합니다. `[:t*m]`으로 길이를 맞춰줍니다.


## 문법 설명

### 슬라이싱 Step 문법 `[start : end : step]`
파이썬의 슬라이싱은 세 번째 인자로 `step`(간격)을 받을 수 있습니다.

- **`start`**: 시작 인덱스 (포함)
- **`end`**: 끝 인덱스 (미포함)
- **`step`**: 몇 칸씩 건너뛸지 설정

**예시**:
```python
s = "0123456789"

# 인덱스 1부터 끝까지, 3칸 간격으로
print(s[1::3]) 
# 결과: "147" 
# 1. s[1] = '1'
# 2. s[1+3] = s[4] = '4'
# 3. s[4+3] = s[7] = '7'
# 4. s[7+3] = s[10] (범위 초과로 종료)
```

**문제 적용 (`full_str[p-1 : t*m : m]`)**:
- `p-1`: 튜브는 `p`번째 순서이므로 인덱스는 `p-1`부터 시작합니다.
- `t*m`: 튜브가 말해야 할 숫자가 `t`개이므로, 전체 순서상으로는 최대 `t*m` 번째까지만 확인하면 됩니다.
- `m`: 참가자가 `m`명이므로, 내 차례는 `m`명마다(m칸씩 건너뛰어서) 돌아옵니다.

> **요약**: 정해진 `start` ~ `end` 범위 내에서, `start`부터 시작해 `step`만큼 인덱스를 더해가며 **해당 위치의 한 글자씩만 쏙쏙 뽑아낸다**는 의미입니다.

