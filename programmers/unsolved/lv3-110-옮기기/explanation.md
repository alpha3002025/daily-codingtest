# 110 옮기기

## 문제 설명
`0`과 `1`로 이루어진 문자열 $x$가 주어집니다.
"110"을 뽑아서 임의의 위치에 다시 삽입할 수 있습니다.
이 과정을 무한히 반복하여 만들 수 있는 문자열 중 **사전 순으로 가장 앞에 오는 것**을 찾으세요.

## 문제 해결 전략

사전 순으로 가장 앞선다는 것은 **`0`이 최대한 앞에 오도록** 해야 한다는 뜻입니다.
즉, "110"들을 모두 추출한 뒤, 남은 문자열의 **가장 적절한 위치(Greedy)**에 한꺼번에 삽입하면 됩니다.

1. **"110" 추출**:
   - 문자열을 스캔하며 "110"이 나오면 모두 제거하고 개수(`cnt`)를 셉니다.
   - 스택을 사용하면 $O(N)$에 한 번에 찾을 수 있습니다.

2. **삽입 위치 결정**:
   - 남은 문자열(`remain`)에서 "110"들을 어디에 넣어야 할까요?
   - "110"은 시작이 '1'이지만 끝이 '0'입니다. 이 '0'을 최대한 활용해야 합니다.
   - `remain`에 있는 **마지막 '0'의 뒤**에 넣는 것이 최적입니다.
     - 이유: 마지막 '0' 뒤에는 모두 '1'들만 있을 것입니다 (만약 '0'이 있었다면 그게 마지막 '0'이었을 테니).
     - 즉 `...0 111...1` 형태가 됩니다.
     - 여기서 `111...1` 앞에 "110"들을 넣으면 `...0 (110...110) 111...1`이 됩니다.
     - "110"은 '1'로 시작하므로, `remain`의 앞쪽 '0'들보다는 뒤에 와야 하고, `remain` 뒤쪽의 '1'들보다는 앞에 와야 ('0'을 포함하므로) 사전 순으로 앞섭니다.
   - 만약 `remain`에 '0'이 없다면? (예: "111") -> 제일 앞에 넣습니다.

## Python 코드

```python
def solution(s):
    answer = []
    
    for string in s:
        # 1. '110' 추출하기 (Stack)
        stack = []
        count_110 = 0
        
        for char in string:
            stack.append(char)
            # 스택 끝 3자리가 110인지 확인
            if len(stack) >= 3 and stack[-1] == '0' and stack[-2] == '1' and stack[-3] == '1':
                stack.pop()
                stack.pop()
                stack.pop()
                count_110 += 1
                
        # 남은 문자열
        remain = "".join(stack)
        
        # 2. 삽입 위치 찾기: 마지막 '0'의 뒤
        # rfind가 없으면(모두 1이면) -1 리턴 -> index + 1 = 0 (맨 앞)
        idx = remain.rfind('0')
        
        if idx == -1:
            # 0이 없으면 맨 앞
            result = "110" * count_110 + remain
        else:
            # 마지막 0 바로 뒤에 삽입
            result = remain[:idx+1] + "110" * count_110 + remain[idx+1:]
            
        answer.append(result)
        
    return answer
```
